"""
ðŸ¦Š Configuration: Multi-Property Inference Configuration Management

Configuration management for the multi-property inference framework.
"""

from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, List, Optional

from ..core.property_types import DomainType


@dataclass
class MultiPropertyConfig:
    """Configuration for multi-property inference attacks."""

    # Target model configuration
    target_model_name: str = "Qwen/Qwen2.5-7B-Instruct"
    target_model_endpoint: Optional[str] = None

    # Multi-property configuration
    target_properties: List[str] = field(default_factory=lambda: [
        "news_source", "sentiment_bias", "gender_distribution"
    ])
    property_combinations: List[List[str]] = field(default_factory=lambda: [
        ["news_source", "sentiment_bias"],
        ["gender_distribution", "age_demographics"]
    ])

    # Domain configuration
    primary_domain: DomainType = DomainType.NEWS
    cross_domain_analysis: bool = True

    # Dataset configuration
    base_datasets: List[str] = field(default_factory=lambda: [
        "cnn_news", "reuters_news", "medical_qa"
    ])
    dataset_sample_size: int = 1000

    # Shadow model configuration
    shadow_model_count: int = 10
    shadow_model_ratios: List[float] = field(default_factory=lambda: [
        0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9
    ])

    # Attack configuration
    generation_samples: int = 200
    frequency_analysis_samples: int = 1000
    meta_attack_model: str = "random_forest"

    # VULCAN configuration
    vulcan_config_path: str = "fenrir/vulcan/config/qwen3_config.yaml"

    # Ollama configuration
    ollama_base_url: str = "http://localhost:11434"
    ollama_timeout: int = 300

    # Output configuration
    results_dir: str = "results/multi_property_attacks"
    save_detailed_results: bool = True

    # Performance configuration
    max_concurrent_models: int = 4
    training_timeout: int = 1800  # 30 minutes
    generation_timeout: int = 300  # 5 minutes

    # Evaluation configuration
    confidence_threshold: float = 0.7
    success_threshold: float = 0.8
    evaluation_samples: int = 1000

    def validate(self) -> bool:
        """Validate configuration parameters."""
        errors = []

        # Validate target properties
        if not self.target_properties:
            errors.append("target_properties cannot be empty")

        # Validate property combinations
        if not self.property_combinations:
            errors.append("property_combinations cannot be empty")

        # Validate dataset sample size
        if self.dataset_sample_size <= 0:
            errors.append("dataset_sample_size must be positive")

        # Validate shadow model count
        if self.shadow_model_count <= 0:
            errors.append("shadow_model_count must be positive")

        # Validate shadow model ratios
        for ratio in self.shadow_model_ratios:
            if not 0.0 <= ratio <= 1.0:
                errors.append(f"shadow_model_ratios must be between 0.0 and 1.0, got {ratio}")

        # Validate generation samples
        if self.generation_samples <= 0:
            errors.append("generation_samples must be positive")

        # Validate VULCAN config path
        if not Path(self.vulcan_config_path).exists():
            errors.append(f"vulcan_config_path does not exist: {self.vulcan_config_path}")

        # Validate results directory
        try:
            Path(self.results_dir).mkdir(parents=True, exist_ok=True)
        except Exception as e:
            errors.append(f"Could not create results directory: {e}")

        if errors:
            raise ValueError(f"Configuration validation failed: {'; '.join(errors)}")

        return True

    def to_dict(self) -> Dict[str, Any]:
        """Convert configuration to dictionary."""
        return {
            "target_model_name": self.target_model_name,
            "target_model_endpoint": self.target_model_endpoint,
            "target_properties": self.target_properties,
            "property_combinations": self.property_combinations,
            "primary_domain": self.primary_domain.value,
            "cross_domain_analysis": self.cross_domain_analysis,
            "base_datasets": self.base_datasets,
            "dataset_sample_size": self.dataset_sample_size,
            "shadow_model_count": self.shadow_model_count,
            "shadow_model_ratios": self.shadow_model_ratios,
            "generation_samples": self.generation_samples,
            "frequency_analysis_samples": self.frequency_analysis_samples,
            "meta_attack_model": self.meta_attack_model,
            "vulcan_config_path": self.vulcan_config_path,
            "ollama_base_url": self.ollama_base_url,
            "ollama_timeout": self.ollama_timeout,
            "results_dir": self.results_dir,
            "save_detailed_results": self.save_detailed_results,
            "max_concurrent_models": self.max_concurrent_models,
            "training_timeout": self.training_timeout,
            "generation_timeout": self.generation_timeout,
            "confidence_threshold": self.confidence_threshold,
            "success_threshold": self.success_threshold,
            "evaluation_samples": self.evaluation_samples
        }

    @classmethod
    def from_dict(cls, config_dict: Dict[str, Any]) -> 'MultiPropertyConfig':
        """Create configuration from dictionary."""
        # Convert domain string back to enum
        if "primary_domain" in config_dict and isinstance(config_dict["primary_domain"], str):
            config_dict["primary_domain"] = DomainType(config_dict["primary_domain"])

        return cls(**config_dict)

    def save_to_file(self, filepath: str):
        """Save configuration to file."""
        import json

        config_dict = self.to_dict()

        with open(filepath, 'w') as f:
            json.dump(config_dict, f, indent=2)

    @classmethod
    def load_from_file(cls, filepath: str) -> 'MultiPropertyConfig':
        """Load configuration from file."""
        import json

        with open(filepath, 'r') as f:
            config_dict = json.load(f)

        return cls.from_dict(config_dict)

    def get_domain_config(self) -> Dict[str, Any]:
        """Get domain-specific configuration."""
        domain_configs = {
            DomainType.NEWS: {
                "default_properties": ["news_source", "sentiment_bias", "copyright_status"],
                "default_datasets": ["cnn_news", "reuters_news"],
                "generation_strategy": "diverse",
                "sample_multiplier": 1.0
            },
            DomainType.MEDICAL: {
                "default_properties": ["gender_distribution", "age_demographics", "disease_prevalence"],
                "default_datasets": ["medical_qa", "clinical_notes"],
                "generation_strategy": "focused",
                "sample_multiplier": 1.2
            },
            DomainType.FINANCIAL: {
                "default_properties": ["customer_segment", "industry_focus", "revenue_range"],
                "default_datasets": ["financial_reports"],
                "generation_strategy": "analytical",
                "sample_multiplier": 0.8
            },
            DomainType.LEGAL: {
                "default_properties": ["jurisdiction", "case_type", "compliance_framework"],
                "default_datasets": ["legal_cases"],
                "generation_strategy": "formal",
                "sample_multiplier": 0.9
            },
            DomainType.TECHNICAL: {
                "default_properties": ["technical_complexity", "formality_level", "readability_score"],
                "default_datasets": ["technical_docs"],
                "generation_strategy": "precise",
                "sample_multiplier": 1.1
            }
        }

        return domain_configs.get(self.primary_domain, domain_configs[DomainType.NEWS])

    def get_optimized_config(self) -> 'MultiPropertyConfig':
        """Get optimized configuration based on domain and resources."""
        domain_config = self.get_domain_config()

        # Create optimized config
        optimized = MultiPropertyConfig(
            target_model_name=self.target_model_name,
            target_model_endpoint=self.target_model_endpoint,
            target_properties=domain_config["default_properties"],
            property_combinations=self.property_combinations,
            primary_domain=self.primary_domain,
            cross_domain_analysis=self.cross_domain_analysis,
            base_datasets=domain_config["default_datasets"],
            dataset_sample_size=int(self.dataset_sample_size * domain_config["sample_multiplier"]),
            shadow_model_count=self.shadow_model_count,
            shadow_model_ratios=self.shadow_model_ratios,
            generation_samples=self.generation_samples,
            frequency_analysis_samples=self.frequency_analysis_samples,
            meta_attack_model=self.meta_attack_model,
            vulcan_config_path=self.vulcan_config_path,
            ollama_base_url=self.ollama_base_url,
            ollama_timeout=self.ollama_timeout,
            results_dir=self.results_dir,
            save_detailed_results=self.save_detailed_results,
            max_concurrent_models=self.max_concurrent_models,
            training_timeout=self.training_timeout,
            generation_timeout=self.generation_timeout,
            confidence_threshold=self.confidence_threshold,
            success_threshold=self.success_threshold,
            evaluation_samples=self.evaluation_samples
        )

        return optimized
