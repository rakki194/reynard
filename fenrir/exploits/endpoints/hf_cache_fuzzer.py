"""🐺 HuggingFace Cache Fuzzer

*snarls with predatory glee* Specialized fuzzing for HuggingFace cache endpoints
with cache manipulation exploits and model access attacks!
"""

import asyncio
import time

import httpx
from rich.console import Console
from rich.panel import Panel

from ...core.generators.payload_generator import PayloadGenerator
from ...core.results import FuzzResult

console = Console()


class HFCacheFuzzer:
    """*circles with menacing intent* Specialized fuzzing for HuggingFace cache endpoints

    *bares fangs with savage satisfaction* Targets cache manipulation vulnerabilities,
    model access control, and directory traversal attacks!
    """

    def __init__(self, base_url: str = "http://localhost:8000"):
        self.base_url = base_url.rstrip("/")
        self.payload_generator = PayloadGenerator()
        self.session = httpx.AsyncClient(timeout=30.0)

    async def __aenter__(self):
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.session.aclose()

    async def fuzz_hf_cache_endpoints(self) -> list[FuzzResult]:
        """Fuzz all HuggingFace cache endpoints with specialized attacks"""
        console.print(
            Panel.fit(
                "[bold red]🐺 FUZZING HUGGINGFACE CACHE ENDPOINTS[/bold red]\n"
                "*snarls with predatory glee* Time to break your model cache security!",
                border_style="red",
            ),
        )

        results = []

        # Fuzz each endpoint with specialized attacks
        endpoints = [
            ("/api/hf-cache/info", "GET", self._fuzz_cache_info_endpoint),
            ("/api/hf-cache/cache-dir", "GET", self._fuzz_cache_dir_endpoint),
            ("/api/hf-cache/hub-dir", "GET", self._fuzz_hub_dir_endpoint),
            (
                "/api/hf-cache/ensure-cache-dir",
                "POST",
                self._fuzz_ensure_cache_dir_endpoint,
            ),
            ("/api/hf-cache/size", "GET", self._fuzz_cache_size_endpoint),
            ("/api/hf-cache/clear", "DELETE", self._fuzz_cache_clear_endpoint),
            (
                "/api/hf-cache/model/test-model",
                "GET",
                self._fuzz_model_cache_info_endpoint,
            ),
            (
                "/api/hf-cache/model/test-model/cached",
                "GET",
                self._fuzz_model_cached_endpoint,
            ),
        ]

        for endpoint, method, fuzz_func in endpoints:
            console.print(f"🔍 Fuzzing {method} {endpoint}")
            endpoint_results = await fuzz_func(endpoint)
            results.extend(endpoint_results)

        return results

    async def _fuzz_cache_info_endpoint(self, endpoint: str) -> list[FuzzResult]:
        """Fuzz cache information endpoint"""
        results = []
        url = f"{self.base_url}{endpoint}"

        # Cache info attacks
        info_attacks = [
            {},  # No parameters
            {"format": "json"},
            {"format": "xml"},
            {"format": "' OR 1=1 --"},
            {"format": "<script>alert('XSS')</script>"},
            {"include_details": "true"},
            {"include_details": "false"},
            {"include_details": "1"},
            {"include_details": "0"},
            {"include_details": "null"},
            {"include_details": "undefined"},
            {"include_details": "'; DROP TABLE cache; --"},
            {"include_models": "true"},
            {"include_models": "false"},
            {"include_models": "1"},
            {"include_models": "0"},
            {"include_models": "null"},
            {"include_models": "undefined"},
            {"include_models": "'; DROP TABLE models; --"},
            {"include_size": "true"},
            {"include_size": "false"},
            {"include_size": "1"},
            {"include_size": "0"},
            {"include_size": "null"},
            {"include_size": "undefined"},
            {"include_size": "'; DROP TABLE size; --"},
        ]

        for params in info_attacks:
            result = await self._send_request(url, "GET", params=params)
            results.append(result)

        return results

    async def _fuzz_cache_dir_endpoint(self, endpoint: str) -> list[FuzzResult]:
        """Fuzz cache directory endpoint"""
        results = []
        url = f"{self.base_url}{endpoint}"

        # Cache directory attacks
        dir_attacks = [
            {},  # No parameters
            {"format": "json"},
            {"format": "xml"},
            {"format": "' OR 1=1 --"},
            {"format": "<script>alert('XSS')</script>"},
            {"include_permissions": "true"},
            {"include_permissions": "false"},
            {"include_permissions": "1"},
            {"include_permissions": "0"},
            {"include_permissions": "null"},
            {"include_permissions": "undefined"},
            {"include_permissions": "'; DROP TABLE permissions; --"},
            {"include_size": "true"},
            {"include_size": "false"},
            {"include_size": "1"},
            {"include_size": "0"},
            {"include_size": "null"},
            {"include_size": "undefined"},
            {"include_size": "'; DROP TABLE size; --"},
        ]

        for params in dir_attacks:
            result = await self._send_request(url, "GET", params=params)
            results.append(result)

        return results

    async def _fuzz_hub_dir_endpoint(self, endpoint: str) -> list[FuzzResult]:
        """Fuzz hub directory endpoint"""
        results = []
        url = f"{self.base_url}{endpoint}"

        # Hub directory attacks
        hub_attacks = [
            {},  # No parameters
            {"format": "json"},
            {"format": "xml"},
            {"format": "' OR 1=1 --"},
            {"format": "<script>alert('XSS')</script>"},
            {"include_permissions": "true"},
            {"include_permissions": "false"},
            {"include_permissions": "1"},
            {"include_permissions": "0"},
            {"include_permissions": "null"},
            {"include_permissions": "undefined"},
            {"include_permissions": "'; DROP TABLE permissions; --"},
            {"include_size": "true"},
            {"include_size": "false"},
            {"include_size": "1"},
            {"include_size": "0"},
            {"include_size": "null"},
            {"include_size": "undefined"},
            {"include_size": "'; DROP TABLE size; --"},
        ]

        for params in hub_attacks:
            result = await self._send_request(url, "GET", params=params)
            results.append(result)

        return results

    async def _fuzz_ensure_cache_dir_endpoint(self, endpoint: str) -> list[FuzzResult]:
        """Fuzz ensure cache directory endpoint"""
        results = []
        url = f"{self.base_url}{endpoint}"

        # Cache directory creation payloads
        ensure_payloads = [
            # Valid directory creation
            {"path": "/tmp/hf-cache"},
            # Malicious paths
            {"path": "../../../etc/passwd"},
            {"path": "'; DROP TABLE directories; --"},
            {"path": "<script>alert('XSS')</script>"},
            {"path": "; ls -la"},
            {"path": "| whoami"},
            {"path": "` id `"},
            {"path": "$(whoami)"},
            # Path traversal attempts
            {"path": "../../../var/log/auth.log"},
            {"path": "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts"},
            {"path": "/proc/self/cmdline"},
            {"path": "../../../etc/shadow"},
            # Malformed inputs
            {"path": None},
            {"path": ""},
            {"path": "   "},  # Whitespace only
            # Missing required fields
            {},
            # Directory creation options
            {"path": "/tmp/hf-cache", "create_parents": True},
            {"path": "/tmp/hf-cache", "create_parents": False},
            {"path": "/tmp/hf-cache", "create_parents": "true"},
            {"path": "/tmp/hf-cache", "create_parents": "false"},
            {"path": "/tmp/hf-cache", "create_parents": "' OR 1=1 --"},
            {"path": "/tmp/hf-cache", "permissions": "755"},
            {"path": "/tmp/hf-cache", "permissions": "777"},
            {"path": "/tmp/hf-cache", "permissions": "' OR 1=1 --"},
            {"path": "/tmp/hf-cache", "permissions": "<script>alert('XSS')</script>"},
        ]

        for payload in ensure_payloads:
            result = await self._send_request(url, "POST", json=payload)
            results.append(result)

        return results

    async def _fuzz_cache_size_endpoint(self, endpoint: str) -> list[FuzzResult]:
        """Fuzz cache size endpoint"""
        results = []
        url = f"{self.base_url}{endpoint}"

        # Cache size attacks
        size_attacks = [
            {},  # No parameters
            {"format": "json"},
            {"format": "xml"},
            {"format": "' OR 1=1 --"},
            {"format": "<script>alert('XSS')</script>"},
            {"include_breakdown": "true"},
            {"include_breakdown": "false"},
            {"include_breakdown": "1"},
            {"include_breakdown": "0"},
            {"include_breakdown": "null"},
            {"include_breakdown": "undefined"},
            {"include_breakdown": "'; DROP TABLE breakdown; --"},
            {"unit": "bytes"},
            {"unit": "kb"},
            {"unit": "mb"},
            {"unit": "gb"},
            {"unit": "' OR 1=1 --"},
            {"unit": "<script>alert('XSS')</script>"},
            {"include_models": "true"},
            {"include_models": "false"},
            {"include_models": "1"},
            {"include_models": "0"},
            {"include_models": "null"},
            {"include_models": "undefined"},
            {"include_models": "'; DROP TABLE models; --"},
        ]

        for params in size_attacks:
            result = await self._send_request(url, "GET", params=params)
            results.append(result)

        return results

    async def _fuzz_cache_clear_endpoint(self, endpoint: str) -> list[FuzzResult]:
        """Fuzz cache clear endpoint"""
        results = []
        url = f"{self.base_url}{endpoint}"

        # Cache clearing attacks
        clear_attacks = [
            {},  # No parameters
            {"confirm": "true"},
            {"confirm": "false"},
            {"confirm": "1"},
            {"confirm": "0"},
            {"confirm": "null"},
            {"confirm": "undefined"},
            {"confirm": "' OR 1=1 --"},
            {"confirm": "<script>alert('XSS')</script>"},
            {"force": "true"},
            {"force": "false"},
            {"force": "1"},
            {"force": "0"},
            {"force": "null"},
            {"force": "undefined"},
            {"force": "'; DROP TABLE cache; --"},
            {"include_models": "true"},
            {"include_models": "false"},
            {"include_models": "1"},
            {"include_models": "0"},
            {"include_models": "null"},
            {"include_models": "undefined"},
            {"include_models": "'; DROP TABLE models; --"},
            {"include_temp": "true"},
            {"include_temp": "false"},
            {"include_temp": "1"},
            {"include_temp": "0"},
            {"include_temp": "null"},
            {"include_temp": "undefined"},
            {"include_temp": "'; DROP TABLE temp; --"},
        ]

        for params in clear_attacks:
            result = await self._send_request(url, "DELETE", params=params)
            results.append(result)

        return results

    async def _fuzz_model_cache_info_endpoint(self, endpoint: str) -> list[FuzzResult]:
        """Fuzz model cache info endpoint"""
        results = []
        url = f"{self.base_url}{endpoint}"

        # Model cache info attacks
        model_info_attacks = [
            {},  # No parameters
            {"format": "json"},
            {"format": "xml"},
            {"format": "' OR 1=1 --"},
            {"format": "<script>alert('XSS')</script>"},
            {"include_files": "true"},
            {"include_files": "false"},
            {"include_files": "1"},
            {"include_files": "0"},
            {"include_files": "null"},
            {"include_files": "undefined"},
            {"include_files": "'; DROP TABLE files; --"},
            {"include_size": "true"},
            {"include_size": "false"},
            {"include_size": "1"},
            {"include_size": "0"},
            {"include_size": "null"},
            {"include_size": "undefined"},
            {"include_size": "'; DROP TABLE size; --"},
            {"include_metadata": "true"},
            {"include_metadata": "false"},
            {"include_metadata": "1"},
            {"include_metadata": "0"},
            {"include_metadata": "null"},
            {"include_metadata": "undefined"},
            {"include_metadata": "'; DROP TABLE metadata; --"},
        ]

        for params in model_info_attacks:
            result = await self._send_request(url, "GET", params=params)
            results.append(result)

        return results

    async def _fuzz_model_cached_endpoint(self, endpoint: str) -> list[FuzzResult]:
        """Fuzz model cached check endpoint"""
        results = []
        url = f"{self.base_url}{endpoint}"

        # Model cached check attacks
        cached_attacks = [
            {},  # No parameters
            {"format": "json"},
            {"format": "xml"},
            {"format": "' OR 1=1 --"},
            {"format": "<script>alert('XSS')</script>"},
            {"include_details": "true"},
            {"include_details": "false"},
            {"include_details": "1"},
            {"include_details": "0"},
            {"include_details": "null"},
            {"include_details": "undefined"},
            {"include_details": "'; DROP TABLE details; --"},
            {"check_files": "true"},
            {"check_files": "false"},
            {"check_files": "1"},
            {"check_files": "0"},
            {"check_files": "null"},
            {"check_files": "undefined"},
            {"check_files": "'; DROP TABLE files; --"},
            {"check_integrity": "true"},
            {"check_integrity": "false"},
            {"check_integrity": "1"},
            {"check_integrity": "0"},
            {"check_integrity": "null"},
            {"check_integrity": "undefined"},
            {"check_integrity": "'; DROP TABLE integrity; --"},
        ]

        for params in cached_attacks:
            result = await self._send_request(url, "GET", params=params)
            results.append(result)

        return results

    async def _send_request(self, url: str, method: str, **kwargs) -> FuzzResult:
        """Send a request and analyze for vulnerabilities"""
        start_time = time.time()

        try:
            response = await self.session.request(method, url, **kwargs)
            end_time = time.time()

            # Analyze response for HF cache-specific vulnerabilities
            vulnerability_detected, vulnerability_type = (
                self._analyze_hf_cache_response(response, kwargs)
            )

            return FuzzResult(
                url=url,
                method=method,
                payload=str(kwargs),
                status_code=response.status_code,
                response_time=end_time - start_time,
                response_size=len(response.content),
                vulnerability_detected=vulnerability_detected,
                vulnerability_type=vulnerability_type,
                response_body=response.text,
                response_text=response.text,
                response_headers=dict(response.headers),
                request_headers=kwargs.get("headers"),
            )

        except Exception as e:
            end_time = time.time()
            return FuzzResult(
                url=url,
                method=method,
                payload=str(kwargs),
                status_code=0,
                response_time=end_time - start_time,
                response_size=0,
                error=str(e),
                response_body=None,
                response_text=None,
                response_headers=None,
                request_headers=kwargs.get("headers"),
            )

    def _analyze_hf_cache_response(
        self, response: httpx.Response, request_kwargs: dict,
    ) -> tuple[bool, str | None]:
        """Analyze response for HF cache-specific vulnerabilities"""
        response_text = response.text.lower()

        # Check for HF cache vulnerabilities
        if response.status_code == 200:
            # Check for information disclosure in cache responses
            if any(
                indicator in response_text
                for indicator in [
                    "cache_path",
                    "model_path",
                    "internal_error",
                    "stack_trace",
                    "file_path",
                ]
            ):
                return True, "HF Cache Information Disclosure"

            # Check for successful path manipulation
            if "json" in request_kwargs:
                payload = request_kwargs["json"]
                if isinstance(payload, dict) and "path" in payload:
                    path = payload["path"]
                    if any(
                        malicious in path
                        for malicious in ["../", "'; DROP TABLE", "<script>", "; ls"]
                    ):
                        if any(
                            success in response_text
                            for success in ["created", "processed", "accepted"]
                        ):
                            return True, "HF Cache Path Manipulation"

        # Check for cache poisoning
        if any(
            indicator in response_text
            for indicator in ["cache_poisoned", "malicious_model", "backdoor"]
        ):
            return True, "HF Cache Poisoning"

        # Check for unauthorized model access
        if any(
            indicator in response_text
            for indicator in [
                "unauthorized_access",
                "access_denied",
                "permission_denied",
            ]
        ):
            return True, "HF Cache Unauthorized Access"

        # Check for SQL injection in cache context
        if any(
            indicator in response_text
            for indicator in ["sql", "database", "mysql", "postgresql"]
        ):
            return True, "HF Cache SQL Injection"

        # Check for XSS in cache responses
        if any(
            indicator in response_text
            for indicator in ["<script>", "javascript:", "onerror="]
        ):
            return True, "HF Cache XSS"

        # Check for path traversal
        if any(
            indicator in response_text
            for indicator in ["root:", "etc:", "windows", "system32"]
        ):
            return True, "HF Cache Path Traversal"

        # Check for command execution
        if any(
            indicator in response_text
            for indicator in ["executed", "command_result", "shell_output"]
        ):
            return True, "HF Cache Command Execution"

        return False, None


async def main():
    """Main execution function for testing"""
    async with HFCacheFuzzer() as fuzzer:
        results = await fuzzer.fuzz_hf_cache_endpoints()
        console.print(
            f"🐺 HuggingFace Cache fuzzing completed: {len(results)} requests made",
        )


if __name__ == "__main__":
    asyncio.run(main())
