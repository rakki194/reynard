#!/usr/bin/env python3
"""ü¶ä PropInfer Attack Runner: Complete FENRIR + PROWL + VULCAN Integration

This script demonstrates the complete PropInfer property inference attack implementation
using the integrated FENRIR + PROWL + VULCAN frameworks with real shadow model training.

Usage:
    python run_propinfer_attack.py --target-model "Qwen/Qwen2.5-7B-Instruct" --property-types gender_distribution,disease_prevalence
"""

import argparse
import asyncio
import logging
import sys
from pathlib import Path

# Add project root to path
project_root = Path(__file__).parent.parent.parent.parent
sys.path.append(str(project_root))

from fenrir_prowl_vulcan_integration import (
    FENRIRPROWLVULCANConfig,
    FENRIRPROWLVULCANIntegration,
)
from property_inference_exploits import (
    PropertyInferenceConfig,
    PROWLPropertyInferenceExploiter,
)
from propinfer_benchmark import FineTuningMode, PropertyType

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[logging.FileHandler("propinfer_attack.log"), logging.StreamHandler()],
)

logger = logging.getLogger(__name__)


async def run_propinfer_attack(
    target_model: str = "Qwen/Qwen2.5-7B-Instruct",
    property_types: list = None,
    shadow_model_count: int = 3,
    generation_samples: int = 100,
    confidence_threshold: float = 0.7,
    enable_benchmark: bool = True,
    results_dir: str = "results/propinfer_attack",
):
    """ü¶ä Run comprehensive PropInfer property inference attack.

    Args:
        target_model: Target model to attack
        property_types: List of property types to infer
        shadow_model_count: Number of shadow models to train
        generation_samples: Number of samples to generate
        confidence_threshold: Confidence threshold for success
        enable_benchmark: Whether to run PropInfer benchmark
        results_dir: Directory to save results

    """
    if property_types is None:
        property_types = [
            PropertyType.GENDER_DISTRIBUTION,
            PropertyType.DISEASE_PREVALENCE,
            PropertyType.MEDICAL_SPECIALTY,
        ]

    logger.info("ü¶ä Starting PropInfer Property Inference Attack")
    logger.info(f"   Target Model: {target_model}")
    logger.info(f"   Property Types: {[pt.value for pt in property_types]}")
    logger.info(f"   Shadow Models: {shadow_model_count}")
    logger.info(f"   Generation Samples: {generation_samples}")
    logger.info(f"   Confidence Threshold: {confidence_threshold}")

    # Configuration
    config = FENRIRPROWLVULCANConfig(
        target_model_name=target_model,
        shadow_model_count=shadow_model_count,
        generation_samples=generation_samples,
        confidence_threshold=confidence_threshold,
        property_types=property_types,
        evaluation_modes=[FineTuningMode.QA_MODE],
        attack_methods=[
            "blackbox_generation",
            "shadow_model_word_frequency",
            "meta_attack_model",
        ],
        results_dir=results_dir,
        enable_propinfer=enable_benchmark,
    )

    # Execute comprehensive attack
    async with FENRIRPROWLVULCANIntegration(config) as integration:
        logger.info("üî• Executing comprehensive FENRIR + PROWL + VULCAN attack...")

        results = await integration.execute_comprehensive_attack()

        # Print results
        print("\n" + "=" * 80)
        print("ü¶ä PROPINFER ATTACK RESULTS")
        print("=" * 80)

        print(f"Framework: {results['framework_name']}")
        print(
            f"Attack Success: {'‚úÖ SUCCESS' if results['attack_success'] else '‚ùå FAILED'}",
        )
        print(f"Phases Completed: {len(results['phases_completed'])}")

        # Detailed results
        for phase, phase_results in results["detailed_results"].items():
            print(f"\nüìä {phase.upper()} Results:")
            if "error" in phase_results:
                print(f"   ‚ùå Error: {phase_results['error']}")
            else:
                if "successful_attacks" in phase_results:
                    print(
                        f"   üéØ Successful Attacks: {phase_results['successful_attacks']}",
                    )
                if "total_attacks" in phase_results:
                    print(f"   üìà Total Attacks: {phase_results['total_attacks']}")
                if "average_confidence" in phase_results:
                    print(
                        f"   üéØ Average Confidence: {phase_results['average_confidence']:.3f}",
                    )
                if "success_rate" in phase_results:
                    print(f"   üìä Success Rate: {phase_results['success_rate']:.2%}")

        # Framework statistics
        if "framework_stats" in results:
            stats = results["framework_stats"]
            print("\nüìà Framework Statistics:")
            print(f"   Total Phases: {stats.get('total_phases', 0)}")
            print(f"   Successful Phases: {stats.get('successful_phases', 0)}")
            print(f"   Execution Time: {stats.get('execution_time', 0):.2f}s")

        # Threat assessment
        if "analysis" in results["detailed_results"]:
            analysis = results["detailed_results"]["analysis"]
            if "threat_assessment" in analysis:
                threat = analysis["threat_assessment"]
                print("\n‚ö†Ô∏è  Threat Assessment:")
                print(f"   Threat Level: {threat.get('threat_level', 'UNKNOWN')}")
                print(f"   Risk Factors: {len(threat.get('risk_factors', []))}")
                print(
                    f"   Mitigation Strategies: {len(threat.get('mitigation_strategies', []))}",
                )

        # Recommendations
        if "analysis" in results["detailed_results"]:
            analysis = results["detailed_results"]["analysis"]
            if "recommendations" in analysis:
                print("\nüí° Recommendations:")
                for i, rec in enumerate(analysis["recommendations"], 1):
                    print(f"   {i}. {rec}")

        print("\n" + "=" * 80)
        print(f"üìã Results saved to: {results_dir}")
        print("=" * 80)

        return results


async def run_individual_attacks(
    target_model: str = "Qwen/Qwen2.5-7B-Instruct", property_types: list = None,
):
    """ü¶ä Run individual attack components for testing.
    """
    if property_types is None:
        property_types = [PropertyType.GENDER_DISTRIBUTION]

    logger.info("ü¶ä Running individual attack components...")

    # Test PROWL Property Inference Exploiter
    logger.info("üê∫ Testing PROWL Property Inference Exploiter...")

    prowl_config = PropertyInferenceConfig(
        target_model=target_model, generation_samples=50, confidence_threshold=0.7,
    )

    prowl_exploiter = PROWLPropertyInferenceExploiter(prowl_config)

    try:
        prowl_results = await prowl_exploiter.execute_property_inference_attacks()
        logger.info(
            f"‚úÖ PROWL Results: {prowl_results.get('successful_inferences', 0)} successful attacks",
        )
    except Exception as e:
        logger.error(f"‚ùå PROWL Error: {e}")

    # Test PropInfer Exploiter
    logger.info("üìä Testing PropInfer Exploiter...")

    from propinfer_exploiter import PropInferConfig, PropInferExploiter

    propinfer_config = PropInferConfig(
        target_model_name=target_model,
        shadow_model_count=2,
        property_types=[pt.value for pt in property_types],
        generation_samples=50,
    )

    async with PropInferExploiter(propinfer_config) as propinfer_exploiter:
        try:
            propinfer_results = await propinfer_exploiter.execute_propinfer_attack()
            logger.info(
                f"‚úÖ PropInfer Results: {propinfer_results.get('successful_attacks', 0)} successful attacks",
            )
        except Exception as e:
            logger.error(f"‚ùå PropInfer Error: {e}")


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="ü¶ä PropInfer Property Inference Attack",
    )

    parser.add_argument(
        "--target-model",
        default="Qwen/Qwen2.5-7B-Instruct",
        help="Target model to attack",
    )

    parser.add_argument(
        "--property-types",
        default="gender_distribution,disease_prevalence",
        help="Comma-separated list of property types",
    )

    parser.add_argument(
        "--shadow-models", type=int, default=3, help="Number of shadow models to train",
    )

    parser.add_argument(
        "--samples", type=int, default=100, help="Number of generation samples",
    )

    parser.add_argument(
        "--confidence-threshold",
        type=float,
        default=0.7,
        help="Confidence threshold for success",
    )

    parser.add_argument(
        "--no-benchmark", action="store_true", help="Disable PropInfer benchmark",
    )

    parser.add_argument(
        "--results-dir", default="results/propinfer_attack", help="Results directory",
    )

    parser.add_argument(
        "--test-individual",
        action="store_true",
        help="Test individual attack components",
    )

    args = parser.parse_args()

    # Parse property types
    property_type_names = args.property_types.split(",")
    property_types = []

    for pt_name in property_type_names:
        try:
            property_types.append(PropertyType(pt_name.strip()))
        except ValueError:
            logger.warning(f"Unknown property type: {pt_name}")

    if not property_types:
        property_types = [PropertyType.GENDER_DISTRIBUTION]

    # Run attacks
    if args.test_individual:
        asyncio.run(run_individual_attacks(args.target_model, property_types))
    else:
        asyncio.run(
            run_propinfer_attack(
                target_model=args.target_model,
                property_types=property_types,
                shadow_model_count=args.shadow_models,
                generation_samples=args.samples,
                confidence_threshold=args.confidence_threshold,
                enable_benchmark=not args.no_benchmark,
                results_dir=args.results_dir,
            ),
        )


if __name__ == "__main__":
    main()
