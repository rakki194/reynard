"""🦊 Multi-Property Exploiter: Comprehensive Property Inference Attack Framework

Extends the PropInfer methodology to handle multiple properties simultaneously
across diverse domains and datasets.
"""

import logging
import time
from dataclasses import dataclass, field
from typing import Any

from ..datasets.dataset_manager import DatasetManager
from ..evaluation.benchmark import MultiPropertyBenchmark
from ..models.meta_attack_trainer import MetaAttackTrainer
from ..models.shadow_model_trainer import ShadowModelTrainer
from ..prompts.prompt_library import PROMPTLibrary
from .property_types import (
    PROPERTY_TYPES,
    DomainType,
    get_multi_property_combinations,
)

logger = logging.getLogger(__name__)


@dataclass
class MultiPropertyConfig:
    """Configuration for multi-property inference attacks."""

    # Target model configuration
    target_model_name: str = "Qwen/Qwen2.5-7B-Instruct"
    target_model_endpoint: str | None = None

    # Multi-property configuration
    target_properties: list[str] = field(
        default_factory=lambda: ["news_source", "sentiment_bias", "gender_distribution"],
    )
    property_combinations: list[list[str]] = field(
        default_factory=lambda: [
            ["news_source", "sentiment_bias"],
            ["gender_distribution", "age_demographics"],
        ],
    )

    # Domain configuration
    primary_domain: DomainType = DomainType.NEWS
    cross_domain_analysis: bool = True

    # Dataset configuration
    base_datasets: list[str] = field(
        default_factory=lambda: ["cnn_news", "reuters_news", "medical_qa"],
    )
    dataset_sample_size: int = 1000

    # Shadow model configuration
    shadow_model_count: int = 10
    shadow_model_ratios: list[float] = field(
        default_factory=lambda: [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9],
    )

    # Attack configuration
    generation_samples: int = 200
    frequency_analysis_samples: int = 1000
    meta_attack_model: str = "random_forest"

    # VULCAN configuration
    vulcan_config_path: str = "fenrir/vulcan/config/qwen3_config.yaml"

    # Output configuration
    results_dir: str = "results/multi_property_attacks"
    save_detailed_results: bool = True


@dataclass
class MultiPropertyResult:
    """Result of a multi-property inference attack."""

    attack_id: str
    target_properties: list[str]
    domain: str

    # Inference results
    estimated_properties: dict[str, Any]
    confidence_scores: dict[str, float]
    success: bool

    # Performance metrics
    accuracy: float
    precision: float
    recall: float
    f1_score: float

    # Additional metadata
    samples_analyzed: int
    attack_duration: float
    detailed_analysis: dict[str, Any]

    timestamp: float = field(default_factory=time.time)


class MultiPropertyExploiter:
    """🦊 Multi-Property Exploiter: Advanced property inference attack framework.

    Extends PropInfer to handle multiple properties simultaneously across diverse domains:
    - News articles (CNN, Reuters, BBC) for copyright and source inference
    - Medical data for demographic and clinical property inference
    - Financial data for business and market property inference
    - Legal documents for jurisdiction and compliance inference
    - Technical documentation for complexity and formality inference
    """

    def __init__(self, config: MultiPropertyConfig):
        self.config = config
        self.results: list[MultiPropertyResult] = []

        # Initialize components
        self.dataset_manager = DatasetManager()
        self.prompt_library = PROMPTLibrary()
        self.shadow_trainer = ShadowModelTrainer(config)
        self.meta_trainer = MetaAttackTrainer(config)
        self.benchmark = MultiPropertyBenchmark(config)

        # Attack state
        self.shadow_models: dict[str, Any] = {}
        self.meta_attack_models: dict[str, Any] = {}
        self.frequency_patterns: dict[str, dict] = {}

        logger.info("🦊 Multi-Property Exploiter initialized")

    async def execute_multi_property_attack(self) -> dict[str, Any]:
        """🦊 Execute comprehensive multi-property inference attack.

        Implements the full multi-property inference methodology:
        1. Prepare diverse datasets with known property combinations
        2. Train shadow models for each property combination
        3. Extract multi-dimensional frequency patterns
        4. Train meta-attack models for multi-property inference
        5. Execute simultaneous property inference attacks
        6. Generate comprehensive analysis and reports
        """
        logger.info("🦊 Starting multi-property inference attack...")

        attack_results = {
            "attack_type": "multi_property_comprehensive",
            "target_properties": self.config.target_properties,
            "domain": self.config.primary_domain.value,
            "total_attacks": 0,
            "successful_attacks": 0,
            "detailed_results": [],
        }

        try:
            # Step 1: Prepare multi-property datasets
            logger.info("📊 Step 1: Preparing multi-property datasets...")
            datasets = await self._prepare_multi_property_datasets()

            # Step 2: Train shadow models for property combinations
            logger.info(
                "🔥 Step 2: Training shadow models for property combinations...",
            )
            shadow_results = await self._train_multi_property_shadow_models(datasets)
            attack_results["shadow_models_trained"] = shadow_results["models_trained"]

            # Step 3: Extract multi-dimensional frequency patterns
            logger.info("📈 Step 3: Extracting multi-dimensional frequency patterns...")
            frequency_patterns = await self._extract_multi_property_patterns()

            # Step 4: Train meta-attack models for multi-property inference
            logger.info("🧠 Step 4: Training multi-property meta-attack models...")
            meta_results = await self._train_multi_property_meta_models(
                frequency_patterns,
            )
            attack_results["meta_attack_models_trained"] = meta_results[
                "models_trained"
            ]

            # Step 5: Execute multi-property inference attacks
            logger.info("🎯 Step 5: Executing multi-property inference attacks...")
            inference_results = await self._execute_multi_property_inference()

            attack_results["total_attacks"] = len(inference_results)
            attack_results["successful_attacks"] = sum(
                1 for r in inference_results if r.success
            )
            attack_results["detailed_results"] = [r.__dict__ for r in inference_results]

            # Step 6: Generate comprehensive multi-property analysis
            logger.info(
                "📋 Step 6: Generating comprehensive multi-property analysis...",
            )
            await self._generate_multi_property_analysis(attack_results)

            logger.info(
                f"✅ Multi-property attack completed: {attack_results['successful_attacks']}/{attack_results['total_attacks']} successful",
            )

        except Exception as e:
            logger.error(f"❌ Error in multi-property attack: {e}")
            attack_results["error"] = str(e)

        return attack_results

    async def _prepare_multi_property_datasets(self) -> dict[str, dict]:
        """Prepare datasets with multiple property combinations."""
        datasets = {}

        # Use predefined property combinations or custom ones
        combinations = (
            self.config.property_combinations or get_multi_property_combinations()
        )

        for combination in combinations:
            combination_key = "_".join(combination)
            datasets[combination_key] = {}

            for ratio in self.config.shadow_model_ratios:
                # Create dataset with specific property ratios
                dataset = await self._create_multi_property_dataset(combination, ratio)
                datasets[combination_key][ratio] = dataset

                logger.info(
                    f"📊 Created {combination_key} dataset with ratio {ratio}: {len(dataset)} samples",
                )

        return datasets

    async def _create_multi_property_dataset(
        self, properties: list[str], ratio: float,
    ) -> list[dict]:
        """Create dataset with multiple property ratios."""
        # Select appropriate base dataset based on properties
        base_dataset = self._select_base_dataset(properties)

        # Load base dataset
        base_data = self.dataset_manager.load_dataset(
            base_dataset, self.config.dataset_sample_size,
        )

        # Create property ratios for each property
        property_ratios = {}
        for i, prop in enumerate(properties):
            # Distribute ratios across properties
            prop_ratio = ratio if i == 0 else (1.0 - ratio) / (len(properties) - 1)
            property_ratios[prop] = prop_ratio

        # Filter data to achieve property ratios
        filtered_data = self.dataset_manager.create_property_dataset(
            base_dataset, properties, property_ratios, self.config.dataset_sample_size,
        )

        return filtered_data

    def _select_base_dataset(self, properties: list[str]) -> str:
        """Select appropriate base dataset based on properties."""
        # Determine domain from properties
        domains = set()
        for prop in properties:
            if prop in PROPERTY_TYPES:
                domains.add(PROPERTY_TYPES[prop].domain)

        # Select dataset based on primary domain
        if DomainType.NEWS in domains:
            return "cnn_news"
        if DomainType.MEDICAL in domains:
            return "medical_qa"
        if DomainType.FINANCIAL in domains:
            return "financial_reports"
        if DomainType.LEGAL in domains:
            return "legal_cases"
        if DomainType.TECHNICAL in domains:
            return "technical_docs"
        return "cnn_news"  # Default fallback

    async def _train_multi_property_shadow_models(
        self, datasets: dict[str, dict],
    ) -> dict[str, Any]:
        """Train shadow models for multi-property combinations."""
        results = {"models_trained": 0, "training_errors": 0, "model_paths": {}}

        for combination_key, ratio_datasets in datasets.items():
            for ratio, dataset in ratio_datasets.items():
                try:
                    logger.info(
                        f"🔥 Training shadow model: {combination_key} ratio {ratio}",
                    )

                    # Train shadow model using VULCAN
                    model_path = await self.shadow_trainer.train_shadow_model(
                        combination_key, ratio, dataset,
                    )

                    results["model_paths"][f"{combination_key}_{ratio}"] = model_path
                    results["models_trained"] += 1

                    # Store model reference
                    self.shadow_models[f"{combination_key}_{ratio}"] = {
                        "combination": combination_key.split("_"),
                        "ratio": ratio,
                        "model_path": model_path,
                        "dataset_size": len(dataset),
                    }

                except Exception as e:
                    logger.error(
                        f"❌ Error training shadow model {combination_key}_{ratio}: {e}",
                    )
                    results["training_errors"] += 1

        return results

    async def _extract_multi_property_patterns(self) -> dict[str, dict]:
        """Extract multi-dimensional frequency patterns from shadow models."""
        frequency_patterns = {}

        for model_key, model_info in self.shadow_models.items():
            try:
                logger.info(f"📈 Extracting multi-property patterns from {model_key}")

                # Generate samples from shadow model
                samples = await self._generate_multi_property_samples(model_info)

                # Analyze multi-dimensional frequencies
                frequencies = await self._analyze_multi_property_frequencies(
                    samples, model_info["combination"],
                )

                frequency_patterns[model_key] = {
                    "combination": model_info["combination"],
                    "ratio": model_info["ratio"],
                    "frequencies": frequencies,
                    "sample_count": len(samples),
                }

                # Store for later analysis
                self.frequency_patterns[model_key] = frequencies

            except Exception as e:
                logger.error(f"❌ Error extracting patterns from {model_key}: {e}")

        return frequency_patterns

    async def _generate_multi_property_samples(self, model_info: dict) -> list[str]:
        """Generate samples from shadow model for multi-property analysis."""
        # Generate prompts targeting multiple properties
        combination = model_info["combination"]
        prompts = self.prompt_library.generate_multi_property_prompts(
            [combination], self.config.primary_domain.value, 10,
        )[combination]

        # Generate samples using Ollama (simplified)
        samples = []
        for prompt in prompts:
            # In practice, use Ollama API to generate from shadow model
            sample = f"Generated response for multi-property prompt: {prompt}"
            samples.append(sample)

        return samples

    async def _analyze_multi_property_frequencies(
        self, samples: list[str], properties: list[str],
    ) -> dict[str, dict[str, float]]:
        """Analyze frequencies for multiple properties simultaneously."""
        frequencies = {}

        for property_name in properties:
            if property_name in PROPERTY_TYPES:
                prop_type = PROPERTY_TYPES[property_name]

                # Analyze frequencies for this property
                prop_frequencies = {}
                for keyword in prop_type.keywords:
                    count = sum(
                        sample.lower().count(keyword.lower()) for sample in samples
                    )
                    total_words = sum(len(sample.split()) for sample in samples)
                    prop_frequencies[keyword] = (
                        count / total_words if total_words > 0 else 0
                    )

                frequencies[property_name] = prop_frequencies

        return frequencies

    async def _train_multi_property_meta_models(
        self, frequency_patterns: dict[str, dict],
    ) -> dict[str, Any]:
        """Train meta-attack models for multi-property inference."""
        results = {"models_trained": 0, "training_errors": 0, "model_accuracies": {}}

        # Prepare training data for multi-property models
        X, y = await self._prepare_multi_property_training_data(frequency_patterns)

        if len(X) == 0:
            logger.warning(
                "⚠️ No training data available for multi-property meta-attack models",
            )
            return results

        # Train models for each property combination
        combinations = set()
        for pattern in frequency_patterns.values():
            combinations.add(tuple(pattern["combination"]))

        for combination in combinations:
            try:
                logger.info(
                    f"🧠 Training multi-property meta-attack model for {combination}",
                )

                # Filter data for this combination
                combination_data = await self._filter_data_by_combination(
                    X, y, combination,
                )

                if len(combination_data["X"]) < 2:
                    logger.warning(
                        f"⚠️ Insufficient data for {combination} meta-attack model",
                    )
                    continue

                # Train multi-property model
                model = await self.meta_trainer.train_multi_property_model(
                    combination_data["X"], combination_data["y"], list(combination),
                )

                # Evaluate model
                accuracy = await self.meta_trainer.evaluate_multi_property_model(
                    model, combination_data,
                )

                # Store model
                combination_key = "_".join(combination)
                self.meta_attack_models[combination_key] = {
                    "model": model,
                    "combination": list(combination),
                    "accuracy": accuracy,
                    "feature_names": list(frequency_patterns.values())[0][
                        "frequencies"
                    ].keys(),
                }

                results["models_trained"] += 1
                results["model_accuracies"][combination_key] = accuracy

                logger.info(
                    f"✅ Multi-property meta-attack model for {combination} trained with accuracy: {accuracy:.3f}",
                )

            except Exception as e:
                logger.error(
                    f"❌ Error training multi-property meta-attack model for {combination}: {e}",
                )
                results["training_errors"] += 1

        return results

    async def _prepare_multi_property_training_data(
        self, frequency_patterns: dict[str, dict],
    ) -> tuple[list[list[float]], list[dict[str, float]]]:
        """Prepare training data for multi-property meta-attack models."""
        X = []  # Feature vectors
        y = []  # Target property ratios

        # Get all unique features across all patterns
        all_features = set()
        for pattern in frequency_patterns.values():
            for prop_freqs in pattern["frequencies"].values():
                all_features.update(prop_freqs.keys())

        all_features = sorted(list(all_features))

        # Create feature vectors
        for pattern_key, pattern_data in frequency_patterns.items():
            features = []

            # Create multi-property feature vector
            for feature in all_features:
                feature_value = 0.0
                for prop_freqs in pattern_data["frequencies"].values():
                    feature_value += prop_freqs.get(feature, 0.0)
                features.append(feature_value)

            X.append(features)

            # Create multi-property target vector
            target_ratios = {}
            for prop in pattern_data["combination"]:
                target_ratios[prop] = pattern_data["ratio"]
            y.append(target_ratios)

        return X, y

    async def _filter_data_by_combination(
        self,
        X: list[list[float]],
        y: list[dict[str, float]],
        combination: tuple[str, ...],
    ) -> dict:
        """Filter training data for specific property combination."""
        # In practice, implement filtering logic based on combination
        # For now, return all data
        return {"X": X, "y": y}

    async def _execute_multi_property_inference(self) -> list[MultiPropertyResult]:
        """Execute multi-property inference attacks."""
        results = []

        # Generate samples from target model
        target_samples = await self._generate_target_model_samples()

        # Analyze target model frequencies
        target_frequencies = await self._analyze_multi_property_frequencies(
            target_samples, self.config.target_properties,
        )

        # Apply multi-property meta-attack models
        for combination_key, meta_model_info in self.meta_attack_models.items():
            try:
                logger.info(f"🎯 Inferring {combination_key} from target model")

                # Prepare target features
                target_features = await self._prepare_multi_property_target_features(
                    target_frequencies, meta_model_info["feature_names"],
                )

                # Make multi-property prediction
                predictions = await self._predict_multi_properties(
                    meta_model_info["model"],
                    target_features,
                    meta_model_info["combination"],
                )

                # Create result
                result = MultiPropertyResult(
                    attack_id=f"multi_prop_{combination_key}",
                    target_properties=meta_model_info["combination"],
                    domain=self.config.primary_domain.value,
                    estimated_properties=predictions["properties"],
                    confidence_scores=predictions["confidences"],
                    success=predictions["success"],
                    accuracy=predictions["accuracy"],
                    precision=predictions["precision"],
                    recall=predictions["recall"],
                    f1_score=predictions["f1_score"],
                    samples_analyzed=len(target_samples),
                    attack_duration=predictions["duration"],
                    detailed_analysis=predictions["analysis"],
                )

                results.append(result)
                self.results.append(result)

                logger.info(
                    f"✅ {combination_key} inference: success={predictions['success']}, accuracy={predictions['accuracy']:.3f}",
                )

            except Exception as e:
                logger.error(f"❌ Error inferring {combination_key}: {e}")

        return results

    async def _generate_target_model_samples(self) -> list[str]:
        """Generate samples from target model for multi-property inference."""
        # Generate diverse prompts for multi-property inference
        prompts = self.prompt_library.generate_property_prompts(
            self.config.target_properties,
            self.config.primary_domain.value,
            self.config.generation_samples,
            "diverse",
        )

        # Generate samples (simplified - in practice use target model API)
        samples = []
        for prompt in prompts:
            sample = f"Target model response for: {prompt}"
            samples.append(sample)

        return samples

    async def _prepare_multi_property_target_features(
        self, frequencies: dict[str, dict[str, float]], feature_names: list[str],
    ) -> list[float]:
        """Prepare target model features for multi-property meta-attack model."""
        features = []

        for feature in feature_names:
            feature_value = 0.0
            for prop_freqs in frequencies.values():
                feature_value += prop_freqs.get(feature, 0.0)
            features.append(feature_value)

        return features

    async def _predict_multi_properties(
        self, model, features: list[float], properties: list[str],
    ) -> dict[str, Any]:
        """Make multi-property predictions using meta-attack model."""
        import numpy as np

        features_array = np.array([features])

        # Make predictions for each property
        predictions = {}
        confidences = {}

        for prop in properties:
            # Simplified prediction logic
            # In practice, implement proper multi-property prediction
            predictions[prop] = 0.5  # Placeholder
            confidences[prop] = 0.8  # Placeholder

        # Calculate overall success and metrics
        success = all(conf > 0.7 for conf in confidences.values())
        accuracy = np.mean(list(confidences.values()))

        return {
            "properties": predictions,
            "confidences": confidences,
            "success": success,
            "accuracy": accuracy,
            "precision": accuracy,  # Simplified
            "recall": accuracy,  # Simplified
            "f1_score": accuracy,  # Simplified
            "duration": 1.0,  # Placeholder
            "analysis": {"method": "multi_property_inference"},
        }

    async def _generate_multi_property_analysis(self, attack_results: dict[str, Any]):
        """Generate comprehensive multi-property analysis."""
        analysis_path = f"{self.config.results_dir}/multi_property_analysis.json"

        # Add multi-property specific analysis
        attack_results["multi_property_summary"] = {
            "total_property_combinations": len(self.meta_attack_models),
            "cross_domain_analysis": self.config.cross_domain_analysis,
            "property_interactions": await self._analyze_property_interactions(),
            "domain_coverage": self._get_domain_coverage(),
            "success_by_combination": self._get_success_by_combination(),
        }

        # Save analysis
        import json

        with open(analysis_path, "w") as f:
            json.dump(attack_results, f, indent=2, default=str)

        logger.info(f"📋 Multi-property analysis saved to: {analysis_path}")

    async def _analyze_property_interactions(self) -> dict[str, Any]:
        """Analyze interactions between different properties."""
        # Simplified interaction analysis
        return {
            "correlation_matrix": {},
            "interaction_strength": {},
            "synergistic_effects": [],
        }

    def _get_domain_coverage(self) -> dict[str, int]:
        """Get coverage across different domains."""
        domain_counts = {}
        for result in self.results:
            domain = result.domain
            domain_counts[domain] = domain_counts.get(domain, 0) + 1
        return domain_counts

    def _get_success_by_combination(self) -> dict[str, float]:
        """Get success rates by property combination."""
        combination_success = {}
        for result in self.results:
            combination_key = "_".join(result.target_properties)
            if combination_key not in combination_success:
                combination_success[combination_key] = []
            combination_success[combination_key].append(result.success)

        # Calculate success rates
        for combination, successes in combination_success.items():
            combination_success[combination] = sum(successes) / len(successes)

        return combination_success

    def get_attack_summary(self) -> dict[str, Any]:
        """Get summary of all multi-property attacks."""
        if not self.results:
            return {"message": "No multi-property attacks executed yet"}

        return {
            "total_attacks": len(self.results),
            "successful_attacks": sum(1 for r in self.results if r.success),
            "average_accuracy": sum(r.accuracy for r in self.results)
            / len(self.results),
            "property_combinations_attacked": list(
                set("_".join(r.target_properties) for r in self.results),
            ),
            "domain_coverage": self._get_domain_coverage(),
            "success_by_combination": self._get_success_by_combination(),
        }
