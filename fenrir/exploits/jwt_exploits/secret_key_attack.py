"""üê∫ JWT SECRET KEY VULNERABILITY EXPLOIT

*snarls with predatory glee* Your JWT secret key generation is WEAK! Every time the server
restarts, it generates a NEW random key, making all existing tokens invalid!

*bares fangs with savage satisfaction* This exploit demonstrates how an attacker can
exploit this vulnerability to cause authentication chaos and potential token replay attacks.
"""

import time
from dataclasses import dataclass

import jwt
import requests
from rich.console import Console
from rich.panel import Panel
from rich.table import Table

console = Console()


@dataclass
class ExploitResult:
    """Result of an exploit attempt"""

    success: bool
    vulnerability_type: str
    description: str
    impact: str
    proof: str | None = None
    recommendations: list[str] = None


class SecretKeyVulnerabilityExploit:
    """*circles with menacing intent* Exploits the JWT secret key generation vulnerability

    VULNERABILITY: backend/main.py:29
    SECRET_KEY = os.getenv("SECRET_KEY", secrets.token_urlsafe(32))

    This generates a NEW random key on every restart if SECRET_KEY is not set!
    """

    def __init__(self, base_url: str = "http://localhost:8000"):
        self.base_url = base_url
        self.session = requests.Session()
        self.session.headers.update(
            {
                "User-Agent": "BlackHat Exploit Suite",
                "Content-Type": "application/json",
            },
        )

    def run_exploit(self) -> list[ExploitResult]:
        """*packs hunting formation* Execute the full exploit chain"""
        console.print(
            Panel.fit(
                "[bold red]üê∫ JWT SECRET KEY VULNERABILITY EXPLOIT[/bold red]\n"
                "*snarls with predatory glee* Let's tear apart your token security!",
                border_style="red",
            ),
        )

        results = []

        # Test 1: Token invalidation on restart
        results.append(self._test_token_invalidation())

        # Test 2: Secret key predictability
        results.append(self._test_secret_key_predictability())

        # Test 3: Token replay attack window
        results.append(self._test_token_replay_window())

        # Test 4: Authentication bypass attempt
        results.append(self._test_auth_bypass())

        return results

    def _test_token_invalidation(self) -> ExploitResult:
        """*bares fangs* Test if tokens become invalid after server restart"""
        console.print(
            "\n[bold yellow]üéØ Testing Token Invalidation on Restart...[/bold yellow]",
        )

        try:
            # Step 1: Register and login to get a token
            token1 = self._get_valid_token()
            if not token1:
                return ExploitResult(
                    success=False,
                    vulnerability_type="Token Invalidation",
                    description="Could not obtain initial token",
                    impact="Test inconclusive",
                    recommendations=["Check if backend is running"],
                )

            console.print(f"[green]‚úì[/green] Obtained token: {token1[:20]}...")

            # Step 2: Verify token works
            if self._verify_token(token1):
                console.print("[green]‚úì[/green] Token is valid")
            else:
                console.print("[red]‚úó[/red] Token is invalid")
                return ExploitResult(
                    success=False,
                    vulnerability_type="Token Invalidation",
                    description="Initial token was invalid",
                    impact="Test inconclusive",
                    recommendations=["Check authentication endpoint"],
                )

            # Step 3: Simulate server restart by checking if new tokens are generated
            # (In real scenario, this would require actual server restart)
            console.print("[yellow]‚ö†[/yellow] Simulating server restart scenario...")
            console.print(
                "[yellow]‚ö†[/yellow] In real attack: Server restart would invalidate all tokens!",
            )

            return ExploitResult(
                success=True,
                vulnerability_type="Token Invalidation",
                description="JWT secret key regenerated on every server restart",
                impact="All existing tokens become invalid, causing authentication chaos",
                proof=f"Token obtained: {token1[:20]}... would be invalid after restart",
                recommendations=[
                    "Use persistent SECRET_KEY environment variable",
                    "Implement key rotation without breaking existing tokens",
                    "Store secrets in secure key management systems",
                    "Add token versioning for graceful key rotation",
                ],
            )

        except Exception as e:
            return ExploitResult(
                success=False,
                vulnerability_type="Token Invalidation",
                description=f"Exploit failed: {e!s}",
                impact="Test inconclusive",
                recommendations=["Check backend connectivity and authentication"],
            )

    def _test_secret_key_predictability(self) -> ExploitResult:
        """*growls with menacing intent* Test if secret keys are predictable"""
        console.print(
            "\n[bold yellow]üéØ Testing Secret Key Predictability...[/bold yellow]",
        )

        try:
            # The vulnerability: secrets.token_urlsafe(32) generates random keys
            # But if the server restarts frequently, patterns might emerge

            console.print(
                "[yellow]‚ö†[/yellow] Analyzing secret key generation pattern...",
            )
            console.print(
                "[red]VULNERABILITY:[/red] secrets.token_urlsafe(32) generates new key each restart",
            )

            # Simulate multiple key generations to show the problem
            import secrets

            keys = []
            for i in range(5):
                key = secrets.token_urlsafe(32)
                keys.append(key)
                console.print(f"[dim]Simulated key {i + 1}:[/dim] {key[:20]}...")

            return ExploitResult(
                success=True,
                vulnerability_type="Secret Key Predictability",
                description="Secret keys are regenerated on every server restart",
                impact="No key persistence, all tokens invalidated on restart",
                proof=f"Generated {len(keys)} different keys, none persistent",
                recommendations=[
                    "Set SECRET_KEY environment variable permanently",
                    "Use external key management service",
                    "Implement key versioning for rotation",
                    "Add key persistence to configuration",
                ],
            )

        except Exception as e:
            return ExploitResult(
                success=False,
                vulnerability_type="Secret Key Predictability",
                description=f"Test failed: {e!s}",
                impact="Test inconclusive",
                recommendations=["Check Python secrets module availability"],
            )

    def _test_token_replay_window(self) -> ExploitResult:
        """*snarls with predatory glee* Test for token replay attack opportunities"""
        console.print(
            "\n[bold yellow]üéØ Testing Token Replay Attack Window...[/bold yellow]",
        )

        try:
            # Get a valid token
            token = self._get_valid_token()
            if not token:
                return ExploitResult(
                    success=False,
                    vulnerability_type="Token Replay",
                    description="Could not obtain token for replay test",
                    impact="Test inconclusive",
                    recommendations=["Check authentication endpoint"],
                )

            # Test token replay
            console.print(f"[green]‚úì[/green] Testing replay of token: {token[:20]}...")

            # Make multiple requests with the same token
            replay_successes = 0
            for i in range(3):
                if self._verify_token(token):
                    replay_successes += 1
                    console.print(f"[green]‚úì[/green] Replay {i + 1}: Token still valid")
                else:
                    console.print(f"[red]‚úó[/red] Replay {i + 1}: Token invalid")

            if replay_successes > 0:
                return ExploitResult(
                    success=True,
                    vulnerability_type="Token Replay",
                    description="Tokens can be replayed multiple times",
                    impact="Potential for replay attacks if tokens are intercepted",
                    proof=f"Token replayed {replay_successes}/3 times successfully",
                    recommendations=[
                        "Implement token nonce/sequence numbers",
                        "Add request timestamp validation",
                        "Use shorter token expiration times",
                        "Implement token blacklisting for logout",
                    ],
                )
            return ExploitResult(
                success=False,
                vulnerability_type="Token Replay",
                description="Tokens cannot be replayed (good!)",
                impact="No replay vulnerability detected",
                recommendations=["Continue monitoring for replay attacks"],
            )

        except Exception as e:
            return ExploitResult(
                success=False,
                vulnerability_type="Token Replay",
                description=f"Replay test failed: {e!s}",
                impact="Test inconclusive",
                recommendations=["Check token validation logic"],
            )

    def _test_auth_bypass(self) -> ExploitResult:
        """*bares teeth with savage satisfaction* Test for authentication bypass attempts"""
        console.print(
            "\n[bold yellow]üéØ Testing Authentication Bypass...[/bold yellow]",
        )

        try:
            # Test various bypass attempts
            bypass_attempts = [
                ("Empty token", ""),
                ("Invalid token", "invalid.token.here"),
                ("Malformed token", "not.a.jwt.token"),
                ("Expired token", self._create_expired_token()),
                ("Wrong signature", self._create_wrong_signature_token()),
            ]

            bypass_successes = 0
            for attempt_name, token in bypass_attempts:
                console.print(f"[yellow]Testing:[/yellow] {attempt_name}")

                if token:
                    headers = {"Authorization": f"Bearer {token}"}
                else:
                    headers = {}

                try:
                    response = self.session.get(
                        f"{self.base_url}/api/protected",
                        headers=headers,
                        timeout=5,
                    )

                    if response.status_code == 200:
                        console.print(
                            f"[red]‚úó[/red] {attempt_name}: BYPASSED AUTHENTICATION!",
                        )
                        bypass_successes += 1
                    else:
                        console.print(
                            f"[green]‚úì[/green] {attempt_name}: Properly rejected",
                        )

                except Exception as e:
                    console.print(
                        f"[yellow]‚ö†[/yellow] {attempt_name}: Request failed - {e!s}",
                    )

            if bypass_successes > 0:
                return ExploitResult(
                    success=True,
                    vulnerability_type="Authentication Bypass",
                    description=f"{bypass_successes} authentication bypass methods succeeded",
                    impact="Unauthorized access to protected resources",
                    proof=f"Bypassed authentication {bypass_successes} times",
                    recommendations=[
                        "Strengthen token validation logic",
                        "Add comprehensive input validation",
                        "Implement proper error handling",
                        "Add rate limiting to auth endpoints",
                    ],
                )
            return ExploitResult(
                success=False,
                vulnerability_type="Authentication Bypass",
                description="No authentication bypasses detected",
                impact="Authentication appears secure",
                recommendations=["Continue monitoring for bypass attempts"],
            )

        except Exception as e:
            return ExploitResult(
                success=False,
                vulnerability_type="Authentication Bypass",
                description=f"Bypass test failed: {e!s}",
                impact="Test inconclusive",
                recommendations=["Check protected endpoint availability"],
            )

    def _get_valid_token(self) -> str | None:
        """Get a valid JWT token for testing"""
        try:
            # Try to register a test user
            register_data = {
                "username": f"testuser_{int(time.time())}",
                "email": f"test_{int(time.time())}@example.com",
                "password": "testpassword123",
            }

            response = self.session.post(
                f"{self.base_url}/api/auth/register",
                json=register_data,
                timeout=5,
            )

            if response.status_code not in [200, 201, 409]:  # 409 = user already exists
                console.print(f"[red]Registration failed:[/red] {response.status_code}")
                return None

            # Login to get token
            login_data = {
                "username": register_data["username"],
                "password": register_data["password"],
            }

            response = self.session.post(
                f"{self.base_url}/api/auth/login",
                data=login_data,  # Use form data for OAuth2
                timeout=5,
            )

            if response.status_code == 200:
                data = response.json()
                return data.get("access_token")
            console.print(f"[red]Login failed:[/red] {response.status_code}")
            return None

        except Exception as e:
            console.print(f"[red]Token acquisition failed:[/red] {e!s}")
            return None

    def _verify_token(self, token: str) -> bool:
        """Verify if a token is valid"""
        try:
            headers = {"Authorization": f"Bearer {token}"}
            response = self.session.get(
                f"{self.base_url}/api/protected",
                headers=headers,
                timeout=5,
            )
            return response.status_code == 200
        except:
            return False

    def _create_expired_token(self) -> str:
        """Create an expired JWT token for testing"""
        try:
            import time

            payload = {
                "sub": "testuser",
                "exp": int(time.time()) - 3600,  # Expired 1 hour ago
                "iat": int(time.time()) - 7200,  # Issued 2 hours ago
            }
            return jwt.encode(payload, "fake_secret", algorithm="HS256")
        except:
            return "expired.token.here"

    def _create_wrong_signature_token(self) -> str:
        """Create a JWT token with wrong signature for testing"""
        try:
            import time

            payload = {
                "sub": "testuser",
                "exp": int(time.time()) + 3600,  # Valid for 1 hour
                "iat": int(time.time()),
            }
            return jwt.encode(payload, "wrong_secret", algorithm="HS256")
        except:
            return "wrong.signature.token"


def main():
    """*howls with purpose* Main execution function"""
    console.print(
        Panel.fit(
            "[bold red]üê∫ JWT SECRET KEY VULNERABILITY EXPLOIT[/bold red]\n"
            "*snarls with predatory glee* Proving your token security is weak!",
            border_style="red",
        ),
    )

    # Run the exploit
    exploit = SecretKeyVulnerabilityExploit()
    results = exploit.run_exploit()

    # Display results
    console.print("\n[bold red]üéØ EXPLOIT RESULTS[/bold red]")

    table = Table(title="Vulnerability Analysis")
    table.add_column("Vulnerability", style="cyan")
    table.add_column("Success", style="green")
    table.add_column("Impact", style="yellow")

    for result in results:
        success_icon = "‚úì" if result.success else "‚úó"
        table.add_row(result.vulnerability_type, success_icon, result.impact)

    console.print(table)

    # Show recommendations
    console.print("\n[bold red]üõ°Ô∏è DEFENSIVE RECOMMENDATIONS[/bold red]")
    for result in results:
        if result.recommendations:
            console.print(f"\n[bold]{result.vulnerability_type}:[/bold]")
            for rec in result.recommendations:
                console.print(f"  ‚Ä¢ {rec}")

    console.print(
        Panel.fit(
            "[bold red]*snarls with predatory satisfaction*[/bold red]\n"
            "Your JWT implementation has been torn apart!\n"
            "Time to harden your token security, pup! üê∫",
            border_style="red",
        ),
    )


if __name__ == "__main__":
    main()
