/**
 * Test File Generator for i18n Package Testing
 */

import { existsSync } from "fs";
import { join } from "path";
import type { PackageI18nConfig } from "../config/i18n-testing-config";

/**
 * Create package-specific i18n test files
 */
export async function createPackageI18nTestFiles(): Promise<void> {
  const { getEnabledPackages } = await import("../config/i18n-testing-config");
  const enabledPackages = await getEnabledPackages();

  for (const pkg of enabledPackages) {
    const testFilePath = join(pkg.path, "src/__tests__/i18n.test.ts");
    const testDir = join(pkg.path, "src/__tests__");

    // Create test directory if it doesn't exist
    if (!existsSync(testDir)) {
      console.log(`ðŸ“ Creating test directory: ${testDir}`);
      // Note: In a real implementation, you'd use fs.mkdirSync with recursive: true
    }

    // Create test file if it doesn't exist
    if (!existsSync(testFilePath)) {
      generatePackageTestFile(pkg);
      console.log(`ðŸ“ Creating i18n test file: ${testFilePath}`);
      // Note: In a real implementation, you'd use fs.writeFileSync
    }
  }
}

/**
 * Generate test file content for a package
 */
export function generatePackageTestFile(pkg: PackageI18nConfig): string {
  return `/**
 * i18n Tests for ${pkg.name} Package
 * Auto-generated by Reynard i18n testing orchestrator
 */

import { describe, it, expect } from 'vitest';
import { runPackageI18nTests } from 'reynard-testing/utils/i18n-package-orchestrator';
import { getPackageI18nConfig } from 'reynard-testing/config/i18n-testing-config';

describe('${pkg.name} i18n Tests', () => {
  it('should pass all i18n validation checks', async () => {
    const config = await getPackageI18nConfig('${pkg.name}');
    expect(config).toBeDefined();
    
    if (config?.enabled) {
      const result = await runPackageI18nTests(config);
      
      expect(result.success).toBe(true);
      expect(result.errors).toHaveLength(0);
      
      if (config.failOnHardcodedStrings) {
        expect(result.results.hardcodedStrings).toHaveLength(0);
      }
      
      if (config.validateCompleteness) {
        const missingTranslations = result.results.translationValidation.reduce(
          (sum, validation) => sum + validation.missingKeys.length, 0
        );
        expect(missingTranslations).toBe(0);
      }
    }
  });
  
  it('should have proper translation namespaces', () => {
    const config = await getPackageI18nConfig('${pkg.name}');
    expect(config).toBeDefined();
    
    if (config?.enabled) {
      expect(config.namespaces).toContain('common');
      expect(config.namespaces.length).toBeGreaterThan(0);
    }
  });
  
  it('should have appropriate ignore patterns', () => {
    const config = await getPackageI18nConfig('${pkg.name}');
    expect(config).toBeDefined();
    
    if (config?.enabled) {
      expect(config.ignorePatterns).toBeDefined();
      expect(config.ignorePatterns.length).toBeGreaterThan(0);
    }
  });
});
`;
}
