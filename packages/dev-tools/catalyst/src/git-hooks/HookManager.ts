/**
 * ü¶ä FOXY Git Hook Manager
 * 
 * Flexible Orchestration for Xenial Yield - Git Hooks System
 * Native git hook management system to replace husky.
 * Provides comprehensive git hook lifecycle management with validation.
 */

import { execSync, spawn } from "child_process";
import { existsSync, readFileSync, writeFileSync, chmodSync, mkdirSync } from "fs";
import { join, resolve } from "path";
import { ReynardLogger } from "../logger/ReynardLogger.js";
import type { HookConfig, HookResult, GitHookType } from "../types/GitHooks.js";

export class HookManager {
  private logger: ReynardLogger;
  private projectRoot: string;
  private hooksDir: string;

  constructor(projectRoot: string = process.cwd(), logger?: ReynardLogger) {
    this.projectRoot = resolve(projectRoot);
    this.hooksDir = join(this.projectRoot, ".git", "hooks");
    this.logger = logger || new ReynardLogger();
  }

  /**
   * Install all configured git hooks
   */
  async installHooks(config: HookConfig): Promise<void> {
    this.logger.info("ü¶ä Installing Reynard git hooks...");

    try {
      // Ensure hooks directory exists
      if (!existsSync(this.hooksDir)) {
        mkdirSync(this.hooksDir, { recursive: true });
      }

      // Install each hook type
      for (const [hookType, hookConfig] of Object.entries(config.hooks)) {
        if (hookConfig.enabled) {
          await this.installHook(hookType as GitHookType, hookConfig);
        }
      }

      this.logger.success("‚úÖ All git hooks installed successfully");
    } catch (error) {
      this.logger.error(`‚ùå Failed to install git hooks: ${error}`);
      throw error;
    }
  }

  /**
   * Install a specific git hook
   */
  private async installHook(hookType: GitHookType, config: any): Promise<void> {
    const hookPath = join(this.hooksDir, hookType);
    const hookScript = this.generateHookScript(hookType, config);

    writeFileSync(hookPath, hookScript);
    chmodSync(hookPath, 0o755);

    this.logger.info(`‚úÖ Installed ${hookType} hook`);
  }

  /**
   * Generate hook script content
   */
  private generateHookScript(hookType: GitHookType, config: any): string {
    const scriptName = `reynard-${hookType}`;
    
    return `#!/bin/sh
# ü¶ä Reynard ${hookType} hook
# Generated by Reynard Hook Manager

set -e

# Run Reynard hook command
npx --no -- ${scriptName} "$@"
`;
  }

  /**
   * Run pre-commit hook
   */
  async runPreCommit(): Promise<HookResult> {
    this.logger.info("ü¶ä Running pre-commit validation...");
    
    try {
      // Run linting
      const lintResult = await this.runLinting();
      if (!lintResult.success) {
        return {
          success: false,
          message: "Pre-commit validation failed: Linting errors found",
          details: lintResult.details
        };
      }

      // Run type checking
      const typeResult = await this.runTypeCheck();
      if (!typeResult.success) {
        return {
          success: false,
          message: "Pre-commit validation failed: Type errors found",
          details: typeResult.details
        };
      }

      // Run tests for staged files
      const testResult = await this.runTests();
      if (!testResult.success) {
        return {
          success: false,
          message: "Pre-commit validation failed: Tests failed",
          details: testResult.details
        };
      }

      this.logger.success("‚úÖ Pre-commit validation passed");
      return {
        success: true,
        message: "Pre-commit validation passed"
      };
    } catch (error) {
      this.logger.error(`‚ùå Pre-commit validation failed: ${error}`);
      return {
        success: false,
        message: `Pre-commit validation failed: ${error}`,
        details: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * Run commit message validation
   */
  async runCommitMsg(message: string): Promise<HookResult> {
    this.logger.info("ü¶ä Validating commit message...");

    try {
      // Basic validation
      if (!message || message.trim().length === 0) {
        return {
          success: false,
          message: "Commit message cannot be empty"
        };
      }

      // Check conventional commit format
      const conventionalCommitRegex = /^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\(.+\))?: .+/;
      if (!conventionalCommitRegex.test(message)) {
        return {
          success: false,
          message: "Commit message must follow conventional commit format: type(scope): description"
        };
      }

      // Check length
      if (message.length > 100) {
        return {
          success: false,
          message: "Commit message must be 100 characters or less"
        };
      }

      this.logger.success("‚úÖ Commit message validation passed");
      return {
        success: true,
        message: "Commit message validation passed"
      };
    } catch (error) {
      this.logger.error(`‚ùå Commit message validation failed: ${error}`);
      return {
        success: false,
        message: `Commit message validation failed: ${error}`,
        details: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * Run pre-push hook
   */
  async runPrePush(): Promise<HookResult> {
    this.logger.info("ü¶ä Running pre-push validation...");

    try {
      // Run full test suite
      const testResult = await this.runFullTestSuite();
      if (!testResult.success) {
        return {
          success: false,
          message: "Pre-push validation failed: Full test suite failed",
          details: testResult.details
        };
      }

      // Run security scan
      const securityResult = await this.runSecurityScan();
      if (!securityResult.success) {
        return {
          success: false,
          message: "Pre-push validation failed: Security issues found",
          details: securityResult.details
        };
      }

      this.logger.success("‚úÖ Pre-push validation passed");
      return {
        success: true,
        message: "Pre-push validation passed"
      };
    } catch (error) {
      this.logger.error(`‚ùå Pre-push validation failed: ${error}`);
      return {
        success: false,
        message: `Pre-push validation failed: ${error}`,
        details: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * Run linting on staged files
   */
  private async runLinting(): Promise<HookResult> {
    try {
      const stagedFiles = this.getStagedFiles();
      if (stagedFiles.length === 0) {
        return { success: true, message: "No staged files to lint" };
      }

      // Run ESLint
      const eslintResult = execSync(`pnpm exec eslint ${stagedFiles.join(" ")}`, { 
        encoding: "utf8",
        cwd: this.projectRoot 
      });

      return { success: true, message: "Linting passed" };
    } catch (error: any) {
      return {
        success: false,
        message: "Linting failed",
        details: error.stdout || error.message
      };
    }
  }

  /**
   * Run type checking
   */
  private async runTypeCheck(): Promise<HookResult> {
    try {
      execSync("pnpm exec tsc --noEmit", { 
        encoding: "utf8",
        cwd: this.projectRoot 
      });

      return { success: true, message: "Type checking passed" };
    } catch (error: any) {
      return {
        success: false,
        message: "Type checking failed",
        details: error.stdout || error.message
      };
    }
  }

  /**
   * Run tests for staged files
   */
  private async runTests(): Promise<HookResult> {
    try {
      const stagedFiles = this.getStagedFiles();
      const testFiles = stagedFiles.filter(file => 
        file.includes(".test.") || file.includes(".spec.") || file.includes("__tests__")
      );

      if (testFiles.length === 0) {
        return { success: true, message: "No test files to run" };
      }

      execSync(`pnpm exec vitest run ${testFiles.join(" ")}`, { 
        encoding: "utf8",
        cwd: this.projectRoot 
      });

      return { success: true, message: "Tests passed" };
    } catch (error: any) {
      return {
        success: false,
        message: "Tests failed",
        details: error.stdout || error.message
      };
    }
  }

  /**
   * Run full test suite
   */
  private async runFullTestSuite(): Promise<HookResult> {
    try {
      execSync("pnpm exec vitest run", { 
        encoding: "utf8",
        cwd: this.projectRoot 
      });

      return { success: true, message: "Full test suite passed" };
    } catch (error: any) {
      return {
        success: false,
        message: "Full test suite failed",
        details: error.stdout || error.message
      };
    }
  }

  /**
   * Run security scan
   */
  private async runSecurityScan(): Promise<HookResult> {
    try {
      // Run audit-ci for security vulnerabilities
      execSync("pnpm exec audit-ci --config audit-ci.json", { 
        encoding: "utf8",
        cwd: this.projectRoot 
      });

      return { success: true, message: "Security scan passed" };
    } catch (error: any) {
      return {
        success: false,
        message: "Security scan failed",
        details: error.stdout || error.message
      };
    }
  }

  /**
   * Get staged files
   */
  private getStagedFiles(): string[] {
    try {
      const output = execSync("git diff --cached --name-only", { 
        encoding: "utf8",
        cwd: this.projectRoot 
      });
      
      return output.trim().split("\n").filter(file => file.length > 0);
    } catch (error) {
      this.logger.warn("Failed to get staged files");
      return [];
    }
  }

  /**
   * Uninstall all Reynard hooks
   */
  async uninstallHooks(): Promise<void> {
    this.logger.info("ü¶ä Uninstalling Reynard git hooks...");

    const hookTypes: GitHookType[] = ["pre-commit", "commit-msg", "pre-push"];
    
    for (const hookType of hookTypes) {
      const hookPath = join(this.hooksDir, hookType);
      if (existsSync(hookPath)) {
        const content = readFileSync(hookPath, "utf8");
        if (content.includes("ü¶ä Reynard")) {
          // Remove the hook file
          execSync(`rm "${hookPath}"`, { cwd: this.projectRoot });
          this.logger.info(`‚úÖ Removed ${hookType} hook`);
        }
      }
    }

    this.logger.success("‚úÖ All Reynard git hooks uninstalled");
  }
}
