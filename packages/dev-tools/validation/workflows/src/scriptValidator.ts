/**
 * ðŸº Script Validator Module
 * Handles validation of extracted shell scripts using shellcheck
 */

import fs from "fs";
import path from "path";
import { execSync } from "child_process";
import type { WorkflowScript, ValidationResult } from "./types.js";
import type { ReynardLogger } from "reynard-dev-tools-catalyst";

export class ScriptValidator {
  constructor(
    private logger: ReynardLogger,
    private tempDir: string,
    private shellcheckRc: string
  ) {}

  /**
   * Validate extracted shell script with shellcheck
   */
  validateScript(script: WorkflowScript): ValidationResult {
    this.logger.log(`ðŸ” Validating script: ${script.name}`, "blue");

    const tempScriptPath = this.createTempScript(script);
    const scriptContent = this.generateScriptContent(script);

    this.writeTempScript(tempScriptPath, scriptContent);

    try {
      this.runShellcheck(tempScriptPath);
      this.logger.log(`    âœ… Valid`, "green");
      return this.createValidResult(tempScriptPath, script);
    } catch (error) {
      const issues = this.extractIssues(error);
      this.logger.log(`    âŒ Issues found`, "red");
      this.logIssues(issues);
      return this.createInvalidResult(tempScriptPath, script, issues);
    }
  }

  private createTempScript(script: WorkflowScript): string {
    return path.join(this.tempDir, `${path.basename(script.workflow)}_${script.name}.sh`);
  }

  private generateScriptContent(script: WorkflowScript): string {
    return `#!/bin/bash
# Extracted from ${script.workflow}:${script.startLine}
# Generated by WorkflowShellExtractor

${script.content}`;
  }

  private writeTempScript(tempScriptPath: string, content: string): void {
    // Ensure temp directory exists
    if (!fs.existsSync(this.tempDir)) {
      fs.mkdirSync(this.tempDir, { recursive: true });
    }

    fs.writeFileSync(tempScriptPath, content);
  }

  private runShellcheck(tempScriptPath: string): void {
    execSync(`shellcheck --rcfile=${this.shellcheckRc} "${tempScriptPath}"`, {
      encoding: "utf8",
      stdio: "pipe",
    });
  }

  private extractIssues(error: unknown): string {
    const err = error as any;
    return err.stdout || err.stderr || "";
  }

  private logIssues(issues: string): void {
    if (this.logger) {
      console.log(issues);
    }
  }

  private createValidResult(tempScriptPath: string, script: WorkflowScript): ValidationResult {
    return {
      valid: true,
      issues: [],
      script: tempScriptPath,
      metadata: {
        timestamp: new Date(),
        lineCount: script.content.split("\n").length,
      },
    };
  }

  private createInvalidResult(tempScriptPath: string, script: WorkflowScript, issues: string): ValidationResult {
    return {
      valid: false,
      issues: issues.split("\n").filter((line: string) => line.trim().length > 0),
      script: tempScriptPath,
      metadata: {
        timestamp: new Date(),
        lineCount: script.content.split("\n").length,
      },
    };
  }
}
