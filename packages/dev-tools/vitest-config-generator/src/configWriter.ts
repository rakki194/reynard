/**
 * ðŸ¦Š Configuration Writer
 * Handles writing generated configurations to files
 */

import fs from "fs";
import path from "path";
import type { VitestGlobalConfig, GeneratorResult } from "./types.js";
import type { Logger } from "./logger.js";

export class ConfigWriter {
  private logger: Logger;

  constructor(logger: Logger) {
    this.logger = logger;
  }

  /**
   * Write the generated configuration to a file
   */
  writeConfig(result: GeneratorResult, outputPath: string = "vitest.generated.config.ts"): boolean {
    try {
      if (!result.success) {
        this.logger.error("Cannot write configuration: generation failed");
        return false;
      }

      const configContent = this.generateConfigFile(result.config);
      const fullPath = path.resolve(outputPath);

      // Ensure directory exists
      const dir = path.dirname(fullPath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }

      // Write the file
      fs.writeFileSync(fullPath, configContent, "utf8");

      this.logger.info(`Configuration written to: ${fullPath}`);
      return true;
    } catch (error) {
      this.logger.error(`Failed to write configuration: ${(error as Error).message}`);
      return false;
    }
  }

  /**
   * Generate the TypeScript configuration file content
   */
  private generateConfigFile(config: VitestGlobalConfig): string {
    const timestamp = new Date().toISOString();

    return `/**
 * ðŸ¦Š Generated Vitest Configuration
 * Auto-generated from project architecture on ${timestamp}
 * 
 * This file is generated by the vitest-config-generator tool.
 * Do not edit manually - regenerate using: pnpm generate-vitest-config
 */

import { defineConfig } from "vitest/config";

export default defineConfig(${JSON.stringify(config, null, 2)});
`;
  }

  /**
   * Write a backup of the current configuration
   */
  backupCurrentConfig(configPath: string): boolean {
    try {
      if (!fs.existsSync(configPath)) {
        this.logger.debug(`No existing config to backup: ${configPath}`);
        return true;
      }

      const backupPath = `${configPath}.backup.${Date.now()}`;
      fs.copyFileSync(configPath, backupPath);

      this.logger.info(`Backed up current config to: ${backupPath}`);
      return true;
    } catch (error) {
      this.logger.error(`Failed to backup config: ${(error as Error).message}`);
      return false;
    }
  }

  /**
   * Validate that the generated configuration is valid
   */
  validateConfig(config: VitestGlobalConfig): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Check required fields
    if (!config.test) {
      errors.push("Missing required 'test' configuration");
      return { valid: false, errors };
    }

    if (!config.test.projects || !Array.isArray(config.test.projects)) {
      errors.push("Missing or invalid 'test.projects' array");
    }

    // Check project configurations
    if (config.test.projects) {
      config.test.projects.forEach((project, index) => {
        if (!project.name) {
          errors.push(`Project ${index}: missing name`);
        }
        if (!project.root) {
          errors.push(`Project ${index}: missing root path`);
        }
        if (!project.test) {
          errors.push(`Project ${index}: missing test configuration`);
        } else if (!project.test.include || project.test.include.length === 0) {
          errors.push(`Project ${index}: missing test include patterns`);
        }
      });
    }

    return {
      valid: errors.length === 0,
      errors,
    };
  }
}
