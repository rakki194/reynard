---
globs: *.tsx,*.ts,*.js
alwaysApply: false
---

# The Modular Manifesto

*A comprehensive guide to writing modular TypeScript and JavaScript based on proven patterns from the Reynard framework*

## Core Principles

### The 100-Line Axiom

Every source file should be under 100 lines (excluding blank lines and comments). This constraint forces:

- **Clear Separation of Concerns**: Each file has a single, well-defined responsibility
- **Improved Readability**: Files are small enough to understand at a glance
- **Better Testability**: Smaller modules are easier to test comprehensively
- **Enhanced Maintainability**: Changes are localized and predictable

### The Three Pillars of Modularity

1. **Small** - Each line of code costs energy to maintain
2. **Modular** - Organized into groups of swappable modules
3. **Self-contained** - Easily reusable via cross-project integration

## Modular Architecture Patterns

### 1. Package Export Strategy

Use structured exports with clear boundaries:

```typescript
// packages/core/package.json
{
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    },
    "./modules": {
      "types": "./dist/modules/index.d.ts",
      "import": "./dist/modules/index.js"
    },
    "./composables": {
      "types": "./dist/composables/index.d.ts",
      "import": "./dist/composables/index.js"
    }
  }
}
```

### 2. Barrel Export Pattern

Create clean API boundaries with barrel exports:

```typescript
// packages/core/src/index.ts
export * from "./modules";
export * from "./composables";

// packages/core/src/modules/index.ts
export * from "./notifications";
export type { Notification, NotificationsModule } from "./notifications";
```

### 3. Interface-First Design

Define clear contracts before implementation:

```typescript
// packages/core/src/modules/notifications.ts
export interface Notification {
  id: string;
  message: string;
  type: "error" | "success" | "info" | "warning";
  group?: string;
  icon?: "spinner" | "success" | "error" | "info" | "warning";
  progress?: number;
  timestamp: number;
  duration?: number;
}

export interface NotificationsModule {
  readonly notifications: Notification[];
  notify: (message: string, type?: Notification["type"], options?: NotificationOptions) => string;
  removeNotification: (id: string) => void;
  clearNotifications: (group?: string) => void;
}
```

### 4. Factory Pattern for Module Creation

Use factory functions for clean module instantiation:

```typescript
export const createNotificationsModule = (): NotificationsModule => {
  const [notifications, setNotifications] = createSignal<Notification[]>([]);
  
  const notify = (message: string, type: Notification["type"] = "info", options = {}) => {
    // Implementation
  };
  
  return {
    get notifications() { return notifications(); },
    notify,
    removeNotification,
    clearNotifications
  };
};
```

## Refactoring Strategies

### Strategy 1: Extract by Functionality

**Before** (Monolithic):

```typescript
class FileProcessor {
  processImage() { /* 200+ lines */ }
  processVideo() { /* 200+ lines */ }
  processAudio() { /* 200+ lines */ }
  processDocument() { /* 200+ lines */ }
}
```

**After** (Modular):

```typescript
// image-processor.ts (80 lines)
export class ImageProcessor {
  processImage() { /* focused implementation */ }
}

// video-processor.ts (80 lines)
export class VideoProcessor {
  processVideo() { /* focused implementation */ }
}

// file-processor.ts (50 lines) - Orchestrator
export { ImageProcessor } from './image-processor';
export { VideoProcessor } from './video-processor';
export { AudioProcessor } from './audio-processor';
export { DocumentProcessor } from './document-processor';
```

### Strategy 2: Extract by Layer

**Before** (Mixed Concerns):

```typescript
class UserService {
  validateUser() { /* validation logic */ }
  hashPassword() { /* security logic */ }
  saveUser() { /* persistence logic */ }
  sendEmail() { /* notification logic */ }
}
```

**After** (Separated Concerns):

```typescript
// user-validator.ts (60 lines)
export class UserValidator {
  validateUser() { /* validation logic */ }
}

// password-utils.ts (40 lines)
export class PasswordUtils {
  hashPassword() { /* security logic */ }
}

// user-repository.ts (50 lines)
export class UserRepository {
  saveUser() { /* persistence logic */ }
}

// user-service.ts (40 lines) - Orchestrator
export class UserService {
  constructor(
    private validator: UserValidator,
    private passwordUtils: PasswordUtils,
    private repository: UserRepository
  ) {}
}
```

### Strategy 3: Category-Specific Modules

**Before** (Single Large Config):

```typescript
// file-types.ts (500+ lines)
export const IMAGE_TYPES = { /* 100+ lines */ };
export const VIDEO_TYPES = { /* 100+ lines */ };
export const AUDIO_TYPES = { /* 100+ lines */ };
export const DOCUMENT_TYPES = { /* 100+ lines */ };
export const TEXT_TYPES = { /* 100+ lines */ };
```

**After** (Category Modules):

```typescript
// image-types.ts (80 lines)
export const IMAGE_TYPES = { /* focused image types */ };

// video-types.ts (80 lines)
export const VIDEO_TYPES = { /* focused video types */ };

// file-types.ts (30 lines) - Aggregator
export { IMAGE_TYPES } from './image-types';
export { VIDEO_TYPES } from './video-types';
export { AUDIO_TYPES } from './audio-types';
export { DOCUMENT_TYPES } from './document-types';
export { TEXT_TYPES } from './text-types';
```

## TypeScript-Specific Patterns

### 1. Strict Type Definitions

```typescript
// Use strict typing for better modularity
export interface ConnectionConfig {
  readonly host: string;
  readonly port: number;
  readonly timeout: number;
  readonly retries: number;
}

// Avoid any types - use specific interfaces
export interface ConnectionState {
  status: 'connecting' | 'connected' | 'disconnected' | 'error';
  lastError?: Error;
  connectedAt?: Date;
}
```

### 2. Generic Module Patterns

```typescript
// Generic connection interface
export interface Connection<T = unknown> {
  connect(): Promise<T>;
  disconnect(): Promise<void>;
  isConnected(): boolean;
  getState(): ConnectionState;
}

// Specific implementations
export class HTTPConnection implements Connection<Response> {
  // Implementation
}

export class WebSocketConnection implements Connection<WebSocket> {
  // Implementation
}
```

### 3. Composable Patterns

```typescript
// packages/core/src/composables/useLocalStorage.ts
export interface UseLocalStorageOptions<T> {
  defaultValue: T;
  serializer?: {
    read: (value: string) => T;
    write: (value: T) => string;
  };
  syncAcrossTabs?: boolean;
}

export function useLocalStorage<T>(
  key: string,
  options: UseLocalStorageOptions<T>
): [Accessor<T>, Setter<T>] {
  // Implementation
}
```

## JavaScript-Specific Patterns

### 1. Module Pattern with Closures

```javascript
// connection-manager.js (80 lines)
export const createConnectionManager = () => {
  const connections = new Map();
  
  const addConnection = (id, connection) => {
    connections.set(id, connection);
  };
  
  const removeConnection = (id) => {
    connections.delete(id);
  };
  
  const getConnection = (id) => {
    return connections.get(id);
  };
  
  return {
    addConnection,
    removeConnection,
    getConnection,
    getConnectionCount: () => connections.size
  };
};
```

### 2. Event-Driven Modules

```javascript
// event-bus.js (60 lines)
export const createEventBus = () => {
  const listeners = new Map();
  
  const on = (event, callback) => {
    if (!listeners.has(event)) {
      listeners.set(event, []);
    }
    listeners.get(event).push(callback);
  };
  
  const emit = (event, data) => {
    const eventListeners = listeners.get(event) || [];
    eventListeners.forEach(callback => callback(data));
  };
  
  const off = (event, callback) => {
    const eventListeners = listeners.get(event) || [];
    const index = eventListeners.indexOf(callback);
    if (index > -1) {
      eventListeners.splice(index, 1);
    }
  };
  
  return { on, emit, off };
};
```

## Testing Modular Code

### 1. Unit Testing Small Modules

```typescript
// notifications.test.ts
import { createNotificationsModule } from './notifications';

describe('NotificationsModule', () => {
  let notifications: NotificationsModule;
  
  beforeEach(() => {
    notifications = createNotificationsModule();
  });
  
  it('should add notification', () => {
    const id = notifications.notify('Test message', 'info');
    expect(notifications.notifications).toHaveLength(1);
    expect(notifications.notifications[0].id).toBe(id);
  });
  
  it('should remove notification', () => {
    const id = notifications.notify('Test message');
    notifications.removeNotification(id);
    expect(notifications.notifications).toHaveLength(0);
  });
});
```

### 2. Integration Testing

```typescript
// connection-manager.test.ts
import { createConnectionManager } from './connection-manager';
import { createHTTPConnection } from './http-connection';

describe('ConnectionManager Integration', () => {
  it('should manage multiple connections', () => {
    const manager = createConnectionManager();
    const conn1 = createHTTPConnection({ host: 'api1.example.com' });
    const conn2 = createHTTPConnection({ host: 'api2.example.com' });
    
    manager.addConnection('api1', conn1);
    manager.addConnection('api2', conn2);
    
    expect(manager.getConnectionCount()).toBe(2);
    expect(manager.getConnection('api1')).toBe(conn1);
  });
});
```

## Performance Considerations

### 1. Lazy Loading

```typescript
// Lazy load heavy modules
export const loadImageProcessor = async () => {
  const { ImageProcessor } = await import('./image-processor');
  return new ImageProcessor();
};

// Use dynamic imports for code splitting
export const processImage = async (imageData: ImageData) => {
  const processor = await loadImageProcessor();
  return processor.process(imageData);
};
```

### 2. Memory Management

```typescript
// Clean up resources in modules
export class ConnectionPool {
  private connections = new Set<Connection>();
  
  addConnection(connection: Connection) {
    this.connections.add(connection);
  }
  
  removeConnection(connection: Connection) {
    this.connections.delete(connection);
    connection.disconnect(); // Clean up
  }
  
  dispose() {
    this.connections.forEach(conn => conn.disconnect());
    this.connections.clear();
  }
}
```

## Best Practices

### 1. File Organization

```
packages/
├── core/
│   ├── src/
│   │   ├── modules/
│   │   │   ├── notifications.ts (80 lines)
│   │   │   ├── storage.ts (70 lines)
│   │   │   └── index.ts (20 lines)
│   │   ├── composables/
│   │   │   ├── useLocalStorage.ts (60 lines)
│   │   │   ├── useDebounce.ts (40 lines)
│   │   │   └── index.ts (15 lines)
│   │   └── index.ts (10 lines)
│   └── package.json
```

### 2. Naming Conventions

- **Modules**: `kebab-case.ts` (e.g., `connection-manager.ts`)
- **Classes**: `PascalCase` (e.g., `ConnectionManager`)
- **Functions**: `camelCase` (e.g., `createConnection`)
- **Interfaces**: `PascalCase` with descriptive names (e.g., `ConnectionConfig`)

### 3. Documentation

```typescript
/**
 * Creates a new connection manager for handling multiple connections
 * 
 * @example
 * ```typescript
 * const manager = createConnectionManager();
 * manager.addConnection('api', httpConnection);
 * ```
 * 
 * @returns A connection manager instance
 */
export const createConnectionManager = (): ConnectionManager => {
  // Implementation
};
```

## Migration Strategy

### Phase 1: Identify Monoliths

1. Scan for files > 100 lines
2. Identify mixed concerns
3. Map dependencies

### Phase 2: Extract Core Modules

1. Start with utility functions
2. Extract pure functions first
3. Create clear interfaces

### Phase 3: Refactor Components

1. Break down large components
2. Extract custom hooks/composables
3. Separate business logic from UI

### Phase 4: Optimize Integration

1. Implement barrel exports
2. Add proper TypeScript types
3. Create comprehensive tests

## Conclusion

Modular architecture is not just about file size—it's about creating a sustainable, maintainable codebase that can grow and adapt. The 100-line axiom forces us to think about separation of concerns, clear interfaces, and reusable components.

By following these patterns, your TypeScript and JavaScript code becomes:

- **Maintainable**: Easy to understand and modify
- **Testable**: Small, focused units that can be thoroughly tested
- **Reusable**: Self-contained modules that can be shared across projects
- **Scalable**: Architecture that grows with your application

Remember: *Every line of code is a liability. Make each line count by keeping it focused, clear, and purposeful.*
