---
globs: *.tex
alwaysApply: false
---

# LaTeX Writing Rules for Reynard Research Papers

Academic papers should be crafted with precision and clarity - every equation,
every algorithm, every citation strategically placed for maximum impact and
understanding. These guidelines capture the sophisticated patterns that make
your work exceptional.

## Core Principles

### Academic Writing Philosophy

Every research paper in the Reynard project should embody technical
excellence, following the patterns established in your comprehensive refactor
analysis, NEXUS collision detection system, and VECTOR engagement tracking
papers.

The foundation rests on mathematical rigor with precise notation, clear
proofs, and well-defined algorithms that include comprehensive complexity
analysis. Systematic analysis requires structured methodology with reproducible
results and empirical validation, ensuring that every claim can be verified
and replicated.

Practical impact demands real-world applications with measurable performance
improvements that demonstrate tangible value beyond theoretical contributions.
Clear communication makes research accessible to both specialists and
practitioners through strategic use of quotes and examples that illuminate
complex concepts.

Innovation focus drives novel approaches to established problems with
comprehensive benchmarking that establishes new standards in the field.

### Document Structure Standards

Based on analysis of your research papers, follow this proven structure that
mirrors your successful NEXUS and VECTOR papers.

```latex
\documentclass[10pt]{article}

% Essential packages (from your papers)
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{float}
\usepackage{microtype}
\usepackage{caption}
\usepackage{geometry}

% Page setup
\geometry{margin=1.25in, includeheadfoot}

% Float optimization
\renewcommand{\topfraction}{.9}
\renewcommand{\bottomfraction}{.9}
\renewcommand{\textfraction}{.1}
\renewcommand{\floatpagefraction}{.8}

% Code formatting
\lstset{
    basicstyle=\small\ttfamily,
    breaklines=true,
    breakatwhitespace=true,
    showstringspaces=false,
    columns=flexible
}

\begin{document}
\title{[SYSTEM_NAME]: [Descriptive Subtitle] \\
\Large{[Problem Context] - [Solution Approach]} \\
\large{[Key Innovation or Contribution]}}

\author{Technical Documentation Team\\
Reynard Project\\
\includegraphics[width=0.5cm]{favicon.pdf}}
\maketitle

\begin{abstract}
We present [SYSTEM_NAME], a [BRIEF_DESCRIPTION] that [PROBLEM_SOLVED]. 
[SYSTEM_NAME] applies [METHODOLOGY] to provide [KEY_BENEFITS]. 
Our system achieves [SPECIFIC_METRICS] through [KEY_TECHNIQUES], 
making it particularly suitable for [TARGET_APPLICATION] requiring [SPECIFIC_REQUIREMENTS].
\end{abstract}

\section{Introduction}
[Problem context, existing solutions, and your contribution with strategic quotes]

\section{System Architecture}
[High-level design and component overview with mathematical foundations]

\section{Algorithmic Implementation}
[Mathematical foundations, algorithms, and complexity analysis]

\section{Performance Analysis}
[Benchmarks, measurements, and comparisons with empirical validation]

\section{Conclusion}
[Summary of contributions and future work with impact assessment]
\end{document}
```

## Mathematical Writing Standards

### Equation Formatting

```latex
% Good: Clear, well-spaced equations with proper numbering
\begin{equation}
\begin{split}
    \text{overlap}(A, B) = & (A.x_1 \leq B.x_2) \land \\
    & (B.x_1 \leq A.x_2) \land \\
    & (A.y_1 \leq B.y_2) \land \\
    & (B.y_1 \leq A.y_2)
\end{split}
\end{equation}

% Good: Inline math for simple expressions
The time complexity is $O(\alpha(n))$ where $\alpha(n)$ is the inverse Ackermann
function.

% Good: Display math for important results
\[
\text{Performance Improvement} = \frac{T_{\text{original}} - T_{\text{optimized}}}{T_{\text{original}}} \times 100\%
\]
```

### Algorithm Presentation

```latex
\begin{algorithm}
\caption{Union-Find with Path Compression and Union by Rank}
\begin{algorithmic}[1]
\Function{Find}{x}
    \If{parent[x] $\neq$ x}
        \State parent[x] $\gets$ Find(parent[x]) \Comment{Path Compression}
    \EndIf
    \Return parent[x]
\EndFunction
\Statex
\Function{Union}{x, y}
    \State rootX $\gets$ Find(x)
    \State rootY $\gets$ Find(y)
    \If{rootX $\neq$ rootY}
        \If{rank[rootX] $<$ rank[rootY]}
            \State parent[rootX] $\gets$ rootY
        \ElsIf{rank[rootX] $>$ rank[rootY]}
            \State parent[rootY] $\gets$ rootX
        \Else
            \State parent[rootY] $\gets$ rootX
            \State rank[rootX] $\gets$ rank[rootX] + 1
        \EndIf
    \EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}
```

## Code Integration Standards

### Listings Configuration

```latex
% TypeScript/JavaScript code
\lstdefinestyle{typescript}{
  backgroundcolor=\color{backcolour},
  basicstyle=\footnotesize\ttfamily,
  breaklines=true,
  numbers=left,
  numberstyle=\tiny\color{codegray},
  numbersep=5pt,
  tabsize=2,
  frame=single,
  framerule=0.4pt,
  rulecolor=\color{codegray},
  commentstyle=\color{codegreen},
  keywordstyle=\color{codepurple},
  stringstyle=\color{codegreen},
  morekeywords={export, import, interface, type, const, let, var, function, return, if, else, for, while, switch, case, default, class, extends, implements, public, private, protected, static, async, await, createSignal, createEffect, createMemo, Show, For, Index, Match, Switch, onMount, onCleanup},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
}

% Python code
\lstdefinestyle{python}{
  backgroundcolor=\color{backcolour},
  basicstyle=\footnotesize\ttfamily,
  breaklines=true,
  numbers=left,
  numberstyle=\tiny\color{codegray},
  numbersep=5pt,
  tabsize=2,
  frame=single,
  framerule=0.4pt,
  rulecolor=\color{codegray},
  commentstyle=\color{codegreen},
  keywordstyle=\color{codepurple},
  stringstyle=\color{codegreen},
  morekeywords={def, class, import, from, as, if, elif, else, for, while, try, except, finally, with, return, yield, lambda, and, or, not, in, is, None, True, False},
  morecomment=[l]{\#},
  morecomment=[s]{"""}{"""},
}

% Color definitions
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
```

### Code Examples

```latex
% Good: Contextual code with explanation
\begin{lstlisting}[caption={Progressive Processor Configuration}, style=typescript]
interface ProgressiveLoadingOptions {
  batchSize?: number;        // Items per batch (default: 1000)
  maxBatchTime?: number;     // Max time per batch (default: 16ms)
  yieldInterval?: number;    // Yield frequency (default: 100ms)
  onProgress?: (progress: number) => void;
  onComplete?: (result: T[]) => void;
  onError?: (error: Error) => void;
}
\end{lstlisting}

% Good: Algorithm implementation
\begin{lstlisting}[caption={CSS Performance Optimization}, style=typescript]
function applyStylesStaggered(elements: HTMLElement[], styles: CSSStyleDeclaration) {
  const batchSize = 50;
  let index = 0;
  
  function processBatch() {
    const endIndex = Math.min(index + batchSize, elements.length);
    
    for (let i = index; i < endIndex; i++) {
      Object.assign(elements[i].style, styles);
    }
    
    index = endIndex;
    
    if (index < elements.length) {
      requestAnimationFrame(processBatch);
    }
  }
  
  requestAnimationFrame(processBatch);
}
\end{lstlisting}
```

## Performance Analysis Standards

### Benchmark Presentation

```latex
% Good: Clear performance comparison table
\begin{table}[h]
\centering
\caption{Performance Comparison: Original vs Optimized}
\begin{tabular}{@{}lrrr@{}}
\toprule
\textbf{Metric} & \textbf{Original} & \textbf{Optimized} & \textbf{Improvement} \\
\midrule
Selection Time (216 items) & 1527ms & 100ms & 93.4\% \\
Memory Usage & 45MB & 12MB & 73.3\% \\
CPU Usage (peak) & 85\% & 15\% & 82.4\% \\
Frame Rate (during selection) & 12fps & 60fps & 400\% \\
\bottomrule
\end{tabular}
\label{tab:performance}
\end{table}

% Good: Performance improvement calculation
The overall performance improvement is calculated as:
\[
\text{Improvement} = \frac{T_{\text{original}} - T_{\text{optimized}}}{T_{\text{original}}} \times 100\% = \frac{1527 - 100}{1527} \times 100\% = 93.4\%
\]
```

### System Architecture Diagrams

```latex
% Use TikZ for system architecture
\begin{figure}[h]
\centering
\begin{tikzpicture}[
  node distance=2cm,
  component/.style={rectangle, draw, fill=blue!20, text width=3cm, text centered, minimum height=1cm},
  arrow/.style={->, thick}
]

\node[component] (input) {Input Processing};
\node[component, below of=input] (collision) {Collision Detection};
\node[component, below of=collision] (union) {Union-Find Algorithm};
\node[component, below of=union] (group) {Group Processing};
\node[component, below of=group] (cycling) {Box Cycling};

\draw[arrow] (input) -- (collision);
\draw[arrow] (collision) -- (union);
\draw[arrow] (union) -- (group);
\draw[arrow] (group) -- (cycling);

\end{tikzpicture}
\caption{NEXUS System Architecture}
\label{fig:architecture}
\end{figure}
```

## Writing Style Guidelines

### Abstract Writing

```latex
\begin{abstract}
We present [SYSTEM_NAME], a [BRIEF_DESCRIPTION] that [PROBLEM_SOLVED]. 
[SYSTEM_NAME] applies [METHODOLOGY] to provide [KEY_BENEFITS]. 
Our system achieves [SPECIFIC_METRICS] through [KEY_TECHNIQUES], 
making it particularly suitable for [TARGET_APPLICATION] requiring [SPECIFIC_REQUIREMENTS].
\end{abstract}
```

### Section Organization

The document structure follows a proven five-section organization that ensures comprehensive coverage and logical flow.

The introduction establishes problem context, surveys existing solutions, and clearly articulates your unique contribution to the field. System architecture provides high-level design overview and component relationships that form the foundation for detailed implementation.

Algorithmic implementation delves into mathematical foundations, presents core algorithms with complexity analysis, and demonstrates the theoretical soundness of the approach. Performance analysis presents benchmarks, measurements, and comparisons that validate the practical effectiveness of the proposed solution.

The conclusion summarizes key contributions and outlines future work directions that build upon the current research.

### Technical Writing Style

Technical writing demands precise language using exact technical terms while avoiding ambiguity that could lead to misinterpretation. Active voice construction, such as "We implemented" rather than "Implementation was done," creates more engaging and direct communication.

Present tense should be used for established facts and current system behavior, while past tense appropriately describes completed experiments and historical context. Consistent notation requires that all variables be clearly defined and symbols maintained consistently throughout the document to prevent confusion and ensure mathematical rigor.

## Quality Standards

### Mathematical Rigor

Mathematical rigor demands that every symbol be clearly defined with no ambiguity about its meaning or scope. All assumptions and constraints must be explicitly stated to establish the boundaries within which the mathematical framework operates.

Key theorems and lemmas require complete proofs that demonstrate their validity and establish the logical foundation for subsequent results. Mathematical soundness must be validated through rigorous analysis that shows results are not merely coincidental but follow logically from the established premises.

### Experimental Validation

Experimental validation requires reproducible results with sufficient detail for other researchers to replicate experiments and verify findings independently. Statistical significance must be demonstrated through confidence intervals and appropriate significance tests that establish the reliability of observed effects.

Baseline comparisons against established benchmarks provide context for evaluating the magnitude and importance of improvements or innovations. Real-world testing validates theoretical results with actual use cases and data that reflect the complexity and variability of practical applications.

### Code Quality

Code quality standards require that all examples compile and run successfully, demonstrating practical viability rather than theoretical concepts alone. Performance metrics must include actual measurements that quantify the effectiveness of proposed solutions with concrete data.

Error handling should be explicitly demonstrated to show how systems gracefully manage unexpected conditions and recover from failures. Thorough documentation through comprehensive comments ensures code clarity and facilitates understanding for future maintenance and extension.

## Real-World Examples from Your Papers

### NEXUS Collision Detection System Pattern

Based on your NEXUS paper, here's the proven pattern for algorithm papers:

```latex
\section{Algorithmic Implementation}

\subsection{Union-Find Data Structure}
The core of NEXUS is a modified Union-Find data structure with path compression and union by rank optimizations. The time complexity for find and union operations is $O(\alpha(n))$, where $\alpha(n)$ is the inverse Ackermann function.

\begin{algorithm}
\caption{Union-Find with Path Compression and Union by Rank}
\begin{algorithmic}[1]
\Function{Find}{x}
    \If{parent[x] $\neq$ x}
        \State parent[x] $\gets$ Find(parent[x]) \Comment{Path Compression}
    \EndIf
    \Return parent[x]
\EndFunction
\Statex
\Function{Union}{x, y}
    \State rootX $\gets$ Find(x)
    \State rootY $\gets$ Find(y)
    \If{rootX $\neq$ rootY}
        \If{rank[rootX] $<$ rank[rootY]}
            \State parent[rootX] $\gets$ rootY
        \ElsIf{rank[rootX] $>$ rank[rootY]}
            \State parent[rootY] $\gets$ rootX
        \Else
            \State parent[rootY] $\gets$ rootX
            \State rank[rootX] $\gets$ rank[rootX] + 1
        \EndIf
    \EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}
```

### VECTOR Engagement Tracking Pattern

Based on your VECTOR paper, here's the pattern for mathematical systems:

```latex
\section{Mathematical Foundation}
The core of VECTOR's analytical power lies in its application of linear algebra to model user behavior. User interactions are transformed into a dense, high-dimensional matrix, where rows represent users and columns represent various engagement metrics or features.

Let $M$ be the user-feature matrix of size $U \times F$, where $U$ is the number of users and $F$ is the number of features/metrics. $M_{ij}$ represents the value of feature $j$ for user $i$.

\subsubsection{Principal Component Analysis (PCA)}
PCA is used for dimensionality reduction and to identify the most significant underlying engagement patterns. The covariance matrix $C = \frac{1}{U-1} M^T M$ is computed. Eigenvalues and eigenvectors of $C$ are then extracted. The principal components are linear combinations of the original features that capture the maximum variance in the data.
\[
    M_{reduced} = M W
\]
where $W$ is the transformation matrix composed of the top $k$ eigenvectors.
```

### Comprehensive Refactor Analysis Pattern

Based on your modular refactoring paper, here's the pattern for system analysis:

```latex
\section{The Backend Leviathan Ecosystem}

\subsection{The Python Monolith Landscape}
Our analysis reveals a backend architecture that has grown into a collection of interconnected leviathans.

\begin{table}[ht]
\centering
\begin{tabular}{|p{3.5cm}|r|r|p{4cm}|}
\hline
\textbf{File} & \textbf{Lines} & \textbf{Size} & \textbf{Architectural Violations} \\
\hline
app/utils/lazy\_loader.py & 7,330 & 244KB & Package management leviathan \\
app/main.py & 4,412 & 147KB & API endpoint monolith \\
app/caption\_generation/plugins/florence2/.../modeling\_florence2.py & 3,161 & 105KB & ML model implementation \\
\hline
\end{tabular}
\caption{Backend Mega-Files (Table 1)}
\end{table}

\begin{quote}
\emph{The lazy loader leviathan is not just large; it is omnipotent. It manages package registration, dependency resolution, memory optimization, progress tracking, caching systems, analytics, service integration, configuration management, error handling, priority-based loading, unloading strategies, reloading mechanisms, WebSocket communication, and performance optimization. This single file has become the digital equivalent of a medieval castle - massive, complex, and nearly impossible to modify without affecting the entire system.}
\end{quote}
```

## Conclusion

Mastering academic writing requires precision, clarity, and systematic thinking. Your research papers demonstrate excellent technical writing with clear mathematical foundations, practical implementations, and rigorous performance analysis. By following these standards and maintaining the systematic approach evident in your existing work, you'll continue to produce high-quality academic documentation that advances both theory and practice.

The patterns established in your existing research papers - from the comprehensive modular refactoring analysis to the sophisticated NEXUS collision detection system and VECTOR engagement tracking - demonstrate a level of academic writing excellence that should be the standard for all future research.

Key principles for effective academic writing encompass mathematical rigor with practical validation, ensuring every equation is precise and every algorithm is thoroughly validated through empirical testing.

Clear algorithmic presentation requires well-formatted algorithms with complete complexity analysis that demonstrates both theoretical understanding and practical efficiency. Comprehensive performance measurement and comparison provide empirical validation with measurable improvements that establish the practical value of proposed solutions.

Reproducible results demand detailed implementation descriptions that enable other researchers to replicate experiments with clear methodology and sufficient detail. Professional presentation requires consistent LaTeX formatting and proper citation practices that meet academic standards and facilitate peer review.

Strategic use of quotes and examples enhances understanding by illuminating complex concepts with well-placed references and real-world applications. Systematic analysis combines theoretical foundations with practical measurements to create research that advances both knowledge and application.

These guidelines ensure that your research contributions are accessible, credible, and impactful within the broader technical community. Your existing papers demonstrate these principles beautifully, and these enhanced guidelines will help maintain that standard of excellence.

*Hunt down insights with the relentless curiosity of a wolf, and let your research leave a lasting mark on the field.* 🐺
