---
globs: *.md,*.mdc,*.mdx
alwaysApply: false
---

# Technical Documentation Writing Rules

Technical documentation should be written with clarity, accuracy, and a focus
on the reader's needs. Content must be well-structured, concise, and anticipate
potential questions or challenges, providing clear explanations, actionable steps,
and relevant context to support effective understanding and implementation.

These guidelines capture the sophisticated patterns that make your technical
writing exceptional.

## Core Principles

### Documentation Philosophy

Every piece of technical documentation in the Reynard project should embody
these core values, following the patterns established in your comprehensive
guides:

Strategic clarity involves writing with foresight and precision, anticipating
reader needs with real-world examples. Modular structure creates
self-contained, reusable documentation components with clear cross-references.
Comprehensive coverage always provides alternative approaches, troubleshooting
paths, and performance considerations. Efficiency without compromise delivers
maximum value with minimal cognitive load through strategic organization.
Resilient design ensures documentation adapts to changing requirements with
version-aware content.

## Documentation Structure

### Standard Document Template

Based on these documentation patterns, follow this proven structure:

```markdown
# [System/Feature Name] Guide

*[Brief tagline describing the system's purpose and key benefits]*

## Overview

[Clear, concise explanation of what this covers with context and scope]

## Installation/Setup
[Prerequisites, installation steps, and initial configuration]

## [Core Functionality Sections]
[Organized by complexity and use case with real-world examples]

## Advanced Patterns
[Complex scenarios, optimization techniques, and production considerations]

## API Reference
[Complete API documentation with examples and error handling]

## Performance Considerations
[Optimization strategies, benchmarks, and monitoring]

## Best Practices
[Key recommendations and patterns derived from real-world usage]

## Troubleshooting
[Common issues and solutions with systematic debugging approaches]

## Conclusion
[Summary with key takeaways and next steps]
```

### Section Organization

Start with an overview that always provides context and scope. Progress from
simple to complex concepts, building understanding incrementally. Include
practical examples that show rather than just tell. End with actionable
takeaways that give readers clear next steps.

## Writing Guidelines

### Tone and Voice

Maintain a professional and clear tone with technical accuracy and accessible
language. Be direct and concise, avoiding unnecessary words or complex
sentences. Use consistent terminology from established Reynard vocabulary.
Employ an engaging style that maintains reader interest while staying
professional.

### Code Examples

```typescript
// Good: Clear, commented, and contextual
function optimizeRoute(route: Route): OptimizedRoute {
  // Apply lazy loading for better performance
  return {
    ...route,
    component: lazy(() => import(route.componentPath))
  };
}

// Bad: Unclear purpose and no context
function opt(r) { return {...r, c: lazy(() => import(r.cp))}; }
```

### Code Block Standards

Always include language specification such as `typescript`, `bash`, `json`, etc.
Provide context by explaining what the code does and why. Include error
handling that shows both success and failure cases. Use realistic examples
that avoid contrived or overly simplified code.

## Content Guidelines

### Technical Accuracy

Verify all code examples to ensure they compile and run. Test all procedures
by following step-by-step instructions yourself. Update regularly to keep
documentation current with code changes. Cross-reference by linking to
related documentation and external resources.

### Accessibility

Use semantic structure with proper heading hierarchy (H1 → H2 → H3). Include
alt text for images and diagrams. Provide multiple formats including code,
prose, and visual explanations. Test with screen readers to ensure content
is accessible.

### Performance Considerations

Optimize for scanning by using bullet points, numbered lists, and clear
headings. Include quick reference sections that provide TL;DR summaries for
complex topics. Link strategically to connect related concepts without
overwhelming readers. Minimize cognitive load by breaking complex topics
into digestible chunks.

## Documentation Types

### Development Guides

**Purpose**: Help developers implement features and understand architecture

**Structure**:

Include overview and prerequisites, step-by-step implementation guidance,
code examples with explanations, integration points and dependencies, and
performance considerations.

**Example Topics**:

Cover component development, API integration, state management, and routing
and navigation topics.

### Analysis Documentation

**Purpose**: Provide systematic approaches to testing, debugging, and optimization

**Structure**:

Address problem definition and scope, analysis methodology, tools and
techniques, results interpretation, and recommendations.

**Example Topics**:

Include performance profiling, testing strategies, debugging workflows, and
code quality analysis.

### Security and Error Handling

**Purpose**: Address potential failure modes and security considerations

**Structure**:

Cover threat models or failure scenarios, mitigation strategies,
implementation details, monitoring and alerting, and incident response.

**Example Topics**:

Address security best practices, error boundary implementation, input
validation, and authentication flows.

## Real-World Examples from Your Documentation

### Solid Router Guide Pattern

Based on your comprehensive Solid Router guide, here's the proven pattern
for framework documentation:

```markdown
# Solid Router Guide

*Comprehensive routing solution for SolidJS applications with universal
rendering support.*

## Overview

Solid Router is the universal router for SolidJS that provides seamless
client and server-side rendering capabilities. Built with performance and
developer experience in mind, it offers flexible routing patterns that scale
from simple single-page applications to complex enterprise solutions.

## Installation

Install Solid Router using your preferred package manager:

```bash
npm i @solidjs/router
```

### Package Configuration

In the Reynard ecosystem, Solid Router is typically configured in Vite
builds with manual chunk splitting for optimal performance:

```typescript
// vite.config.ts
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          'solid-router': ['@solidjs/router'],
          'reynard-core': ['reynard-core'],
          'reynard-components': ['reynard-components'],
        }
      }
    }
  }
});
```

## Basic Setup

### Router Configuration

The `Router` component serves as the root of your routing system, managing
URL state and rendering appropriate routes. In production applications, the
router is typically wrapped with application providers and context.

**Production Router Setup (Reynard Pattern):**

```tsx
// examples/comprehensive-dashboard/src/index.tsx
import { render } from "solid-js/web";
import { Router } from "@solidjs/router";
import App from "./App";

render(
  () => (
    <Router>
      <App />
    </Router>
  ),
  document.getElementById("root")!
);
```

### Caption Generation System Pattern

Based on your Caption Generation documentation, here's the pattern for
system architecture documentation:

```markdown
# Caption Generation

This system provides a unified, model-agnostic way to generate captions and
tags in the Reynard framework. It discovers captioners at runtime, applies
retry and post-processing policies, and can persist results for the gallery.
The system is implemented in the `reynard-annotating` package.

## Architecture

Captioning is implemented as a plugin system in the `reynard-annotating`
package that discovers available generators at runtime and exposes a single
service surface. The abstract interface `BaseCaptionGenerator` defines async
generation, availability checks, configuration schema, versioning, and a
`caption_type`. The `AnnotationManager` coordinates model loading with
concurrency locks, bounded retries, post-processing, and optional
persistence to the data source.

Frontend files in packages/annotating include `src/AnnotationManager.ts` as
the main orchestrator, `src/AnnotationService.ts` for the service layer,
`src/BaseCaptionGenerator.ts` as the abstract base class, and
`src/generators/*` for generator implementations. Backend files (TBD) include
`app/caption_generation/base.py`, `app/caption_generation/__init__.py`,
`app/caption_generation/plugin_loader.py`,
`app/caption_generation/caption_service.py`, and
`app/caption_generation/plugins/*`.

## Backend API

The main endpoints for captions live in the app router. Use
`POST /api/generate-caption/{path}` to trigger a single caption with query
parameters `generator` (name), `force` (bool), and `post_process` (bool).
The service validates the generator via the unified manager and returns a
structured result with `success`, `caption`, `processing_time`, and
`caption_type`.
```markdown

### RAG System Pattern

Based on your RAG documentation, here's the pattern for complex system documentation:

```markdown
# RAG Chunking & Ingestion

This document outlines the recommended chunking strategies and ingestion
pipeline for Retrieval-Augmented Generation (RAG) in YipYap.

## Architecture Overview

YipYap's RAG subsystem is composed of a streaming-friendly indexing
service, dedicated embedding services for text and images, a vector database
layer backed by Postgres and pgvector, and a thin API. The indexing service
coordinates chunking, batching, embedding, and vector upserts with progress
events.

## Document Chunking

Use semantic-first chunking: split documents by headings and sentences,
then group into windows targeting approximately 1000 tokens (minimum 800,
maximum 1200), with 10–15% overlap. If semantic segmentation cannot reach
the minimum size, fall back to a recursive character splitter (about 4
characters per token).

## Code Chunking

Prefer language-aware parsing (such as tree-sitter) when available. If
unavailable, use regex to identify `def`, `class`, and import block
boundaries, then build windows of 150–400 lines of code with a 3–5 line
overlap. Maintain a simple symbol map (functions, classes, imports) to
support highlighting and search.

## Security, Limits, and Privacy Controls

The RAG subsystem includes configurable limits and privacy toggles in
`AppConfig` with corresponding env overrides via the config manager.
Defaults are chosen for safe operation.

Rate limits per user include `rag_query_rate_limit_per_minute` (default 60)
and `rag_ingest_rate_limit_per_minute` (default 10). Request size clamps
include `rag_query_topk_max` (default 50),
`rag_ingest_max_items_per_request` (default 100),
`rag_ingest_max_content_length` (default 50000), and
`rag_clip_max_items_per_request` (default 100).
```

### API Documentation Pattern

```markdown
# [API Name] API

## Endpoint Overview
[Base URL, authentication, rate limits]

## Request/Response Format
```json
{
  // Example request/response
}
```

## Error Handling

[Error codes, messages, and handling strategies]

## Rate Limiting

[Limits, headers, and best practices]

## Examples

[Common use cases with curl/JavaScript examples]

```markdown

### Troubleshooting Guide

# [Feature] Troubleshooting

## Common Issues

### Issue: [Problem Description]
**Symptoms**: [What users see]
**Causes**: [Why it happens]
**Solutions**: [Step-by-step fixes]

### Issue: [Another Problem]
[Repeat structure]

## Debug Mode
[How to enable and use debug features]

## Log Analysis
[How to read and interpret logs]

## Getting Help
[Where to find additional support]
```

## Comprehensive Quality Checklists

### Technical Documentation Quality Checklist

#### Content Quality

- [ ] **Accuracy**: All code examples tested and verified in actual environment
- [ ] **Completeness**: All necessary information included with no gaps
- [ ] **Clarity**: Language is clear and technical jargon is explained
- [ ] **Real-world Examples**: Practical examples from actual Reynard codebase
- [ ] **Performance Considerations**: Optimization strategies and benchmarks included
- [ ] **Error Handling**: Comprehensive error scenarios and recovery strategies
- [ ] **Security**: Security considerations and best practices addressed

#### Structure and Organization

- [ ] **Logical Flow**: Information progresses from simple to complex
- [ ] **Heading Hierarchy**: Proper H1 → H2 → H3 structure maintained
- [ ] **Cross-references**: Related documentation properly linked
- [ ] **Table of Contents**: Clear navigation for long documents
- [ ] **Consistent Formatting**: Code blocks, lists, and tables properly formatted

#### Technical Documentation Accuracy

- [ ] **API Documentation**: Complete endpoint documentation with examples
- [ ] **Configuration Options**: All configuration parameters documented
- [ ] **Dependencies**: Prerequisites and requirements clearly stated
- [ ] **Version Compatibility**: Version requirements and compatibility noted
- [ ] **Migration Paths**: Upgrade and migration instructions provided

#### User Experience

- [ ] **Quick Start**: Clear getting started instructions
- [ ] **Troubleshooting**: Common issues and solutions provided
- [ ] **Best Practices**: Proven patterns and recommendations included
- [ ] **Accessibility**: Proper semantic structure and alt text for images
- [ ] **Searchability**: Keywords and concepts easily discoverable

### Academic Paper Quality Checklist

#### Mathematical Rigor

- [ ] **Notation Consistency**: All variables and symbols clearly defined
- [ ] **Proof Completeness**: All theorems and lemmas properly proven
- [ ] **Complexity Analysis**: Time and space complexity clearly stated
- [ ] **Algorithm Correctness**: Algorithms verified and validated
- [ ] **Mathematical Precision**: All equations and formulas accurate

#### Experimental Validation

- [ ] **Reproducible Results**: All experiments can be reproduced
- [ ] **Statistical Significance**: Proper statistical analysis included
- [ ] **Baseline Comparisons**: Comparison with existing methods
- [ ] **Performance Metrics**: Measurable performance improvements
- [ ] **Real-world Testing**: Validation with actual use cases

#### Writing Quality

- [ ] **Abstract Clarity**: Abstract clearly states problem, solution, and results
- [ ] **Introduction Context**: Problem context and motivation clearly established
- [ ] **Related Work**: Comprehensive review of existing approaches
- [ ] **Contribution Clarity**: Novel contributions clearly articulated
- [ ] **Conclusion Impact**: Future work and impact assessment included

#### Technical Presentation

- [ ] **Algorithm Presentation**: Algorithms clearly formatted and explained
- [ ] **Figure Quality**: All figures and diagrams are clear and informative
- [ ] **Table Formatting**: Tables properly formatted with clear headers
- [ ] **Code Examples**: Code examples are complete and functional
- [ ] **Citation Accuracy**: All references properly cited and accessible

### Regular Maintenance Checklist

#### Documentation Maintenance

- [ ] **Update Frequency**: Review quarterly or with major changes
- [ ] **Version Alignment**: Ensure documentation matches current code
- [ ] **User Feedback**: Incorporate feedback from developers and users
- [ ] **Link Checking**: Verify all links are still valid
- [ ] **Example Testing**: Re-test all code examples
- [ ] **Performance Updates**: Update benchmarks and performance data
- [ ] **Security Updates**: Review and update security considerations

#### Academic Paper Maintenance

- [ ] **Citation Updates**: Keep references current and accessible
- [ ] **Performance Data**: Update benchmarks with new results
- [ ] **Algorithm Improvements**: Document any algorithmic enhancements
- [ ] **Experimental Validation**: Add new experimental results
- [ ] **Related Work**: Update with new relevant research
- [ ] **Reproducibility**: Ensure all experiments remain reproducible

## Tools and Resources

### Documentation Tools

- **Markdown**: Primary format for all documentation
- **Mermaid**: For diagrams and flowcharts
- **Code highlighting**: Use appropriate language tags
- **Link validation**: Regular checking of internal and external links

### Review Process

1. **Self-review**: Use the quality checklist
2. **Peer review**: Have another developer review
3. **User testing**: Get feedback from actual users
4. **Iteration**: Improve based on feedback

## Conclusion

🦊> *Mastering technical documentation requires strategic thinking, clear
communication, and attention to detail - just like the cunning fox who plans
every move with precision.*

Mastering technical documentation requires strategic thinking, clear
communication, and attention to detail. By following these guidelines and
maintaining the Reynard project's commitment to excellence, you'll create
documentation that not only informs but empowers developers to build better
solutions.

The patterns established in your existing documentation - from the
comprehensive Solid Router guide to the sophisticated RAG system
documentation - demonstrate a level of technical writing excellence that
should be the standard for all future documentation.

Key principles to remember:

Write for your future self and new team members by making documentation
self-contained and comprehensive. Test everything you document to ensure all
code examples are verified and functional. Keep it current and accurate
through regular maintenance that ensures documentation remains valuable.
Make it accessible and scannable since structure and formatting matter as
much as content. Focus on practical, actionable content where real-world
examples and troubleshooting are essential. Include performance
considerations as optimization strategies and benchmarks add significant
value. Address security and error handling with comprehensive coverage of
edge cases and failure modes.

Effective documentation is the foundation of successful software projects
and enables teams to work efficiently and maintain high-quality codebases.
Your existing documentation demonstrates this principle beautifully, and
these enhanced guidelines will help maintain that standard of excellence.

*Build documentation that empowers developers to outfox complexity and
create exceptional solutions.* 🦊
