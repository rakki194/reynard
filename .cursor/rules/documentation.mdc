---
globs: *.md,*.mdc,*.mdx
alwaysApply: false
---

# Technical Documentation Writing Rules

Technical documentation should be written with clarity, accuracy, and a focus on the reader's needs. Content must be well-structured, concise, and anticipate potential questions or challenges, providing clear explanations, actionable steps, and relevant context to support effective understanding and implementation.

These guidelines capture the sophisticated patterns that make your technical writing exceptional.

## Core Principles

### Documentation Philosophy

Every piece of technical documentation in the Reynard project should embody these core values, following the patterns established in your comprehensive guides:

- **Strategic Clarity**: Write with foresight and precision, anticipating reader needs with real-world examples
- **Modular Structure**: Create self-contained, reusable documentation components with clear cross-references
- **Comprehensive Coverage**: Always provide alternative approaches, troubleshooting paths, and performance considerations
- **Efficiency Without Compromise**: Deliver maximum value with minimal cognitive load through strategic organization
- **Resilient Design**: Documentation that adapts to changing requirements with version-aware content

## Documentation Structure

### Standard Document Template

Based these documentation patterns, follow this proven structure:

```markdown
# [System/Feature Name] Guide

*[Brief tagline describing the system's purpose and key benefits]*

## Overview

[Clear, concise explanation of what this covers with context and scope]

## Installation/Setup
[Prerequisites, installation steps, and initial configuration]

## [Core Functionality Sections]
[Organized by complexity and use case with real-world examples]

## Advanced Patterns
[Complex scenarios, optimization techniques, and production considerations]

## API Reference
[Complete API documentation with examples and error handling]

## Performance Considerations
[Optimization strategies, benchmarks, and monitoring]

## Best Practices
[Key recommendations and patterns derived from real-world usage]

## Troubleshooting
[Common issues and solutions with systematic debugging approaches]

## Conclusion
[Summary with key takeaways and next steps]
```

### Section Organization

1. **Start with Overview**: Always provide context and scope
2. **Progress from Simple to Complex**: Build understanding incrementally
3. **Include Practical Examples**: Show, don't just tell
4. **End with Actionable Takeaways**: Give readers clear next steps

## Writing Guidelines

### Tone and Voice

- **Professional and Clear**: Technical accuracy with accessible language
- **Direct and Concise**: Avoid unnecessary words or complex sentences
- **Consistent Terminology**: Use established Reynard vocabulary
- **Engaging Style**: Maintain reader interest while staying professional

### Code Examples

```typescript
// Good: Clear, commented, and contextual
function optimizeRoute(route: Route): OptimizedRoute {
  // Apply lazy loading for better performance
  return {
    ...route,
    component: lazy(() => import(route.componentPath))
  };
}

// Bad: Unclear purpose and no context
function opt(r) { return {...r, c: lazy(() => import(r.cp))}; }
```

### Code Block Standards

- **Always include language specification**: `typescript`, `bash`, `json`, etc.
- **Provide context**: Explain what the code does and why
- **Include error handling**: Show both success and failure cases
- **Use realistic examples**: Avoid contrived or overly simplified code

## Content Guidelines

### Technical Accuracy

- **Verify all code examples**: Ensure they compile and run
- **Test all procedures**: Follow step-by-step instructions yourself
- **Update regularly**: Keep documentation current with code changes
- **Cross-reference**: Link to related documentation and external resources

### Accessibility

- **Use semantic structure**: Proper heading hierarchy (H1 → H2 → H3)
- **Include alt text**: For images and diagrams
- **Provide multiple formats**: Code, prose, and visual explanations
- **Test with screen readers**: Ensure content is accessible

### Performance Considerations

- **Optimize for scanning**: Use bullet points, numbered lists, and clear headings
- **Include quick reference**: Provide TL;DR sections for complex topics
- **Link strategically**: Connect related concepts without overwhelming
- **Minimize cognitive load**: Break complex topics into digestible chunks

## Documentation Types

### Development Guides

**Purpose**: Help developers implement features and understand architecture

**Structure**:

- Overview and prerequisites
- Step-by-step implementation
- Code examples with explanations
- Integration points and dependencies
- Performance considerations

**Example Topics**:

- Component development
- API integration
- State management
- Routing and navigation

### Analysis Documentation

**Purpose**: Provide systematic approaches to testing, debugging, and optimization

**Structure**:

- Problem definition and scope
- Analysis methodology
- Tools and techniques
- Results interpretation
- Recommendations

**Example Topics**:

- Performance profiling
- Testing strategies
- Debugging workflows
- Code quality analysis

### Security and Error Handling

**Purpose**: Address potential failure modes and security considerations

**Structure**:

- Threat model or failure scenarios
- Mitigation strategies
- Implementation details
- Monitoring and alerting
- Incident response

**Example Topics**:

- Security best practices
- Error boundary implementation
- Input validation
- Authentication flows

## Real-World Examples from Your Documentation

### Solid Router Guide Pattern

Based on your comprehensive Solid Router guide, here's the proven pattern for framework documentation:

```markdown
# Solid Router Guide

*Comprehensive routing solution for SolidJS applications with universal rendering support.*

## Overview

Solid Router is the universal router for SolidJS that provides seamless client and server-side rendering capabilities. Built with performance and developer experience in mind, it offers flexible routing patterns that scale from simple single-page applications to complex enterprise solutions.

## Installation

Install Solid Router using your preferred package manager:

```bash
npm i @solidjs/router
```

### Package Configuration

In the Reynard ecosystem, Solid Router is typically configured in Vite builds with manual chunk splitting for optimal performance:

```typescript
// vite.config.ts
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          'solid-router': ['@solidjs/router'],
          'reynard-core': ['reynard-core'],
          'reynard-components': ['reynard-components'],
        }
      }
    }
  }
});
```

## Basic Setup

### Router Configuration

The `Router` component serves as the root of your routing system, managing URL state and rendering appropriate routes. In production applications, the router is typically wrapped with application providers and context.

**Production Router Setup (Reynard Pattern):**

```tsx
// examples/comprehensive-dashboard/src/index.tsx
import { render } from "solid-js/web";
import { Router } from "@solidjs/router";
import App from "./App";

render(
  () => (
    <Router>
      <App />
    </Router>
  ),
  document.getElementById("root")!
);
```

### Caption Generation System Pattern

Based on your Caption Generation documentation, here's the pattern for system architecture documentation:

```markdown
# Caption Generation

This system provides a unified, model-agnostic way to generate captions and tags in the Reynard framework. It discovers captioners at runtime, applies retry and post-processing policies, and can persist results for the gallery. The system is implemented in the `reynard-annotating` package.

## Architecture

Captioning is implemented as a plugin system in the `reynard-annotating` package that discovers available generators at runtime and exposes a single service surface. The abstract interface `BaseCaptionGenerator` defines async generation, availability checks, configuration schema, versioning, and a `caption_type`. The `AnnotationManager` coordinates model loading with concurrency locks, bounded retries, post-processing, and optional persistence to the data source.

- Frontend Files (packages/annotating):
  - `src/AnnotationManager.ts` - Main orchestrator
  - `src/AnnotationService.ts` - Service layer
  - `src/BaseCaptionGenerator.ts` - Abstract base class
  - `src/generators/*` - Generator implementations
- Backend Files (TBD):
  - `app/caption_generation/base.py`
  - `app/caption_generation/__init__.py`
  - `app/caption_generation/plugin_loader.py`
  - `app/caption_generation/caption_service.py`
  - `app/caption_generation/plugins/*`

## Backend API

The main endpoints for captions live in the app router. Use `POST /api/generate-caption/{path}` to trigger a single caption with query parameters `generator` (name), `force` (bool), and `post_process` (bool). The service validates the generator via the unified manager and returns a structured result with `success`, `caption`, `processing_time`, and `caption_type`.
```markdown

### RAG System Pattern

Based on your RAG documentation, here's the pattern for complex system documentation:

```markdown
# RAG Chunking & Ingestion

This document outlines the recommended chunking strategies and ingestion pipeline for Retrieval-Augmented Generation (RAG) in YipYap.

## Architecture Overview

YipYap's RAG subsystem is composed of a streaming-friendly indexing service, dedicated embedding services for text and images, a vector database layer backed by Postgres and pgvector, and a thin API. The indexing service coordinates chunking, batching, embedding, and vector upserts with progress events.

## Document Chunking

Use semantic-first chunking: split documents by headings and sentences, then group into windows targeting approximately 1000 tokens (minimum 800, maximum 1200), with 10–15% overlap. If semantic segmentation cannot reach the minimum size, fall back to a recursive character splitter (about 4 characters per token).

## Code Chunking

Prefer language-aware parsing (such as tree-sitter) when available. If unavailable, use regex to identify `def`, `class`, and import block boundaries, then build windows of 150–400 lines of code with a 3–5 line overlap. Maintain a simple symbol map (functions, classes, imports) to support highlighting and search.

## Security, Limits, and Privacy Controls

The RAG subsystem includes configurable limits and privacy toggles in `AppConfig` with corresponding env overrides via the config manager. Defaults are chosen for safe operation.

- Rate limits (per user):
  - `rag_query_rate_limit_per_minute` (default 60)
  - `rag_ingest_rate_limit_per_minute` (default 10)
- Request size clamps:
  - `rag_query_topk_max` (default 50)
  - `rag_ingest_max_items_per_request` (default 100)
  - `rag_ingest_max_content_length` (default 50000)
  - `rag_clip_max_items_per_request` (default 100)
```

### API Documentation Pattern

```markdown
# [API Name] API

## Endpoint Overview
[Base URL, authentication, rate limits]

## Request/Response Format
```json
{
  // Example request/response
}
```

## Error Handling

[Error codes, messages, and handling strategies]

## Rate Limiting

[Limits, headers, and best practices]

## Examples

[Common use cases with curl/JavaScript examples]

```markdown

### Troubleshooting Guide

# [Feature] Troubleshooting

## Common Issues

### Issue: [Problem Description]
**Symptoms**: [What users see]
**Causes**: [Why it happens]
**Solutions**: [Step-by-step fixes]

### Issue: [Another Problem]
[Repeat structure]

## Debug Mode
[How to enable and use debug features]

## Log Analysis
[How to read and interpret logs]

## Getting Help
[Where to find additional support]
```

## Comprehensive Quality Checklists

### Technical Documentation Quality Checklist

#### Content Quality

- [ ] **Accuracy**: All code examples tested and verified in actual environment
- [ ] **Completeness**: All necessary information included with no gaps
- [ ] **Clarity**: Language is clear and technical jargon is explained
- [ ] **Real-world Examples**: Practical examples from actual Reynard codebase
- [ ] **Performance Considerations**: Optimization strategies and benchmarks included
- [ ] **Error Handling**: Comprehensive error scenarios and recovery strategies
- [ ] **Security**: Security considerations and best practices addressed

#### Structure and Organization

- [ ] **Logical Flow**: Information progresses from simple to complex
- [ ] **Heading Hierarchy**: Proper H1 → H2 → H3 structure maintained
- [ ] **Cross-references**: Related documentation properly linked
- [ ] **Table of Contents**: Clear navigation for long documents
- [ ] **Consistent Formatting**: Code blocks, lists, and tables properly formatted

#### Technical Documentation Accuracy

- [ ] **API Documentation**: Complete endpoint documentation with examples
- [ ] **Configuration Options**: All configuration parameters documented
- [ ] **Dependencies**: Prerequisites and requirements clearly stated
- [ ] **Version Compatibility**: Version requirements and compatibility noted
- [ ] **Migration Paths**: Upgrade and migration instructions provided

#### User Experience

- [ ] **Quick Start**: Clear getting started instructions
- [ ] **Troubleshooting**: Common issues and solutions provided
- [ ] **Best Practices**: Proven patterns and recommendations included
- [ ] **Accessibility**: Proper semantic structure and alt text for images
- [ ] **Searchability**: Keywords and concepts easily discoverable

### Academic Paper Quality Checklist

#### Mathematical Rigor

- [ ] **Notation Consistency**: All variables and symbols clearly defined
- [ ] **Proof Completeness**: All theorems and lemmas properly proven
- [ ] **Complexity Analysis**: Time and space complexity clearly stated
- [ ] **Algorithm Correctness**: Algorithms verified and validated
- [ ] **Mathematical Precision**: All equations and formulas accurate

#### Experimental Validation

- [ ] **Reproducible Results**: All experiments can be reproduced
- [ ] **Statistical Significance**: Proper statistical analysis included
- [ ] **Baseline Comparisons**: Comparison with existing methods
- [ ] **Performance Metrics**: Measurable performance improvements
- [ ] **Real-world Testing**: Validation with actual use cases

#### Writing Quality

- [ ] **Abstract Clarity**: Abstract clearly states problem, solution, and results
- [ ] **Introduction Context**: Problem context and motivation clearly established
- [ ] **Related Work**: Comprehensive review of existing approaches
- [ ] **Contribution Clarity**: Novel contributions clearly articulated
- [ ] **Conclusion Impact**: Future work and impact assessment included

#### Technical Presentation

- [ ] **Algorithm Presentation**: Algorithms clearly formatted and explained
- [ ] **Figure Quality**: All figures and diagrams are clear and informative
- [ ] **Table Formatting**: Tables properly formatted with clear headers
- [ ] **Code Examples**: Code examples are complete and functional
- [ ] **Citation Accuracy**: All references properly cited and accessible

### Regular Maintenance Checklist

#### Documentation Maintenance

- [ ] **Update Frequency**: Review quarterly or with major changes
- [ ] **Version Alignment**: Ensure documentation matches current code
- [ ] **User Feedback**: Incorporate feedback from developers and users
- [ ] **Link Checking**: Verify all links are still valid
- [ ] **Example Testing**: Re-test all code examples
- [ ] **Performance Updates**: Update benchmarks and performance data
- [ ] **Security Updates**: Review and update security considerations

#### Academic Paper Maintenance

- [ ] **Citation Updates**: Keep references current and accessible
- [ ] **Performance Data**: Update benchmarks with new results
- [ ] **Algorithm Improvements**: Document any algorithmic enhancements
- [ ] **Experimental Validation**: Add new experimental results
- [ ] **Related Work**: Update with new relevant research
- [ ] **Reproducibility**: Ensure all experiments remain reproducible

## Tools and Resources

### Documentation Tools

- **Markdown**: Primary format for all documentation
- **Mermaid**: For diagrams and flowcharts
- **Code highlighting**: Use appropriate language tags
- **Link validation**: Regular checking of internal and external links

### Review Process

1. **Self-review**: Use the quality checklist
2. **Peer review**: Have another developer review
3. **User testing**: Get feedback from actual users
4. **Iteration**: Improve based on feedback

## Conclusion

🦊> *Mastering technical documentation requires strategic thinking, clear communication, and attention to detail - just like the cunning fox who plans every move with precision.*

Mastering technical documentation requires strategic thinking, clear communication, and attention to detail. By following these guidelines and maintaining the Reynard project's commitment to excellence, you'll create documentation that not only informs but empowers developers to build better solutions.

The patterns established in your existing documentation - from the comprehensive Solid Router guide to the sophisticated RAG system documentation - demonstrate a level of technical writing excellence that should be the standard for all future documentation.

Key principles to remember:

- **Write for your future self and new team members**: Documentation should be self-contained and comprehensive
- **Test everything you document**: All code examples must be verified and functional
- **Keep it current and accurate**: Regular maintenance ensures documentation remains valuable
- **Make it accessible and scannable**: Structure and formatting matter as much as content
- **Focus on practical, actionable content**: Real-world examples and troubleshooting are essential
- **Include performance considerations**: Optimization strategies and benchmarks add significant value
- **Address security and error handling**: Comprehensive coverage of edge cases and failure modes

Effective documentation is the foundation of successful software projects and enables teams to work efficiently and maintain high-quality codebases. Your existing documentation demonstrates this principle beautifully, and these enhanced guidelines will help maintain that standard of excellence.

*Build documentation that empowers developers to outfox complexity and create exceptional solutions.* 🦊
