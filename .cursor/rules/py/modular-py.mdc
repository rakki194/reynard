---
globs: *.py
alwaysApply: false
---

# Modular Python Manifesto

> Essential patterns for maintainable Python architecture

## Core Principles

### The 100-Line Axiom

Every Python source file should be under 100 lines (excluding blank lines and comments). This forces:

- **Clear Separation of Concerns**: Single, well-defined responsibility per file
- **Improved Readability**: Files small enough to understand at a glance  
- **Better Testability**: Smaller modules are easier to test comprehensively
- **Enhanced Maintainability**: Changes are localized and predictable

### Three Pillars

1. **Small** - Each line of code costs energy to maintain
2. **Modular** - Organized into groups of swappable modules
3. **Self-contained** - Easily reusable via cross-project integration

## Essential Patterns

### 1. Service-Oriented Architecture

```python
# services/database.py
class DatabaseService:
    """Database service with connection pooling"""
    
    def __init__(self):
        self.connection_pool = None
        self.is_initialized = False
    
    async def initialize(self):
        """Initialize database connection pool"""
        if IS_RELOAD_MODE:
            return  # Skip in reload mode
        
        self.connection_pool = create_connection_pool()
        self.is_initialized = True
    
    async def get_connection(self):
        """Get a database connection from the pool"""
        if not self.is_initialized:
            raise RuntimeError("Service not initialized")
        return await self.connection_pool.acquire()
    
    async def close(self):
        """Close database connections and cleanup"""
        if self.connection_pool:
            await self.connection_pool.close()
```

### 2. Lazy Loading Pattern

```python
# utils/lazy_loader.py
class LazyPackageExport:
    """Lazy loading proxy for heavy packages"""
    
    def __init__(self, package_name: str):
        self.package_name = package_name
        self._module = None
    
    def __getattr__(self, name: str):
        """Lazy load the module and return the requested attribute"""
        if self._module is None:
            self._module = __import__(self.package_name)
        return getattr(self._module, name)
```

### 3. FastAPI Modular Structure

```python
# main.py
from contextlib import asynccontextmanager
from fastapi import FastAPI

# Global services
services = {}

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan manager"""
    if IS_RELOAD_MODE:
        yield
        return
    
    # Initialize services
    services['database'] = DatabaseService()
    await services['database'].initialize()
    
    yield
    
    # Cleanup
    await services['database'].close()

app = FastAPI(lifespan=lifespan)
app.include_router(health.router, prefix="/api")
```

### 4. Authentication Module

```python
# auth/token_manager.py
class TokenManager:
    """Token management for JWT operations"""
    
    def __init__(self, config: TokenConfig):
        self.config = config
        self._blacklisted_tokens: Set[str] = set()
    
    def create_token(self, data: TokenData) -> TokenResponse:
        """Create a new JWT token"""
        to_encode = data.dict().copy()
        expire = datetime.now(timezone.utc) + timedelta(seconds=self.config.expire_seconds)
        to_encode.update({"exp": expire})
        
        encoded_jwt = jwt.encode(to_encode, self.config.secret_key, algorithm=self.config.algorithm)
        return TokenResponse(access_token=encoded_jwt, token_type="bearer")
    
    def validate_token(self, token: str) -> TokenValidationResult:
        """Validate a JWT token"""
        try:
            if token in self._blacklisted_tokens:
                return TokenValidationResult(valid=False, error="Token revoked")
            
            payload = jwt.decode(token, self.config.secret_key, algorithms=[self.config.algorithm])
            username: str = payload.get("sub")
            
            if username is None:
                return TokenValidationResult(valid=False, error="Invalid payload")
            
            return TokenValidationResult(valid=True, username=username)
            
        except JWTError as e:
            return TokenValidationResult(valid=False, error=f"Validation failed: {e}")
```

### 5. Backend Abstraction

```python
# backends/base.py
from abc import ABC, abstractmethod

class UserBackend(ABC):
    """Abstract base class for user backends"""
    
    @abstractmethod
    async def create_user(self, user_data: Dict[str, Any]) -> User:
        pass
    
    @abstractmethod
    async def get_user_by_id(self, user_id: str) -> Optional[User]:
        pass

# backends/sqlite.py
class SQLiteBackend(UserBackend):
    """SQLite implementation of user backend"""
    
    def __init__(self, database_url: str = "sqlite:///./gatekeeper.db"):
        self.database_url = database_url
        self._initialized = False
    
    async def _initialize(self) -> None:
        """Initialize the database connection"""
        if self._initialized:
            return
        
        self.engine = create_engine(self.database_url)
        self.session_factory = sessionmaker(bind=self.engine)
        Base.metadata.create_all(bind=self.engine)
        self._initialized = True
    
    async def create_user(self, user_data: Dict[str, Any]) -> User:
        """Create a new user in SQLite"""
        await self._initialize()
        
        with self.session_factory() as session:
            user_model = UserModel(**user_data)
            session.add(user_model)
            session.commit()
            session.refresh(user_model)
            return self._model_to_user(user_model)
```

## Refactoring Strategies

### Extract Service Classes

**Before** (Monolithic):

```python
# main.py (500+ lines)
class Application:
    def __init__(self):
        self.database = None
        self.cache = None
        # ... 400+ more lines of mixed concerns
```

**After** (Modular):

```python
# services/database.py (80 lines)
class DatabaseService:
    async def initialize(self): pass
    async def close(self): pass

# main.py (50 lines) - Orchestrator
class Application:
    def __init__(self):
        self.database = DatabaseService()
        self.cache = CacheService()
```

### Extract Route Modules

**Before** (Single Routes File):

```python
# routes.py (300+ lines)
@router.get("/users")
async def get_users(): pass  # 50+ lines

@router.get("/health")
async def health_check(): pass  # 30+ lines
```

**After** (Modular Routes):

```python
# routes/users.py (80 lines)
@router.get("/")
async def get_users(): pass

# routes/health.py (60 lines)
@router.get("/")
async def health_check(): pass
```

### Extract Configuration Modules

**Before** (Single Config File):

```python
# config.py (200+ lines)
class Config:
    # Database config (50+ lines)
    # Cache config (50+ lines)
    # Auth config (50+ lines)
```

**After** (Category-Specific Configs):

```python
# config/database.py (40 lines)
class DatabaseConfig:
    DATABASE_URL = "sqlite:///./app.db"
    POOL_SIZE = 5

# config/__init__.py (25 lines)
class Config:
    database = DatabaseConfig()
    cache = CacheConfig()
    auth = AuthConfig()
```

## Python-Specific Patterns

### Context Managers

```python
# utils/context_managers.py
from contextlib import asynccontextmanager

@asynccontextmanager
async def database_connection(service: DatabaseService):
    """Context manager for database connections"""
    connection = await service.get_connection()
    try:
        yield connection
    finally:
        await service.release_connection(connection)
```

### Dependency Injection

```python
# dependencies.py
from fastapi import Depends, HTTPException, status

def get_database_service() -> DatabaseService:
    """Dependency to get database service"""
    if database_service is None:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Database service not available"
        )
    return database_service
```

## Testing Patterns

### Unit Testing Services

```python
# tests/test_database_service.py
@pytest.fixture
async def database_service():
    service = DatabaseService()
    await service.initialize()
    yield service
    await service.close()

@pytest.mark.asyncio
async def test_database_initialization(database_service):
    """Test database service initialization"""
    assert database_service.is_initialized
    assert database_service.connection_pool is not None
```

### Integration Testing

```python
# tests/test_integration.py
@pytest.fixture
def client():
    return TestClient(app)

def test_health_endpoint(client):
    """Test health check endpoint"""
    response = client.get("/api/health")
    assert response.status_code == 200
    assert response.json()["status"] == "healthy"
```

## File Organization

```text
backend/
├── main.py                 # FastAPI app (90 lines)
├── config.py              # Configuration (50 lines)
├── services/
│   ├── __init__.py        # Service exports (10 lines)
│   ├── database.py        # Database service (95 lines)
│   └── cache.py           # Cache service (85 lines)
├── routes/
│   ├── __init__.py        # Route exports (15 lines)
│   ├── health.py          # Health endpoints (60 lines)
│   └── users.py           # User endpoints (80 lines)
├── auth/
│   ├── token_manager.py   # Token management (85 lines)
│   └── password_manager.py # Password handling (70 lines)
└── utils/
    ├── lazy_loader.py     # Lazy loading (80 lines)
    └── context_managers.py # Context managers (70 lines)
```

## Naming Conventions

- **Modules**: `snake_case.py` (e.g., `database_service.py`)
- **Classes**: `PascalCase` (e.g., `DatabaseService`)
- **Functions**: `snake_case` (e.g., `get_connection`)
- **Constants**: `UPPER_SNAKE_CASE` (e.g., `DEFAULT_TIMEOUT`)
- **Private methods**: `_snake_case` (e.g., `_validate_config`)

## Migration Strategy

### Phase 1: Identify Monoliths

1. Scan for files > 100 lines
2. Identify mixed concerns in classes
3. Map service dependencies

### Phase 2: Extract Services

1. Start with pure utility functions
2. Extract service classes with clear interfaces
3. Implement dependency injection

### Phase 3: Refactor Routes

1. Break down large route files
2. Extract business logic to services
3. Implement proper error handling

### Phase 4: Optimize Performance

1. Implement lazy loading for heavy dependencies
2. Add caching layers
3. Optimize database connections

## Key Benefits

- **Maintainable**: Easy to understand and modify
- **Testable**: Small, focused units that can be thoroughly tested
- **Reusable**: Self-contained modules that can be shared across projects
- **Scalable**: Architecture that grows with your application
- **Performant**: Optimized loading and memory management

*Every line of Python code is a liability. Make each line count by keeping it focused, clear, and purposeful.*

## Reference Files

For detailed implementations and advanced patterns, see:

- `py/examples/service-patterns.md` - Complete service implementations
- `py/examples/testing-patterns.md` - Comprehensive testing examples
- `py/examples/performance-optimization.md` - Memory and performance patterns
