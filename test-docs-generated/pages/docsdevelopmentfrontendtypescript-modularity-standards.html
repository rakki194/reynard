<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TypeScript Modularity Standards and Type Safety - Reynard Documentation Test</title>
  <link rel="stylesheet" href="../styles.css">
  <link rel="stylesheet" href="../highlight.css">
  <link rel="icon" href="/favicon.ico">
</head>
<body>
  <nav class="docs-nav">
    <div class="nav-brand"><a href="../index.html">Reynard Documentation Test</a></div>
    <div class="nav-links"><a href="../index.html">Home</a><a href="../api.html">API Reference</a></div>
  </nav>
  <main class="docs-main">
    <div class="docs-content">
      <h1>TypeScript Modularity Standards and Type Safety</h1>
      <div class="markdown-content"><h1>TypeScript Modularity Standards and Type Safety</h1>
<h2>Overview</h2>
<p>This document outlines the comprehensive approach to maintaining modularity standards and type safety in the Reynard framework&#39;s TypeScript codebase. It covers the resolution of common issues including function length violations, type safety problems, and proper AbortSignal handling.</p>
<h2>Table of Contents</h2>
<ol>
<li><a href="#the-100-line-axiom">The 100-Line Axiom</a></li>
<li><a href="#modular-refactoring-strategies">Modular Refactoring Strategies</a></li>
<li><a href="#type-safety-best-practices">Type Safety Best Practices</a></li>
<li><a href="#abortsignal-type-handling">AbortSignal Type Handling</a></li>
<li><a href="#common-issues-and-solutions">Common Issues and Solutions</a></li>
<li><a href="#implementation-examples">Implementation Examples</a></li>
</ol>
<h2>The 140-Line Axiom</h2>
<h3>Core Principle</h3>
<p>Every source file should be under 140 lines (excluding blank lines and comments). This constraint forces:</p>
<ul>
<li><strong>Clear Separation of Concerns</strong>: Each file has a single, well-defined responsibility</li>
<li><strong>Improved Readability</strong>: Files are small enough to understand at a glance</li>
<li><strong>Better Testability</strong>: Smaller modules are easier to test comprehensively</li>
<li><strong>Enhanced Maintainability</strong>: Changes are localized and predictable</li>
</ul>
<h3>Enforcement</h3>
<p>The 140-line limit is enforced through ESLint rules and code review processes. When violations occur, the code must be refactored using the modular patterns outlined in this document. This standard is established in <a href="../architecture/decisions/001-modularity-standards.md">ADR-001: Modularity Standards</a>.</p>
<h2>Modular Refactoring Strategies</h2>
<h3>Strategy 1: Extract by Functionality</h3>
<p><strong>Problem</strong>: Monolithic functions exceeding 100 lines with mixed responsibilities.</p>
<p><strong>Solution</strong>: Break down large functions into focused, single-responsibility modules.</p>
<h4>Example: RAG Client Refactoring</h4>
<p><strong>Before</strong> (172 lines - violates 140-line axiom):</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createRAGClient</span>(<span class="hljs-params"><span class="hljs-attr">options</span>: <span class="hljs-title class_">RAGClientOptions</span></span>) {
  <span class="hljs-comment">// 172 lines of mixed query, ingest, config, and admin functionality</span>
}</code></pre><p><strong>After</strong> (Modular approach):</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// rag-query.ts (33 lines)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createRAGQueryClient</span>(<span class="hljs-params">authFetch, queryUrl</span>) {
  <span class="hljs-comment">// Focused query functionality</span>
}

<span class="hljs-comment">// rag-ingest.ts (77 lines)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createRAGIngestClient</span>(<span class="hljs-params">authFetch, ingestUrl</span>) {
  <span class="hljs-comment">// Focused ingestion functionality</span>
}

<span class="hljs-comment">// rag-config.ts (74 lines)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createRAGConfigClient</span>(<span class="hljs-params">authFetch, configUrl</span>) {
  <span class="hljs-comment">// Focused configuration management</span>
}

<span class="hljs-comment">// rag-client.ts (39 lines) - Orchestrator</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createRAGClient</span>(<span class="hljs-params"><span class="hljs-attr">options</span>: <span class="hljs-title class_">RAGClientOptions</span></span>) {
  <span class="hljs-comment">// Composes specialized clients</span>
}</code></pre><h3>Strategy 2: Extract by Layer</h3>
<p><strong>Problem</strong>: Mixed concerns within a single module.</p>
<p><strong>Solution</strong>: Separate concerns into distinct layers with clear interfaces.</p>
<h4>Example: Type Definitions</h4>
<p><strong>Before</strong> (Mixed with implementation):</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// useRAG.ts (263 lines)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RAGConfig</span> {
  <span class="hljs-comment">/* 50+ lines of types */</span>
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useRAG</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">/* implementation */</span>
}</code></pre><p><strong>After</strong> (Separated concerns):</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// rag-types.ts (141 lines) - Pure type definitions</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RAGConfig</span> {
  <span class="hljs-comment">/* all type definitions */</span>
}

<span class="hljs-comment">// useRAG.ts (55 lines) - Implementation only</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useRAG</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">/* focused implementation */</span>
}</code></pre><h3>Strategy 3: Factory Pattern Implementation</h3>
<p><strong>Pattern</strong>: Use factory functions for clean module instantiation.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createRAGQueryClient</span>(<span class="hljs-params">
  <span class="hljs-attr">authFetch</span>: <span class="hljs-title class_">RAGClientOptions</span>[<span class="hljs-string">&quot;authFetch&quot;</span>],
  <span class="hljs-attr">queryUrl</span>: <span class="hljs-built_in">string</span>,
</span>) {
  <span class="hljs-keyword">const</span> query = <span class="hljs-keyword">async</span> &lt;<span class="hljs-title class_">TExtra</span> = <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">unknown</span>&gt;&gt;(
    <span class="hljs-attr">params</span>: <span class="hljs-title class_">RAGQueryParams</span>,
    <span class="hljs-attr">signal</span>?: globalThis.<span class="hljs-property">AbortSignal</span>,
  ): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">RAGQueryResponse</span>&lt;<span class="hljs-title class_">TExtra</span>&gt;&gt; =&gt; {
    <span class="hljs-comment">// Implementation</span>
  };

  <span class="hljs-keyword">return</span> { query };
}</code></pre><h2>Type Safety Best Practices</h2>
<h3>1. Avoid <code>any</code> Types</h3>
<p><strong>Problem</strong>: Using <code>any</code> undermines TypeScript&#39;s type safety.</p>
<p><strong>Solution</strong>: Use specific types or <code>unknown</code> with proper type guards.</p>
<h4>Bad Practice</h4>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">processData</span>(<span class="hljs-params"><span class="hljs-attr">data</span>: <span class="hljs-built_in">any</span></span>) {
  <span class="hljs-keyword">return</span> data.<span class="hljs-property">someProperty</span>; <span class="hljs-comment">// No type safety</span>
}</code></pre><h4>Good Practice</h4>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">processData</span>(<span class="hljs-params"><span class="hljs-attr">data</span>: <span class="hljs-built_in">unknown</span></span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&quot;object&quot;</span> &amp;&amp; data !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-string">&quot;someProperty&quot;</span> <span class="hljs-keyword">in</span> data) {
    <span class="hljs-keyword">return</span> (data <span class="hljs-keyword">as</span> { <span class="hljs-attr">someProperty</span>: <span class="hljs-built_in">string</span> }).<span class="hljs-property">someProperty</span>;
  }
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Invalid data structure&quot;</span>);
}</code></pre><h3>2. Proper Generic Type Constraints</h3>
<p><strong>Problem</strong>: Unconstrained generics can lead to type errors.</p>
<p><strong>Solution</strong>: Use proper type constraints and defaults.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Good: Constrained generic with default</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RAGQueryHit</span>&lt;<span class="hljs-title class_">TExtra</span> = <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">unknown</span>&gt;&gt; {
  <span class="hljs-attr">id</span>?: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">score</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">extra</span>?: <span class="hljs-title class_">TExtra</span>;
}

<span class="hljs-comment">// Usage</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">hit</span>: <span class="hljs-title class_">RAGQueryHit</span>&lt;{ <span class="hljs-attr">source</span>: <span class="hljs-built_in">string</span> }&gt; = {
  <span class="hljs-attr">score</span>: <span class="hljs-number">0.95</span>,
  <span class="hljs-attr">extra</span>: { <span class="hljs-attr">source</span>: <span class="hljs-string">&quot;document.pdf&quot;</span> },
};</code></pre><h3>3. Interface-First Design</h3>
<p><strong>Pattern</strong>: Define clear contracts before implementation.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RAGClientOptions</span> {
  <span class="hljs-attr">authFetch</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">input</span>: <span class="hljs-built_in">string</span> | URL, <span class="hljs-attr">init</span>?: <span class="hljs-title class_">RequestInit</span></span>) =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Response</span>&gt;;
  <span class="hljs-attr">configUrl</span>?: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">queryUrl</span>?: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">ingestUrl</span>?: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">adminUrl</span>?: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">metricsUrl</span>?: <span class="hljs-built_in">string</span>;
}</code></pre><h2>AbortSignal Type Handling</h2>
<h3>The Problem</h3>
<p>TypeScript environments may not properly recognize the built-in <code>AbortSignal</code> type, leading to compilation errors:</p>
<pre><code class="hljs"><span class="hljs-string">&#x27;AbortSignal&#x27;</span> <span class="hljs-literal">is</span><span class="hljs-built_in"> not</span> defined.</code></pre><h3>The Solution (2025 Best Practice)</h3>
<p>Use <code>globalThis.AbortSignal</code> to explicitly reference the global AbortSignal interface:</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Correct approach</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createRAGQueryClient</span>(<span class="hljs-params">
  <span class="hljs-attr">authFetch</span>: <span class="hljs-title class_">RAGClientOptions</span>[<span class="hljs-string">&quot;authFetch&quot;</span>],
  <span class="hljs-attr">queryUrl</span>: <span class="hljs-built_in">string</span>,
</span>) {
  <span class="hljs-keyword">const</span> query = <span class="hljs-keyword">async</span> &lt;<span class="hljs-title class_">TExtra</span> = <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">unknown</span>&gt;&gt;(
    <span class="hljs-attr">params</span>: <span class="hljs-title class_">RAGQueryParams</span>,
    <span class="hljs-attr">signal</span>?: globalThis.<span class="hljs-property">AbortSignal</span>, <span class="hljs-comment">// Proper type reference</span>
  ): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">RAGQueryResponse</span>&lt;<span class="hljs-title class_">TExtra</span>&gt;&gt; =&gt; {
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">authFetch</span>(queryUrl, {
      <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span>,
      <span class="hljs-attr">headers</span>: { <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span> },
      <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(payload),
      signal, <span class="hljs-comment">// No type casting needed</span>
    });

    <span class="hljs-keyword">if</span> (!res.<span class="hljs-property">ok</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`RAG query failed (<span class="hljs-subst">${res.status}</span>)`</span>);
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>()) <span class="hljs-keyword">as</span> <span class="hljs-title class_">RAGQueryResponse</span>&lt;<span class="hljs-title class_">TExtra</span>&gt;;
  };

  <span class="hljs-keyword">return</span> { query };
}</code></pre><h3>Why This Works</h3>
<ol>
<li><strong>Global Scope Access</strong>: <code>globalThis.AbortSignal</code> explicitly references the global AbortSignal interface</li>
<li><strong>DOM Library Integration</strong>: Works seamlessly with the DOM library included in tsconfig</li>
<li><strong>Type Safety</strong>: Maintains full type safety without any <code>any</code> types</li>
<li><strong>Future-Proof</strong>: This is the recommended approach for 2025 and beyond</li>
</ol>
<h3>Alternative Approaches (Not Recommended)</h3>
<h4>❌ Using <code>any</code> Types</h4>
<pre><code class="hljs language-typescript"><span class="hljs-attr">signal</span>?: <span class="hljs-built_in">any</span>  <span class="hljs-comment">// Loses type safety</span></code></pre><h4>❌ Custom Type Definitions</h4>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">AbortControllerSignal</span> = {
  <span class="hljs-attr">aborted</span>: <span class="hljs-built_in">boolean</span>;
  <span class="hljs-attr">addEventListener</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">type</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">listener</span>: () =&gt; <span class="hljs-built_in">void</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  <span class="hljs-attr">removeEventListener</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">type</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">listener</span>: () =&gt; <span class="hljs-built_in">void</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
};</code></pre><h4>❌ Type Casting</h4>
<pre><code class="hljs language-typescript"><span class="hljs-attr">signal</span>: signal <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>; <span class="hljs-comment">// Bypasses type checking</span></code></pre><h2>Common Issues and Solutions</h2>
<h3>Issue 1: Function Too Many Lines</h3>
<p><strong>Error</strong>: <code>Function &#39;createRAGClient&#39; has too many lines (172). Maximum allowed is 140.</code></p>
<p><strong>Solution</strong>: Apply modular refactoring strategies:</p>
<ol>
<li>Extract functionality into separate modules</li>
<li>Use factory patterns for composition</li>
<li>Separate types from implementation</li>
<li>Create focused, single-responsibility functions</li>
</ol>
<h3>Issue 2: Type Safety Violations</h3>
<p><strong>Error</strong>: <code>Unexpected any. Specify a different type.</code></p>
<p><strong>Solution</strong>:</p>
<ol>
<li>Replace <code>any</code> with <code>unknown</code> and add type guards</li>
<li>Use proper generic constraints</li>
<li>Define specific interfaces for all data structures</li>
<li>Use <code>globalThis.AbortSignal</code> for AbortSignal types</li>
</ol>
<h3>Issue 3: Missing Type Definitions</h3>
<p><strong>Error</strong>: <code>&#39;RequestInfo&#39; is not defined.</code></p>
<p><strong>Solution</strong>: Ensure DOM library is included in tsconfig.json:</p>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;lib&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ES2022&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;DOM&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;DOM.Iterable&quot;</span><span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span></code></pre><h3>Issue 4: Unused Imports</h3>
<p><strong>Error</strong>: <code>&#39;createSignal&#39; is defined but never used.</code></p>
<p><strong>Solution</strong>: Remove unused imports and clean up dependencies:</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Before</span>
<span class="hljs-keyword">import</span> {
  <span class="hljs-title class_">Accessor</span>,
  createResource,
  createSignal,
  createEffect,
  onCleanup,
} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;solid-js&quot;</span>;

<span class="hljs-comment">// After</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Accessor</span>, createResource } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;solid-js&quot;</span>;</code></pre><h2>Implementation Examples</h2>
<h3>Complete Modular RAG Implementation</h3>
<p>The following example demonstrates the complete modular approach applied to the RAG system:</p>
<h4>File Structure</h4>
<pre><code class="hljs">packages/composables/<span class="hljs-attribute">src</span>/ai/
├── rag-types<span class="hljs-selector-class">.ts</span>          (<span class="hljs-number">141</span> lines) - All type definitions
├── rag-query<span class="hljs-selector-class">.ts</span>          (<span class="hljs-number">33</span> lines)  - Query functionality
├── rag-ingest<span class="hljs-selector-class">.ts</span>         (<span class="hljs-number">77</span> lines)  - Document ingestion
├── rag-config<span class="hljs-selector-class">.ts</span>         (<span class="hljs-number">74</span> lines)  - Configuration management
├── rag-admin<span class="hljs-selector-class">.ts</span>          (<span class="hljs-number">67</span> lines)  - Administrative operations
├── rag-search-resource<span class="hljs-selector-class">.ts</span> (<span class="hljs-number">64</span> lines) - Reactive search resources
├── rag-auto-refresh<span class="hljs-selector-class">.ts</span>   (<span class="hljs-number">49</span> lines)  - Auto-refresh functionality
├── rag-client<span class="hljs-selector-class">.ts</span>         (<span class="hljs-number">39</span> lines)  - Main orchestrator
├── useRAG<span class="hljs-selector-class">.ts</span>            (<span class="hljs-number">55</span> lines)  - SolidJS composable
└── rag<span class="hljs-selector-class">.ts</span>               (<span class="hljs-number">10</span> lines)  - Barrel exports</code></pre><h4>Key Benefits Achieved</h4>
<ol>
<li><strong>Maintainability</strong>: Each module has a single, clear responsibility</li>
<li><strong>Testability</strong>: Small, focused units that can be thoroughly tested</li>
<li><strong>Reusability</strong>: Modules can be imported and used independently</li>
<li><strong>Scalability</strong>: Easy to extend or modify individual components</li>
<li><strong>Type Safety</strong>: Comprehensive TypeScript interfaces with proper typing</li>
</ol>
<h3>Barrel Export Pattern</h3>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// rag.ts - Clean API boundaries</span>
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./rag-types&quot;</span>;
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./useRAG&quot;</span>;
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./rag-client&quot;</span>;
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./rag-query&quot;</span>;
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./rag-ingest&quot;</span>;
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./rag-config&quot;</span>;
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./rag-admin&quot;</span>;
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./rag-search-resource&quot;</span>;
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./rag-auto-refresh&quot;</span>;</code></pre><h3>Factory Pattern Usage</h3>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Main client composition</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createRAGClient</span>(<span class="hljs-params"><span class="hljs-attr">options</span>: <span class="hljs-title class_">RAGClientOptions</span></span>) {
  <span class="hljs-keyword">const</span> {
    authFetch,
    configUrl = <span class="hljs-string">&quot;/api/config&quot;</span>,
    queryUrl = <span class="hljs-string">&quot;/api/rag/query&quot;</span>,
    ingestUrl = <span class="hljs-string">&quot;/api/rag/ingest&quot;</span>,
    adminUrl = <span class="hljs-string">&quot;/api/rag/admin&quot;</span>,
    metricsUrl = <span class="hljs-string">&quot;/api/rag/ops/metrics&quot;</span>,
  } = options;

  <span class="hljs-comment">// Create specialized clients</span>
  <span class="hljs-keyword">const</span> queryClient = <span class="hljs-title function_">createRAGQueryClient</span>(authFetch, queryUrl);
  <span class="hljs-keyword">const</span> ingestClient = <span class="hljs-title function_">createRAGIngestClient</span>(authFetch, ingestUrl);
  <span class="hljs-keyword">const</span> configClient = <span class="hljs-title function_">createRAGConfigClient</span>(authFetch, configUrl);
  <span class="hljs-keyword">const</span> adminClient = <span class="hljs-title function_">createRAGAdminClient</span>(authFetch, adminUrl, metricsUrl);

  <span class="hljs-comment">// Compose the full client interface</span>
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">query</span>: queryClient.<span class="hljs-property">query</span>,
    <span class="hljs-attr">ingestDocuments</span>: ingestClient.<span class="hljs-property">ingestDocuments</span>,
    <span class="hljs-attr">getConfig</span>: configClient.<span class="hljs-property">getConfig</span>,
    <span class="hljs-attr">updateConfig</span>: configClient.<span class="hljs-property">updateConfig</span>,
    <span class="hljs-attr">getIndexingStatus</span>: adminClient.<span class="hljs-property">getIndexingStatus</span>,
    <span class="hljs-attr">getMetrics</span>: adminClient.<span class="hljs-property">getMetrics</span>,
    <span class="hljs-attr">admin</span>: adminClient.<span class="hljs-property">admin</span>,
  };
}</code></pre><h2>Conclusion</h2>
<p>The modular approach to TypeScript development in the Reynard framework ensures:</p>
<ul>
<li><strong>Code Quality</strong>: All modules adhere to the 140-line axiom established in <a href="../architecture/decisions/001-modularity-standards.md">ADR-001</a></li>
<li><strong>Type Safety</strong>: Proper TypeScript usage with no <code>any</code> types</li>
<li><strong>Maintainability</strong>: Clear separation of concerns and focused responsibilities</li>
<li><strong>Scalability</strong>: Easy to extend and modify individual components</li>
<li><strong>Best Practices</strong>: Following 2025 TypeScript standards and patterns</li>
</ul>
<p>By applying these standards consistently across the codebase, we maintain a high-quality, maintainable, and scalable TypeScript architecture that serves as a foundation for the entire Reynard framework.</p>
<h2>References</h2>
<ul>
<li><a href="../architecture/decisions/001-modularity-standards.md">ADR-001: Modularity Standards</a> - Establishes the 140-line axiom</li>
<li><a href="../architecture/decisions/002-typescript-modularity-refactoring.md">ADR-002: TypeScript Modularity Refactoring</a> - TypeScript-specific implementation</li>
<li><a href="https://www.typescriptlang.org/docs/">TypeScript Official Documentation</a></li>
<li><a href="https://typescript-eslint.io/rules/">ESLint TypeScript Rules</a></li>
<li><a href="https://developer.mozilla.org/docs/Web/API/AbortSignal">MDN AbortSignal Documentation</a></li>
<li><a href="../architecture/modularity-patterns.md">Reynard Modular Manifesto</a></li>
</ul>
</div>
    </div>
  </main>
  <footer class="docs-footer"><p>&copy; 2024 Reynard Documentation Test. Built with ❤️ using SolidJS.</p></footer>
</body>
</html>