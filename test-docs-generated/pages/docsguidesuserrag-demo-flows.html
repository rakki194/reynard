<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RAG Demo Flows - Reynard Documentation Test</title>
  <link rel="stylesheet" href="../styles.css">
  <link rel="stylesheet" href="../highlight.css">
  <link rel="icon" href="/favicon.ico">
</head>
<body>
  <nav class="docs-nav">
    <div class="nav-brand"><a href="../index.html">Reynard Documentation Test</a></div>
    <div class="nav-links"><a href="../index.html">Home</a><a href="../api.html">API Reference</a></div>
  </nav>
  <main class="docs-main">
    <div class="docs-content">
      <h1>RAG Demo Flows</h1>
      <div class="markdown-content"><h1>RAG Demo Flows</h1>
<p>This document provides a practical ingest walkthrough and a concise hybrid ranking explanation. Query screenshots are pending and will be added once the final search UI is captured.</p>
<h2>Ingest Walkthrough (Streaming NDJSON)</h2>
<p>RAG ingestion accepts a compact payload and streams NDJSON events so the UI can present progress in real time. The backend enforces per‑user rate limits, request clamps, and optional privacy redaction.</p>
<p>To ingest a small document set using cURL, provide <code>items</code> and a text embedding <code>model</code>:</p>
<pre><code class="hljs language-bash">curl -N -s \
  -H <span class="hljs-string">&#x27;Content-Type: application/json&#x27;</span> \
  -X POST http://localhost:7001/api/rag/ingest \
  -d <span class="hljs-string">&#x27;{&quot;items&quot;:[{&quot;source&quot;:&quot;manual&quot;,&quot;content&quot;:&quot;The quick brown fox jumps over the lazy dog.&quot;}],&quot;model&quot;:&quot;mxbai-embed-large&quot;}&#x27;</span></code></pre><p>The response streams newline‑delimited objects like <code>{ &quot;type&quot;: &quot;enqueued&quot;, &quot;scheduled&quot;: 1, &quot;total&quot;: 1 }</code>, <code>{ &quot;type&quot;: &quot;accepted&quot;, &quot;total&quot;: 1 }</code>, and errors if any occur. The frontend client in <code>src/composables/useRAG.ts</code> parses these chunks and forwards structured events to the caller.</p>
<p>To wire this into the SolidJS UI with grouped notifications:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { useAppContext } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;~/contexts/app&quot;</span>;
<span class="hljs-keyword">import</span> { useRAG } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;~/composables/useRAG&quot;</span>;

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">useAppContext</span>();
<span class="hljs-keyword">const</span> rag = <span class="hljs-title function_">useRAG</span>();

<span class="hljs-keyword">const</span> group = <span class="hljs-string">&quot;rag-ingest&quot;</span>;
app.<span class="hljs-title function_">notify</span>(<span class="hljs-string">&quot;Starting ingest…&quot;</span>, <span class="hljs-string">&quot;info&quot;</span>, group, <span class="hljs-string">&quot;spinner&quot;</span>, <span class="hljs-number">0</span>);
<span class="hljs-keyword">await</span> rag.<span class="hljs-title function_">ingestDocuments</span>(
  [{ <span class="hljs-attr">source</span>: <span class="hljs-string">&quot;manual&quot;</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">&quot;The quick brown fox…&quot;</span> }],
  <span class="hljs-string">&quot;mxbai-embed-large&quot;</span>,
  <span class="hljs-function">(<span class="hljs-params">evt</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> processed = evt.<span class="hljs-property">processed</span> ?? <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> total = evt.<span class="hljs-property">total</span> ?? <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> percent =
      total &gt; <span class="hljs-number">0</span> ? <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>((processed / total) * <span class="hljs-number">100</span>) : <span class="hljs-literal">undefined</span>;
    app.<span class="hljs-title function_">notify</span>(
      <span class="hljs-string">`Ingest <span class="hljs-subst">${processed}</span>/<span class="hljs-subst">${total}</span>`</span>,
      <span class="hljs-string">&quot;info&quot;</span>,
      group,
      <span class="hljs-string">&quot;spinner&quot;</span>,
      percent,
    );
    <span class="hljs-keyword">if</span> (evt.<span class="hljs-property">type</span> === <span class="hljs-string">&quot;error&quot;</span>)
      app.<span class="hljs-title function_">notify</span>(evt.<span class="hljs-property">error</span> || <span class="hljs-string">&quot;Ingest error&quot;</span>, <span class="hljs-string">&quot;error&quot;</span>, group);
  },
);
app.<span class="hljs-title function_">notify</span>(<span class="hljs-string">&quot;Ingest complete&quot;</span>, <span class="hljs-string">&quot;success&quot;</span>, group);</code></pre><h2>Hybrid Ranking Explanation</h2>
<p>For text, code, and captions, hybrid ranking combines vector similarity from pgvector with a textual ranking signal. Scores are normalized per modality and combined as ( score = w*{vec} \cdot (1 - dist) + w*{text} \cdot rank ). In the current implementation, the text term is a placeholder set to zero while preserving the interface, and vector similarity dominates. The default weights favor vector similarity (docs/code <code>w_vec=0.7</code>, <code>w_text=0.3</code>; captions <code>0.8/0.2</code>). These weights are configurable in <code>AppConfig</code> and can be tuned per deployment without changing API contracts.</p>
<p>Vector similarity uses cosine distance and returns a normalized score in ([0,1]). HNSW indexes accelerate nearest‑neighbor search; recall and latency can be traded by setting <code>hnsw.ef_search</code> at session time. When textual ranking (e.g., BM25 or <code>ts_rank</code>) is introduced, the API shape will remain compatible and weights will blend both signals coherently.</p>
<p>For images, CLIP text→image retrieval computes cosine similarity in the CLIP space and returns hits with scores. The image embedding table uses <code>VECTOR(768)</code> by default (ViT‑L/14), and the text tower or a mapped text embedding is used for compatibility.</p>
<h2>Notes</h2>
<p>Ensure RAG is enabled and the Postgres DSN is provided (<code>RAG_ENABLED=true</code>, <code>PG_DSN=…</code>). See <code>docs/rag.md</code> for architecture, schema, and endpoint details, and <code>docs/notifications.md</code> for progress notification patterns.</p>
</div>
    </div>
  </main>
  <footer class="docs-footer"><p>&copy; 2024 Reynard Documentation Test. Built with ❤️ using SolidJS.</p></footer>
</body>
</html>