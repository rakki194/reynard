<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ü¶ä Reynard Modularity Patterns - Reynard Documentation Test</title>
  <link rel="stylesheet" href="../styles.css">
  <link rel="stylesheet" href="../highlight.css">
  <link rel="icon" href="/favicon.ico">
</head>
<body>
  <nav class="docs-nav">
    <div class="nav-brand"><a href="../index.html">Reynard Documentation Test</a></div>
    <div class="nav-links"><a href="../index.html">Home</a><a href="../api.html">API Reference</a></div>
  </nav>
  <main class="docs-main">
    <div class="docs-content">
      <h1>ü¶ä Reynard Modularity Patterns</h1>
      <div class="markdown-content"><h1>ü¶ä Reynard Modularity Patterns</h1>
<p><em>Strategic architecture patterns for maintainable, scalable code</em></p>
<h2>Overview</h2>
<p>Reynard follows the <strong>140-line axiom</strong> - a strategic approach to code organization that emphasizes modularity, maintainability, and clarity. This document outlines the proven patterns and refactoring strategies used throughout the Reynard codebase.</p>
<h2>Core Principles</h2>
<h3>The 140-Line Axiom</h3>
<p>Every source file should be under 140 lines (excluding blank lines and comments). This constraint forces:</p>
<ul>
<li><strong>Clear Separation of Concerns</strong>: Each file has a single, well-defined responsibility</li>
<li><strong>Improved Readability</strong>: Files are small enough to understand at a glance</li>
<li><strong>Better Testability</strong>: Smaller modules are easier to test comprehensively</li>
<li><strong>Enhanced Maintainability</strong>: Changes are localized and predictable</li>
</ul>
<h3>Modularity Standards</h3>
<table>
<thead>
<tr>
<th>File Type</th>
<th>Max Lines</th>
<th>Max Function Lines</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td>Source Files</td>
<td>140</td>
<td>50</td>
<td>Core business logic</td>
</tr>
<tr>
<td>Test Files</td>
<td>200</td>
<td>100</td>
<td>Comprehensive testing</td>
</tr>
<tr>
<td>Configuration</td>
<td>50</td>
<td>25</td>
<td>Setup and configuration</td>
</tr>
<tr>
<td>Documentation</td>
<td>200</td>
<td>N/A</td>
<td>Guides and references</td>
</tr>
</tbody></table>
<h2>Proven Refactoring Patterns</h2>
<h3>1. Factory Pattern</h3>
<p><strong>Use Case</strong>: When a single class handles multiple types or variants</p>
<p><strong>Before</strong> (631 lines):</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// geometry.ts - Monolithic geometry operations</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GeometryOps</span> {
  <span class="hljs-comment">// Point operations</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">createPoint</span>(<span class="hljs-params"><span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span></span>) {
    <span class="hljs-comment">/* ... */</span>
  }
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">addPoints</span>(<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-title class_">Point</span>, <span class="hljs-attr">b</span>: <span class="hljs-title class_">Point</span></span>) {
    <span class="hljs-comment">/* ... */</span>
  }

  <span class="hljs-comment">// Vector operations</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">createVector</span>(<span class="hljs-params"><span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span></span>) {
    <span class="hljs-comment">/* ... */</span>
  }
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">dotProduct</span>(<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-title class_">Vector</span>, <span class="hljs-attr">b</span>: <span class="hljs-title class_">Vector</span></span>) {
    <span class="hljs-comment">/* ... */</span>
  }

  <span class="hljs-comment">// Line operations</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">createLine</span>(<span class="hljs-params"><span class="hljs-attr">start</span>: <span class="hljs-title class_">Point</span>, <span class="hljs-attr">end</span>: <span class="hljs-title class_">Point</span></span>) {
    <span class="hljs-comment">/* ... */</span>
  }
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">lineIntersection</span>(<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-title class_">Line</span>, <span class="hljs-attr">b</span>: <span class="hljs-title class_">Line</span></span>) {
    <span class="hljs-comment">/* ... */</span>
  }

  <span class="hljs-comment">// ... 600+ more lines</span>
}</code></pre><p><strong>After</strong> (Modular):</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// vector-algorithms.ts (150 lines)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PointOps</span> {
  <span class="hljs-comment">/* ... */</span>
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VectorOps</span> {
  <span class="hljs-comment">/* ... */</span>
}

<span class="hljs-comment">// collision-algorithms.ts (150 lines)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LineOps</span> {
  <span class="hljs-comment">/* ... */</span>
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RectangleOps</span> {
  <span class="hljs-comment">/* ... */</span>
}

<span class="hljs-comment">// transformation-algorithms.ts (150 lines)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransformOps</span> {
  <span class="hljs-comment">/* ... */</span>
}

<span class="hljs-comment">// geometry.ts (24 lines) - Orchestrator</span>
<span class="hljs-keyword">export</span> { <span class="hljs-title class_">PointOps</span>, <span class="hljs-title class_">VectorOps</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./vector-algorithms&quot;</span>;
<span class="hljs-keyword">export</span> { <span class="hljs-title class_">LineOps</span>, <span class="hljs-title class_">RectangleOps</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./collision-algorithms&quot;</span>;
<span class="hljs-keyword">export</span> { <span class="hljs-title class_">TransformOps</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./transformation-algorithms&quot;</span>;</code></pre><p><strong>Benefits</strong>:</p>
<ul>
<li>93% reduction in main file size</li>
<li>Specialized modules for different concerns</li>
<li>Easier to test and maintain</li>
<li>Clear import structure</li>
</ul>
<h3>2. Composable Pattern</h3>
<p><strong>Use Case</strong>: When a single composable handles multiple related concerns</p>
<p><strong>Before</strong> (980 lines):</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// useP2PChat.ts - Monolithic chat composable</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useP2PChat</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// WebSocket connection logic (200 lines)</span>
  <span class="hljs-comment">// Message handling (200 lines)</span>
  <span class="hljs-comment">// Room management (200 lines)</span>
  <span class="hljs-comment">// File upload (200 lines)</span>
  <span class="hljs-comment">// State management (180 lines)</span>
}</code></pre><p><strong>After</strong> (Modular):</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// useP2PConnection.ts (200 lines)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useP2PConnection</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">/* ... */</span>
}

<span class="hljs-comment">// useP2PMessages.ts (200 lines)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useP2PMessages</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">/* ... */</span>
}

<span class="hljs-comment">// useP2PRooms.ts (150 lines)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useP2PRooms</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">/* ... */</span>
}

<span class="hljs-comment">// useP2PFileUpload.ts (150 lines)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useP2PFileUpload</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">/* ... */</span>
}

<span class="hljs-comment">// useP2PChat.ts (370 lines) - Orchestrator</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useP2PChat</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> connection = <span class="hljs-title function_">useP2PConnection</span>();
  <span class="hljs-keyword">const</span> messages = <span class="hljs-title function_">useP2PMessages</span>();
  <span class="hljs-keyword">const</span> rooms = <span class="hljs-title function_">useP2PRooms</span>();
  <span class="hljs-keyword">const</span> fileUpload = <span class="hljs-title function_">useP2PFileUpload</span>();

  <span class="hljs-keyword">return</span> { connection, messages, rooms, fileUpload };
}</code></pre><p><strong>Benefits</strong>:</p>
<ul>
<li>62% reduction in main file size</li>
<li>Focused composables for specific concerns</li>
<li>Better reusability across components</li>
<li>Enhanced testability</li>
</ul>
<h3>3. Test Orchestrator Pattern</h3>
<p><strong>Use Case</strong>: When test files become too large and complex</p>
<p><strong>Before</strong> (775 lines):</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// i18n-core.test.ts - Monolithic test suite</span>
<span class="hljs-title function_">describe</span>(<span class="hljs-string">&quot;i18n-core&quot;</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title function_">describe</span>(<span class="hljs-string">&quot;core functionality&quot;</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">/* 200 lines */</span>
  });
  <span class="hljs-title function_">describe</span>(<span class="hljs-string">&quot;translation logic&quot;</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">/* 200 lines */</span>
  });
  <span class="hljs-title function_">describe</span>(<span class="hljs-string">&quot;pluralization&quot;</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">/* 200 lines */</span>
  });
  <span class="hljs-title function_">describe</span>(<span class="hljs-string">&quot;integration tests&quot;</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">/* 175 lines */</span>
  });
});</code></pre><p><strong>After</strong> (Modular):</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// i18n-core.test.ts (150 lines)</span>
<span class="hljs-title function_">describe</span>(<span class="hljs-string">&quot;i18n-core&quot;</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">/* core functionality */</span>
});

<span class="hljs-comment">// i18n-translations.test.ts (150 lines)</span>
<span class="hljs-title function_">describe</span>(<span class="hljs-string">&quot;i18n-translations&quot;</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">/* translation logic */</span>
});

<span class="hljs-comment">// i18n-pluralization.test.ts (150 lines)</span>
<span class="hljs-title function_">describe</span>(<span class="hljs-string">&quot;i18n-pluralization&quot;</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">/* pluralization */</span>
});

<span class="hljs-comment">// i18n-integration.test.ts (150 lines)</span>
<span class="hljs-title function_">describe</span>(<span class="hljs-string">&quot;i18n-integration&quot;</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">/* integration tests */</span>
});</code></pre><p><strong>Benefits</strong>:</p>
<ul>
<li>81% reduction in main test file size</li>
<li>Focused test suites for specific functionality</li>
<li>Better test organization and maintainability</li>
<li>Faster test execution with parallel runs</li>
</ul>
<h3>4. Category-Specific Modules Pattern</h3>
<p><strong>Use Case</strong>: When configuration files become too large</p>
<p><strong>Before</strong> (673 lines):</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// file-types.ts - Monolithic configuration</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">IMAGE_TYPES</span> = {
  <span class="hljs-comment">/* 100 lines */</span>
};
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">VIDEO_TYPES</span> = {
  <span class="hljs-comment">/* 100 lines */</span>
};
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">AUDIO_TYPES</span> = {
  <span class="hljs-comment">/* 100 lines */</span>
};
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DOCUMENT_TYPES</span> = {
  <span class="hljs-comment">/* 100 lines */</span>
};
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CODE_TYPES</span> = {
  <span class="hljs-comment">/* 100 lines */</span>
};
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TEXT_TYPES</span> = {
  <span class="hljs-comment">/* 100 lines */</span>
};
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ARCHIVE_TYPES</span> = {
  <span class="hljs-comment">/* 73 lines */</span>
};</code></pre><p><strong>After</strong> (Modular):</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// image-types.ts (150 lines)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">IMAGE_TYPES</span> = {
  <span class="hljs-comment">/* ... */</span>
};

<span class="hljs-comment">// video-types.ts (150 lines)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">VIDEO_TYPES</span> = {
  <span class="hljs-comment">/* ... */</span>
};

<span class="hljs-comment">// audio-types.ts (100 lines)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">AUDIO_TYPES</span> = {
  <span class="hljs-comment">/* ... */</span>
};

<span class="hljs-comment">// document-types.ts (150 lines)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DOCUMENT_TYPES</span> = {
  <span class="hljs-comment">/* ... */</span>
};

<span class="hljs-comment">// code-types.ts (100 lines)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CODE_TYPES</span> = {
  <span class="hljs-comment">/* ... */</span>
};

<span class="hljs-comment">// text-types.ts (100 lines)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TEXT_TYPES</span> = {
  <span class="hljs-comment">/* ... */</span>
};

<span class="hljs-comment">// archive-types.ts (100 lines)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ARCHIVE_TYPES</span> = {
  <span class="hljs-comment">/* ... */</span>
};

<span class="hljs-comment">// file-types.ts (50 lines) - Aggregator</span>
<span class="hljs-keyword">export</span> { <span class="hljs-variable constant_">IMAGE_TYPES</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./image-types&quot;</span>;
<span class="hljs-keyword">export</span> { <span class="hljs-variable constant_">VIDEO_TYPES</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./video-types&quot;</span>;
<span class="hljs-comment">// ... other exports</span></code></pre><p><strong>Benefits</strong>:</p>
<ul>
<li>93% reduction in main config file size</li>
<li>Category-specific modules for different file types</li>
<li>Easier to maintain and extend</li>
<li>Clear separation of concerns</li>
</ul>
<h2>Refactoring Guidelines</h2>
<h3>Step-by-Step Refactoring Process</h3>
<ol>
<li><p><strong>Analyze the Current File</strong></p>
<ul>
<li>Identify distinct responsibilities</li>
<li>Look for natural boundaries</li>
<li>Count lines and functions</li>
</ul>
</li>
<li><p><strong>Plan the Split</strong></p>
<ul>
<li>Determine module boundaries</li>
<li>Design the orchestrator pattern</li>
<li>Plan import/export structure</li>
</ul>
</li>
<li><p><strong>Create Specialized Modules</strong></p>
<ul>
<li>Extract related functionality</li>
<li>Maintain single responsibility</li>
<li>Keep modules under 150 lines</li>
</ul>
</li>
<li><p><strong>Create the Orchestrator</strong></p>
<ul>
<li>Re-export from specialized modules</li>
<li>Maintain backward compatibility</li>
<li>Keep orchestrator under 140 lines</li>
</ul>
</li>
<li><p><strong>Update Tests</strong></p>
<ul>
<li>Split test files accordingly</li>
<li>Maintain test coverage</li>
<li>Update imports</li>
</ul>
</li>
<li><p><strong>Verify Functionality</strong></p>
<ul>
<li>Run all tests</li>
<li>Check for breaking changes</li>
<li>Update documentation</li>
</ul>
</li>
</ol>
<h3>Common Refactoring Strategies</h3>
<h4>Strategy 1: Extract by Functionality</h4>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Before: Single large class</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">FileProcessor</span> {
  <span class="hljs-title function_">processImage</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">/* ... */</span>
  }
  <span class="hljs-title function_">processVideo</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">/* ... */</span>
  }
  <span class="hljs-title function_">processAudio</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">/* ... */</span>
  }
  <span class="hljs-title function_">processDocument</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">/* ... */</span>
  }
}

<span class="hljs-comment">// After: Specialized processors</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageProcessor</span> {
  <span class="hljs-comment">/* ... */</span>
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">VideoProcessor</span> {
  <span class="hljs-comment">/* ... */</span>
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">AudioProcessor</span> {
  <span class="hljs-comment">/* ... */</span>
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">DocumentProcessor</span> {
  <span class="hljs-comment">/* ... */</span>
}</code></pre><h4>Strategy 2: Extract by Layer</h4>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Before: Mixed concerns</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
  <span class="hljs-title function_">validateUser</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">/* validation logic */</span>
  }
  <span class="hljs-title function_">hashPassword</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">/* security logic */</span>
  }
  <span class="hljs-title function_">saveUser</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">/* persistence logic */</span>
  }
  <span class="hljs-title function_">sendEmail</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">/* notification logic */</span>
  }
}

<span class="hljs-comment">// After: Separated concerns</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserValidator</span> {
  <span class="hljs-comment">/* ... */</span>
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">PasswordUtils</span> {
  <span class="hljs-comment">/* ... */</span>
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserRepository</span> {
  <span class="hljs-comment">/* ... */</span>
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">EmailService</span> {
  <span class="hljs-comment">/* ... */</span>
}</code></pre><h4>Strategy 3: Extract by Type</h4>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Before: Mixed types</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CONFIG</span> = {
  <span class="hljs-attr">imageTypes</span>: {
    <span class="hljs-comment">/* ... */</span>
  },
  <span class="hljs-attr">videoTypes</span>: {
    <span class="hljs-comment">/* ... */</span>
  },
  <span class="hljs-attr">audioTypes</span>: {
    <span class="hljs-comment">/* ... */</span>
  },
  <span class="hljs-attr">documentTypes</span>: {
    <span class="hljs-comment">/* ... */</span>
  },
};

<span class="hljs-comment">// After: Type-specific modules</span>
<span class="hljs-comment">// image-types.ts</span>
<span class="hljs-comment">// video-types.ts</span>
<span class="hljs-comment">// audio-types.ts</span>
<span class="hljs-comment">// document-types.ts</span></code></pre><h2>Enforcement Mechanisms</h2>
<h3>ESLint Rules</h3>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// eslint.config.js</span>
<span class="hljs-attr">rules</span>: {
  <span class="hljs-string">&quot;max-lines&quot;</span>: [<span class="hljs-string">&quot;error&quot;</span>, {
    <span class="hljs-attr">max</span>: <span class="hljs-number">140</span>,
    <span class="hljs-attr">skipBlankLines</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">skipComments</span>: <span class="hljs-literal">true</span>
  }],
  <span class="hljs-string">&quot;max-lines-per-function&quot;</span>: [<span class="hljs-string">&quot;error&quot;</span>, {
    <span class="hljs-attr">max</span>: <span class="hljs-number">50</span>,
    <span class="hljs-attr">skipBlankLines</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">skipComments</span>: <span class="hljs-literal">true</span>
  }],
}</code></pre><h3>Pre-commit Hooks</h3>
<pre><code class="hljs language-bash"><span class="hljs-comment"># .husky/pre-commit</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;üìè Checking file line counts...&quot;</span>
<span class="hljs-comment"># Automated line count validation</span>
<span class="hljs-comment"># Prevents commits with violations</span></code></pre><h3>CI/CD Integration</h3>
<pre><code class="hljs language-yaml"><span class="hljs-comment"># .github/workflows/ci.yml</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Check</span> <span class="hljs-string">modularity</span> <span class="hljs-string">standards</span>
  <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">lint</span>
  <span class="hljs-comment"># Fails build on violations</span></code></pre><h2>Best Practices</h2>
<h3>Do&#39;s ‚úÖ</h3>
<ul>
<li><strong>Split by Responsibility</strong>: Each module should have a single, clear purpose</li>
<li><strong>Use Orchestrators</strong>: Create main files that re-export from specialized modules</li>
<li><strong>Maintain Backward Compatibility</strong>: Don&#39;t break existing imports</li>
<li><strong>Test Thoroughly</strong>: Ensure all functionality works after refactoring</li>
<li><strong>Document Changes</strong>: Update README and documentation</li>
</ul>
<h3>Don&#39;ts ‚ùå</h3>
<ul>
<li><strong>Don&#39;t Split Arbitrarily</strong>: Ensure logical boundaries exist</li>
<li><strong>Don&#39;t Create Circular Dependencies</strong>: Keep imports clean and simple</li>
<li><strong>Don&#39;t Break Public APIs</strong>: Maintain existing interfaces</li>
<li><strong>Don&#39;t Skip Tests</strong>: Always verify functionality after refactoring</li>
<li><strong>Don&#39;t Ignore Performance</strong>: Consider impact on bundle size</li>
</ul>
<h2>Success Metrics</h2>
<h3>Quantitative Metrics</h3>
<ul>
<li><strong>File Size Reduction</strong>: Target 60-90% reduction in main file size</li>
<li><strong>Module Count</strong>: Increase in focused, single-purpose modules</li>
<li><strong>Test Coverage</strong>: Maintain or improve test coverage</li>
<li><strong>Build Time</strong>: No significant increase in build time</li>
</ul>
<h3>Qualitative Metrics</h3>
<ul>
<li><strong>Code Readability</strong>: Easier to understand and navigate</li>
<li><strong>Maintainability</strong>: Simpler to modify and extend</li>
<li><strong>Testability</strong>: More focused and comprehensive tests</li>
<li><strong>Developer Experience</strong>: Faster development and debugging</li>
</ul>
<h2>Case Studies</h2>
<h3>Case Study 1: Thumbnail Generator (1009 ‚Üí 370 lines)</h3>
<ul>
<li><strong>Strategy</strong>: Factory pattern with specialized generators</li>
<li><strong>Result</strong>: 63% reduction, improved maintainability</li>
<li><strong>Modules</strong>: ImageThumbnailGenerator, VideoThumbnailGenerator, etc.</li>
</ul>
<h3>Case Study 2: P2P Chat (980 ‚Üí 370 lines)</h3>
<ul>
<li><strong>Strategy</strong>: Composable pattern with focused concerns</li>
<li><strong>Result</strong>: 62% reduction, better reusability</li>
<li><strong>Modules</strong>: useP2PConnection, useP2PMessages, etc.</li>
</ul>
<h3>Case Study 3: File Types Config (673 ‚Üí 50 lines)</h3>
<ul>
<li><strong>Strategy</strong>: Category-specific modules</li>
<li><strong>Result</strong>: 93% reduction, clearer organization</li>
<li><strong>Modules</strong>: image-types, video-types, audio-types, etc.</li>
</ul>
<h2>Conclusion</h2>
<p>The 140-line axiom and modularity patterns in Reynard create a codebase that is:</p>
<ul>
<li><strong>Maintainable</strong>: Easy to understand and modify</li>
<li><strong>Scalable</strong>: Can grow without becoming unwieldy</li>
<li><strong>Testable</strong>: Focused modules are easier to test</li>
<li><strong>Collaborative</strong>: Multiple developers can work efficiently</li>
</ul>
<p>By following these patterns and guidelines, teams can create code that stands the test of time and scales with the project&#39;s growth.</p>
<hr>
<p><em>&quot;The cunning fox knows that small, focused modules are the key to outfoxing complexity.&quot;</em> ü¶ä</p>
</div>
    </div>
  </main>
  <footer class="docs-footer"><p>&copy; 2024 Reynard Documentation Test. Built with ‚ù§Ô∏è using SolidJS.</p></footer>
</body>
</html>