<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ADR-002: TypeScript Modularity Refactoring Standards - Reynard Documentation Test</title>
  <link rel="stylesheet" href="../styles.css">
  <link rel="stylesheet" href="../highlight.css">
  <link rel="icon" href="/favicon.ico">
</head>
<body>
  <nav class="docs-nav">
    <div class="nav-brand"><a href="../index.html">Reynard Documentation Test</a></div>
    <div class="nav-links"><a href="../index.html">Home</a><a href="../api.html">API Reference</a></div>
  </nav>
  <main class="docs-main">
    <div class="docs-content">
      <h1>ADR-002: TypeScript Modularity Refactoring Standards</h1>
      <div class="markdown-content"><h1>ADR-002: TypeScript Modularity Refactoring Standards</h1>
<h2>Status</h2>
<p><strong>Accepted</strong> - 2025-01-27</p>
<h2>Context</h2>
<p>The Reynard framework&#39;s TypeScript codebase was experiencing several critical issues that violated our modularity standards and type safety principles:</p>
<h3>Problems Identified</h3>
<ol>
<li><strong>Function Length Violations</strong>: The <code>createRAGClient</code> function exceeded 172 lines, violating our 140-line axiom</li>
<li><strong>Type Safety Issues</strong>: Use of <code>any</code> types and undefined type references (<code>AbortSignal</code>, <code>RequestInfo</code>)</li>
<li><strong>Monolithic Architecture</strong>: Mixed concerns within single files, making maintenance difficult</li>
<li><strong>Poor Testability</strong>: Large functions were difficult to test comprehensively</li>
<li><strong>Code Reusability</strong>: Tightly coupled code prevented independent module usage</li>
</ol>
<h3>Impact Assessment</h3>
<ul>
<li><strong>Maintainability</strong>: High - Large functions were difficult to understand and modify</li>
<li><strong>Type Safety</strong>: Critical - Type errors could lead to runtime failures</li>
<li><strong>Developer Experience</strong>: Medium - Linting errors and type issues slowed development</li>
<li><strong>Code Quality</strong>: High - Violations of established architectural principles</li>
</ul>
<h2>Decision</h2>
<p>We will implement a comprehensive modular refactoring strategy that addresses all identified issues while maintaining backward compatibility and improving overall code quality.</p>
<h3>Core Principles</h3>
<ol>
<li><strong>140-Line Axiom Enforcement</strong>: All source files must be under 140 lines</li>
<li><strong>Type Safety First</strong>: Eliminate all <code>any</code> types and ensure proper TypeScript usage</li>
<li><strong>Single Responsibility</strong>: Each module has one clear, well-defined purpose</li>
<li><strong>Factory Pattern</strong>: Use factory functions for clean module instantiation</li>
<li><strong>Interface-First Design</strong>: Define clear contracts before implementation</li>
</ol>
<h3>Refactoring Strategy</h3>
<h4>1. Extract by Functionality</h4>
<p>Break down monolithic functions into focused, single-responsibility modules:</p>
<pre><code class="hljs language-plaintext">Before: createRAGClient (172 lines)
After:
├── rag-query.ts (33 lines)
├── rag-ingest.ts (77 lines)
├── rag-config.ts (74 lines)
├── rag-admin.ts (67 lines)
└── rag-client.ts (39 lines) - Orchestrator</code></pre><h4>2. Extract by Layer</h4>
<p>Separate concerns into distinct layers:</p>
<pre><code class="hljs language-plaintext">Before: useRAG.ts (263 lines) - Mixed types and implementation
After:
├── rag-types.ts (141 lines) - Pure type definitions
└── useRAG.ts (55 lines) - Implementation only</code></pre><h4>3. Type Safety Improvements</h4>
<ul>
<li>Replace <code>any</code> types with <code>unknown</code> and proper type guards</li>
<li>Use <code>globalThis.AbortSignal</code> for proper AbortSignal typing</li>
<li>Ensure DOM library inclusion in TypeScript configuration</li>
<li>Implement proper generic constraints with defaults</li>
</ul>
<h2>Implementation Details</h2>
<h3>Module Structure</h3>
<p>The refactored RAG system follows this modular architecture:</p>
<pre><code class="hljs language-plaintext">packages/composables/src/ai/
├── rag-types.ts          # Type definitions and interfaces
├── rag-query.ts          # Query functionality
├── rag-ingest.ts         # Document ingestion
├── rag-config.ts         # Configuration management
├── rag-admin.ts          # Administrative operations
├── rag-search-resource.ts # Reactive search resources
├── rag-auto-refresh.ts   # Auto-refresh functionality
├── rag-client.ts         # Main orchestrator
├── useRAG.ts            # SolidJS composable
└── rag.ts               # Barrel exports</code></pre><h3>Type Safety Standards</h3>
<h4>AbortSignal Handling</h4>
<p><strong>Problem</strong>: <code>&#39;AbortSignal&#39; is not defined</code> errors</p>
<p><strong>Solution</strong>: Use <code>globalThis.AbortSignal</code> for proper type reference:</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Correct approach (2025 best practice)</span>
<span class="hljs-keyword">const</span> query = <span class="hljs-title function_">async</span> (
  <span class="hljs-attr">params</span>: <span class="hljs-title class_">RAGQueryParams</span>,
  <span class="hljs-attr">signal</span>?: globalThis.<span class="hljs-property">AbortSignal</span>,
): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">RAGQueryResponse</span>&lt;<span class="hljs-title class_">TExtra</span>&gt;&gt; =&gt; {
  <span class="hljs-comment">// Implementation with full type safety</span>
};</code></pre><h4>Generic Type Constraints</h4>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Proper generic with default constraint</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RAGQueryHit</span>&lt;<span class="hljs-title class_">TExtra</span> = <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">unknown</span>&gt;&gt; {
  <span class="hljs-attr">id</span>?: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">score</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">extra</span>?: <span class="hljs-title class_">TExtra</span>;
}</code></pre><h4>Interface-First Design</h4>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RAGClientOptions</span> {
  <span class="hljs-attr">authFetch</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">input</span>: <span class="hljs-built_in">string</span> | URL, <span class="hljs-attr">init</span>?: <span class="hljs-title class_">RequestInit</span></span>) =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Response</span>&gt;;
  <span class="hljs-attr">configUrl</span>?: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">queryUrl</span>?: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">ingestUrl</span>?: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">adminUrl</span>?: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">metricsUrl</span>?: <span class="hljs-built_in">string</span>;
}</code></pre><h3>Factory Pattern Implementation</h3>
<p>Each module exports a factory function for clean instantiation:</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createRAGQueryClient</span>(<span class="hljs-params">
  <span class="hljs-attr">authFetch</span>: <span class="hljs-title class_">RAGClientOptions</span>[<span class="hljs-string">&quot;authFetch&quot;</span>],
  <span class="hljs-attr">queryUrl</span>: <span class="hljs-built_in">string</span>,
</span>) {
  <span class="hljs-keyword">const</span> query = <span class="hljs-keyword">async</span> &lt;<span class="hljs-title class_">TExtra</span> = <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">unknown</span>&gt;&gt;(
    <span class="hljs-attr">params</span>: <span class="hljs-title class_">RAGQueryParams</span>,
    <span class="hljs-attr">signal</span>?: globalThis.<span class="hljs-property">AbortSignal</span>,
  ): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">RAGQueryResponse</span>&lt;<span class="hljs-title class_">TExtra</span>&gt;&gt; =&gt; {
    <span class="hljs-comment">// Focused implementation</span>
  };

  <span class="hljs-keyword">return</span> { query };
}</code></pre><h3>Composition Pattern</h3>
<p>The main client composes specialized clients:</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createRAGClient</span>(<span class="hljs-params"><span class="hljs-attr">options</span>: <span class="hljs-title class_">RAGClientOptions</span></span>) {
  <span class="hljs-comment">// Create specialized clients</span>
  <span class="hljs-keyword">const</span> queryClient = <span class="hljs-title function_">createRAGQueryClient</span>(authFetch, queryUrl);
  <span class="hljs-keyword">const</span> ingestClient = <span class="hljs-title function_">createRAGIngestClient</span>(authFetch, ingestUrl);
  <span class="hljs-keyword">const</span> configClient = <span class="hljs-title function_">createRAGConfigClient</span>(authFetch, configUrl);
  <span class="hljs-keyword">const</span> adminClient = <span class="hljs-title function_">createRAGAdminClient</span>(authFetch, adminUrl, metricsUrl);

  <span class="hljs-comment">// Compose the full client interface</span>
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">query</span>: queryClient.<span class="hljs-property">query</span>,
    <span class="hljs-attr">ingestDocuments</span>: ingestClient.<span class="hljs-property">ingestDocuments</span>,
    <span class="hljs-attr">getConfig</span>: configClient.<span class="hljs-property">getConfig</span>,
    <span class="hljs-attr">updateConfig</span>: configClient.<span class="hljs-property">updateConfig</span>,
    <span class="hljs-attr">getIndexingStatus</span>: adminClient.<span class="hljs-property">getIndexingStatus</span>,
    <span class="hljs-attr">getMetrics</span>: adminClient.<span class="hljs-property">getMetrics</span>,
    <span class="hljs-attr">admin</span>: adminClient.<span class="hljs-property">admin</span>,
  };
}</code></pre><h2>Consequences</h2>
<h3>Positive</h3>
<ol>
<li><strong>Improved Maintainability</strong>: Each module has a single, clear responsibility</li>
<li><strong>Enhanced Testability</strong>: Small, focused units that can be thoroughly tested</li>
<li><strong>Better Reusability</strong>: Modules can be imported and used independently</li>
<li><strong>Type Safety</strong>: Comprehensive TypeScript interfaces with proper typing</li>
<li><strong>Developer Experience</strong>: Clear, readable code that&#39;s easy to understand</li>
<li><strong>Scalability</strong>: Easy to extend or modify individual components</li>
<li><strong>Code Quality</strong>: Adherence to established architectural principles</li>
</ol>
<h3>Negative</h3>
<ol>
<li><strong>Initial Refactoring Effort</strong>: Significant upfront work to break down monolithic code</li>
<li><strong>File Count Increase</strong>: More files to manage (mitigated by clear organization)</li>
<li><strong>Learning Curve</strong>: Developers need to understand the new modular patterns</li>
</ol>
<h3>Risks and Mitigations</h3>
<table>
<thead>
<tr>
<th>Risk</th>
<th>Impact</th>
<th>Mitigation</th>
</tr>
</thead>
<tbody><tr>
<td>Breaking Changes</td>
<td>High</td>
<td>Maintain backward compatibility through proper exports</td>
</tr>
<tr>
<td>Performance Impact</td>
<td>Low</td>
<td>Factory pattern has minimal overhead</td>
</tr>
<tr>
<td>Developer Confusion</td>
<td>Medium</td>
<td>Comprehensive documentation and examples</td>
</tr>
<tr>
<td>Type Complexity</td>
<td>Low</td>
<td>Clear interfaces and proper generic constraints</td>
</tr>
</tbody></table>
<h2>Compliance</h2>
<h3>ESLint Rules</h3>
<p>The following rules ensure compliance with this decision:</p>
<ul>
<li><code>max-lines-per-function</code>: Enforces 140-line limit</li>
<li><code>@typescript-eslint/no-explicit-any</code>: Prevents <code>any</code> type usage</li>
<li><code>@typescript-eslint/no-unused-vars</code>: Ensures clean imports</li>
</ul>
<h3>Code Review Checklist</h3>
<ul>
<li><input disabled="" type="checkbox"> All functions are under 140 lines</li>
<li><input disabled="" type="checkbox"> No <code>any</code> types used (except where explicitly documented)</li>
<li><input disabled="" type="checkbox"> Proper TypeScript types for all parameters and return values</li>
<li><input disabled="" type="checkbox"> Single responsibility per module</li>
<li><input disabled="" type="checkbox"> Clear interfaces defined before implementation</li>
<li><input disabled="" type="checkbox"> Factory pattern used for module creation</li>
<li><input disabled="" type="checkbox"> Proper error handling and type guards</li>
</ul>
<h3>Monitoring</h3>
<ul>
<li><strong>Linting Errors</strong>: Zero tolerance for type safety violations</li>
<li><strong>Function Length</strong>: Continuous monitoring via ESLint</li>
<li><strong>Test Coverage</strong>: Maintain high coverage for all modules</li>
<li><strong>Performance</strong>: Monitor for any performance regressions</li>
</ul>
<h2>References</h2>
<ul>
<li><a href="./001-modularity-standards.md">ADR-001: Modularity Standards</a></li>
<li><a href="../development/frontend/typescript-modularity-standards.md">TypeScript Modularity Standards</a></li>
<li><a href="./modularity-patterns.md">Reynard Modular Manifesto</a></li>
<li><a href="https://www.typescriptlang.org/docs/">TypeScript Official Documentation</a></li>
</ul>
<h2>Implementation Timeline</h2>
<ul>
<li><strong>Phase 1</strong>: Core RAG system refactoring (Completed)</li>
<li><strong>Phase 2</strong>: Apply patterns to other large modules (In Progress)</li>
<li><strong>Phase 3</strong>: Documentation and training (Completed)</li>
<li><strong>Phase 4</strong>: Monitoring and optimization (Ongoing)</li>
</ul>
<h2>Review Date</h2>
<p>This ADR will be reviewed on 2025-07-27 to assess effectiveness and identify any necessary adjustments.</p>
</div>
    </div>
  </main>
  <footer class="docs-footer"><p>&copy; 2024 Reynard Documentation Test. Built with ❤️ using SolidJS.</p></footer>
</body>
</html>