<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Streaming Tool Execution - Reynard Documentation Test</title>
  <link rel="stylesheet" href="../styles.css">
  <link rel="stylesheet" href="../highlight.css">
  <link rel="icon" href="/favicon.ico">
</head>
<body>
  <nav class="docs-nav">
    <div class="nav-brand"><a href="../index.html">Reynard Documentation Test</a></div>
    <div class="nav-links"><a href="../index.html">Home</a><a href="../api.html">API Reference</a></div>
  </nav>
  <main class="docs-main">
    <div class="docs-content">
      <h1>Streaming Tool Execution</h1>
      <div class="markdown-content"><h1>Streaming Tool Execution</h1>
<p>This document describes the streaming tool execution functionality in yipyap, which allows tools to emit progress updates and intermediate results during execution.</p>
<h2>Overview</h2>
<p>Streaming tool execution enables tools to provide real-time feedback during long-running operations. This is particularly useful for:</p>
<ul>
<li>File processing operations</li>
<li>Data analysis tasks</li>
<li>External API calls with progress tracking</li>
<li>Batch operations with multiple steps</li>
</ul>
<h2>Architecture</h2>
<h3>Core Components</h3>
<ol>
<li><strong>StreamingBaseTool</strong>: Abstract base class for tools that support streaming</li>
<li><strong>StreamingToolExecutionContext</strong>: Extended execution context with progress callbacks</li>
<li><strong>StreamingToolResult</strong>: Extended result class with streaming metadata</li>
<li><strong>ProgressReportingMixin</strong>: Utility mixin for common progress reporting patterns</li>
</ol>
<h3>Streaming Chunk Types</h3>
<p>The system supports several types of streaming chunks:</p>
<ul>
<li><code>tool_execution</code>: Initial tool execution notification</li>
<li><code>tool_execution_progress</code>: Progress updates during execution</li>
<li><code>tool_execution_error</code>: Error notifications during execution</li>
<li><code>tool_result</code>: Final execution result</li>
</ul>
<h2>Creating a Streaming Tool</h2>
<h3>Basic Implementation</h3>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> app.tools.streaming_base <span class="hljs-keyword">import</span> StreamingBaseTool, ProgressReportingMixin
<span class="hljs-keyword">from</span> app.tools.base <span class="hljs-keyword">import</span> ToolParameter, ParameterType

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStreamingTool</span>(StreamingBaseTool, ProgressReportingMixin):
<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;my.streaming_tool&quot;</span>

<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">description</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;A streaming tool that demonstrates progress updates&quot;</span>

<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parameters</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> [
            ToolParameter(
                name=<span class="hljs-string">&quot;input_file&quot;</span>,
                <span class="hljs-built_in">type</span>=ParameterType.STRING,
                description=<span class="hljs-string">&quot;Input file to process&quot;</span>,
                required=<span class="hljs-literal">True</span>
            )
        ]

    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">execute_streaming</span>(<span class="hljs-params">
        self,
        context: StreamingToolExecutionContext,
        **params
    </span>) -&gt; AsyncGenerator[StreamingToolResult, <span class="hljs-literal">None</span>]:
        input_file = params.get(<span class="hljs-string">&quot;input_file&quot;</span>)

        <span class="hljs-comment"># Report initialization</span>
        <span class="hljs-keyword">await</span> <span class="hljs-variable language_">self</span>.report_initialization_progress(
            context, <span class="hljs-variable language_">self</span>.name, context.request_id <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;unknown&quot;</span>
        )

        <span class="hljs-comment"># Process in steps</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):
            progress = (i + <span class="hljs-number">1</span>) / <span class="hljs-number">5</span>

            <span class="hljs-keyword">await</span> <span class="hljs-variable language_">self</span>.report_processing_progress(
                context,
                progress,
                <span class="hljs-string">f&quot;Processing step <span class="hljs-subst">{i + <span class="hljs-number">1</span>}</span>&quot;</span>,
                {<span class="hljs-string">&quot;step&quot;</span>: i + <span class="hljs-number">1</span>, <span class="hljs-string">&quot;total_steps&quot;</span>: <span class="hljs-number">5</span>}
            )

            <span class="hljs-comment"># Simulate work</span>
            <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.5</span>)

            <span class="hljs-comment"># Yield intermediate result</span>
            <span class="hljs-keyword">yield</span> StreamingToolResult(
                success=<span class="hljs-literal">True</span>,
                data={<span class="hljs-string">&quot;step&quot;</span>: i + <span class="hljs-number">1</span>, <span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;completed&quot;</span>},
                metadata={<span class="hljs-string">&quot;progress&quot;</span>: progress},
                streamed_progress=<span class="hljs-literal">True</span>,
                total_progress_updates=i + <span class="hljs-number">1</span>
            )

        <span class="hljs-comment"># Report completion</span>
        <span class="hljs-keyword">await</span> <span class="hljs-variable language_">self</span>.report_completion_progress(context, <span class="hljs-string">&quot;Processing completed&quot;</span>)

        <span class="hljs-comment"># Yield final result</span>
        <span class="hljs-keyword">yield</span> StreamingToolResult(
            success=<span class="hljs-literal">True</span>,
            data={<span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;All steps completed successfully&quot;</span>},
            metadata={<span class="hljs-string">&quot;total_steps&quot;</span>: <span class="hljs-number">5</span>},
            streamed_progress=<span class="hljs-literal">True</span>,
            total_progress_updates=<span class="hljs-number">6</span>
        )</code></pre><h3>Error Handling</h3>
<pre><code class="hljs language-python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">execute_streaming</span>(<span class="hljs-params">
    self,
    context: StreamingToolExecutionContext,
    **params
</span>) -&gt; AsyncGenerator[StreamingToolResult, <span class="hljs-literal">None</span>]:
    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment"># Tool execution logic</span>
        <span class="hljs-keyword">pass</span>
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-comment"># Report error</span>
        <span class="hljs-keyword">await</span> <span class="hljs-variable language_">self</span>.report_error_progress(
            context,
            <span class="hljs-built_in">str</span>(e),
            error_type=<span class="hljs-built_in">type</span>(e).__name__,
            retryable=<span class="hljs-literal">True</span>
        )

        <span class="hljs-comment"># Yield error result</span>
        <span class="hljs-keyword">yield</span> StreamingToolResult(
            success=<span class="hljs-literal">False</span>,
            error=<span class="hljs-built_in">str</span>(e),
            metadata={<span class="hljs-string">&quot;error_type&quot;</span>: <span class="hljs-built_in">type</span>(e).__name__}
        )</code></pre><h2>Progress Reporting Methods</h2>
<p>The <code>ProgressReportingMixin</code> provides several utility methods:</p>
<ul>
<li><code>report_initialization_progress()</code>: Report tool initialization (0% progress)</li>
<li><code>report_processing_progress()</code>: Report processing progress (0-100%)</li>
<li><code>report_finalization_progress()</code>: Report finalization (90% progress)</li>
<li><code>report_completion_progress()</code>: Report completion (100% progress)</li>
<li><code>report_error_progress()</code>: Report errors during execution</li>
</ul>
<h2>Frontend Integration</h2>
<p>The frontend automatically handles streaming tool execution through the <code>useOllama</code> composable. Tool execution progress is displayed in real-time with:</p>
<ul>
<li>Progress indicators</li>
<li>Status messages</li>
<li>Intermediate data display</li>
<li>Error handling with retry options</li>
</ul>
<h3>Example Usage</h3>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// The frontend automatically handles streaming chunks</span>
<span class="hljs-keyword">const</span> { chatWithAssistant } = <span class="hljs-title function_">useOllama</span>();

<span class="hljs-comment">// Tool execution progress is automatically tracked</span>
<span class="hljs-keyword">await</span> <span class="hljs-title function_">chatWithAssistant</span>(<span class="hljs-string">&quot;Process this file with the streaming tool&quot;</span>);</code></pre><h2>Example Tools</h2>
<h3>StreamingExampleTool</h3>
<p>A demonstration tool that shows streaming progress with configurable steps and delays.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>operation</code>: Type of operation (process_data, analyze_files, generate_report)</li>
<li><code>steps</code>: Number of steps to simulate (1-20)</li>
<li><code>delay</code>: Delay between steps in seconds (0.1-2.0)</li>
</ul>
<h3>StreamingErrorTool</h3>
<p>A demonstration tool that shows error handling in streaming execution.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>should_fail</code>: Whether the tool should fail</li>
<li><code>fail_step</code>: At which step to fail (if should_fail is true)</li>
</ul>
<h2>Testing</h2>
<p>Streaming tools can be tested using the provided test framework:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> pytest
<span class="hljs-keyword">from</span> app.tests.test_streaming_tools <span class="hljs-keyword">import</span> TestStreamingExampleTool

<span class="hljs-meta">@pytest.mark.asyncio</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_my_streaming_tool</span>():
    tool = MyStreamingTool()
    context = StreamingToolExecutionContext(user_id=<span class="hljs-string">&quot;test&quot;</span>, user_role=<span class="hljs-string">&quot;user&quot;</span>)

    results = []
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> tool.execute_streaming(context, input_file=<span class="hljs-string">&quot;test.txt&quot;</span>):
        results.append(result)

    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(results) &gt; <span class="hljs-number">0</span>
    <span class="hljs-keyword">assert</span> results[-<span class="hljs-number">1</span>].success <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span></code></pre><h2>Best Practices</h2>
<ol>
<li><strong>Progress Granularity</strong>: Report progress at meaningful intervals (not too frequent)</li>
<li><strong>Error Handling</strong>: Always handle exceptions and report errors through the streaming context</li>
<li><strong>Intermediate Results</strong>: Yield intermediate results when they provide value to the user</li>
<li><strong>Resource Cleanup</strong>: Ensure proper cleanup in case of errors or cancellation</li>
<li><strong>Timeout Handling</strong>: Respect the timeout specified in the execution context</li>
</ol>
<h2>Migration from Regular Tools</h2>
<p>To migrate an existing tool to support streaming:</p>
<ol>
<li>Change the base class from <code>BaseTool</code> to <code>StreamingBaseTool</code></li>
<li>Add <code>ProgressReportingMixin</code> to the class</li>
<li>Implement the <code>execute_streaming</code> method</li>
<li>Update the <code>execute</code> method to use the streaming implementation</li>
<li>Add progress reporting calls at appropriate points</li>
</ol>
<p>The tool will continue to work with the existing non-streaming interface while gaining streaming capabilities.</p>
</div>
    </div>
  </main>
  <footer class="docs-footer"><p>&copy; 2024 Reynard Documentation Test. Built with ❤️ using SolidJS.</p></footer>
</body>
</html>