<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Caption Generation - Reynard Documentation Test</title>
  <link rel="stylesheet" href="../styles.css">
  <link rel="stylesheet" href="../highlight.css">
  <link rel="icon" href="/favicon.ico">
</head>
<body>
  <nav class="docs-nav">
    <div class="nav-brand"><a href="../index.html">Reynard Documentation Test</a></div>
    <div class="nav-links"><a href="../index.html">Home</a><a href="../api.html">API Reference</a></div>
  </nav>
  <main class="docs-main">
    <div class="docs-content">
      <h1>Caption Generation</h1>
      <div class="markdown-content"><h1>Caption Generation</h1>
<p>This system provides a unified, model-agnostic way to generate captions and tags in the Reynard framework. It discovers captioners at runtime, applies retry and post-processing policies, and can persist results for the gallery. The system is implemented in the <code>reynard-annotating</code> package.</p>
<h2>Architecture</h2>
<p>Captioning is implemented as a modular plugin system across multiple packages in the Reynard ecosystem. The system provides a unified interface while maintaining clear separation of concerns between core functionality and individual generators.</p>
<h3>Package Structure</h3>
<pre><code class="hljs">reynard-annotating<span class="hljs-symbol">/</span>
├── annotating-core<span class="hljs-symbol">/</span>          <span class="hljs-comment"># Core functionality, types, and services</span>
│   ├── managers<span class="hljs-symbol">/</span>            <span class="hljs-comment"># Model lifecycle, health monitoring, circuit breakers</span>
│   ├── services<span class="hljs-symbol">/</span>            <span class="hljs-comment"># Annotation services, batch processing, event system</span>
│   └── types<span class="hljs-symbol">/</span>               <span class="hljs-comment"># TypeScript definitions and interfaces</span>
├── annotating-jtp2<span class="hljs-symbol">/</span>          <span class="hljs-comment"># JTP2 generator package (furry artwork tagging)</span>
│   ├── core<span class="hljs-symbol">/</span>                <span class="hljs-comment"># JTP2Generator implementation</span>
│   ├── config<span class="hljs-symbol">/</span>              <span class="hljs-comment"># Configuration schemas and validation</span>
│   ├── plugin<span class="hljs-symbol">/</span>              <span class="hljs-comment"># Plugin registration and lifecycle</span>
│   └── simulation<span class="hljs-symbol">/</span>          <span class="hljs-comment"># Model simulation for development/testing</span>
├── annotating-joy<span class="hljs-symbol">/</span>           <span class="hljs-comment"># JoyCaption generator package (multilingual LLM)</span>
├── annotating-florence2<span class="hljs-symbol">/</span>     <span class="hljs-comment"># Florence2 generator package (general purpose)</span>
├── annotating-wdv3<span class="hljs-symbol">/</span>          <span class="hljs-comment"># WDv3 generator package (Danbooru-style tagging)</span>
└── annotating<span class="hljs-symbol">/</span>               <span class="hljs-comment"># Unified interface (this package)</span>
    ├── core<span class="hljs-symbol">/</span>                <span class="hljs-comment"># Manager delegation and plugin management</span>
    ├── factory<span class="hljs-symbol">/</span>             <span class="hljs-comment"># Factory functions for creating managers</span>
    ├── generators<span class="hljs-symbol">/</span>          <span class="hljs-comment"># Generator accessors and convenience methods</span>
    └── config<span class="hljs-symbol">/</span>              <span class="hljs-comment"># Production configuration</span></code></pre><h3>Key Components</h3>
<ul>
<li><strong>UnifiedAnnotationManager</strong> - Main orchestrator that coordinates all generators</li>
<li><strong>BaseCaptionGenerator</strong> - Abstract interface defining generation, availability checks, configuration schema, versioning, and caption types</li>
<li><strong>Plugin System</strong> - Dynamic registration and discovery of generator plugins</li>
<li><strong>Health Monitoring</strong> - Real-time health checks and performance metrics</li>
<li><strong>Circuit Breakers</strong> - Fault tolerance and error handling</li>
<li><strong>Usage Tracking</strong> - Model usage statistics and performance monitoring</li>
</ul>
<h3>Frontend Files (packages/annotating*)</h3>
<ul>
<li><code>packages/annotating/src/UnifiedAnnotationManager.ts</code> - Main orchestrator</li>
<li><code>packages/annotating-core/src/services/AnnotationService.ts</code> - Service layer</li>
<li><code>packages/annotating-core/src/services/CaptionGenerator.ts</code> - Abstract base class</li>
<li><code>packages/annotating-*/src/*</code> - Individual generator implementations</li>
</ul>
<h3>Backend Files (TBD)</h3>
<ul>
<li><code>app/caption_generation/base.py</code></li>
<li><code>app/caption_generation/__init__.py</code></li>
<li><code>app/caption_generation/plugin_loader.py</code></li>
<li><code>app/caption_generation/caption_service.py</code></li>
<li><code>app/caption_generation/plugins/*</code></li>
</ul>
<h2>Available Generators and Types</h2>
<p>Generator categories are used to optimize loading: lightweight models such as <code>jtp2</code> and <code>wdv3</code> are loaded eagerly, while heavy models such as <code>joy</code> and <code>florence2</code> are coordinated via async locks to avoid duplicate downloads. Each generator exposes a <code>caption_type</code>. For example, <code>jtp2</code> returns <code>tags</code>, so saved captions will use a <code>.tags</code> extension. The unified service exposes <code>get_available_generators()</code>, <code>is_generator_available(name)</code>, and <code>is_model_loaded(name)</code> for introspection.</p>
<h2>Backend API</h2>
<p>The main endpoints for captions live in the app router. Use <code>POST /api/generate-caption/{path}</code> to trigger a single caption with query parameters <code>generator</code> (name), <code>force</code> (bool), and <code>post_process</code> (bool). The service validates the generator via the unified manager and returns a structured result with <code>success</code>, <code>caption</code>, <code>processing_time</code>, and <code>caption_type</code>. Use <code>POST /api/batch-generate-captions</code> to stream progress for many images; the request body contains an <code>items</code> array of image descriptors, a <code>generator</code> string, and an optional <code>config</code> object. Existing captions are skipped unless <code>force</code> is true. Use <code>PUT /api/caption/{path}</code> and <code>DELETE /api/caption/{path}</code> to write or remove specific caption sidecars by <code>type</code>. Use <code>PUT /api/captioner-config/{name}</code> to update generator configuration at runtime.</p>
<h2>Service Behavior</h2>
<p>Single requests call <code>UnifiedCaptionService.generate_single_caption(image_path, generator_name, config, force, data_source)</code>. The service coordinates model loading via per-model async locks and can queue a request if a model is not yet available. Before generation, it checks for an existing caption sidecar of the generator’s <code>caption_type</code> and returns a concise error if present and <code>force</code> is not enabled. Generation is wrapped in <code>_retry_with_backoff</code> with exponential delays and error-type heuristics to decide retryability. After success, optional post-processing normalizes output (for example, replacing underscores for taggers) before saving through the <code>data_source</code> with the resolved <code>caption_type</code>.</p>
<h2>Errors and Post‑processing</h2>
<p>Errors are reported with a concise <code>error</code> message, an <code>error_type</code> such as <code>model_loading</code>, <code>model_unavailable</code>, <code>generation</code>, or <code>unexpected</code>, and a <code>retryable</code> flag. For <code>generation</code> errors, the formatted message keeps only the reason after the colon. Post‑processing can be enabled per request and is applied generator‑specifically.</p>
<h2>Frontend Integration</h2>
<p>The gallery module exposes caption actions and uses typed fetches with progress and notifications. The <code>generateCaption</code> flow in <code>src/modules/gallery/captions.ts</code> accepts <code>path</code>, <code>type</code>, and an optional <code>model</code> (defaulting to <code>jtp2</code>), updates loading state, and notifies on completion. A composable in <code>src/composables/useUnifiedCaptionGeneration.ts</code> centralizes UI integration for batch flows.</p>
<ul>
<li>Files:<ul>
<li><code>src/modules/gallery/captions.ts</code></li>
<li><code>src/composables/useUnifiedCaptionGeneration.ts</code></li>
</ul>
</li>
</ul>
<h2>Adding a New Captioner</h2>
<p>Implement a class conforming to <code>CaptionGenerator</code> with <code>generate</code>, <code>is_available</code>, <code>name</code>, <code>caption_type</code>, <code>description</code>, <code>version</code>, and <code>config_schema</code>. Place it under <code>app/caption_generation/plugins/</code> and ensure dependencies are lazily imported. The system will discover it at runtime, and it becomes available through the unified service and API.</p>
<h3>Plugin authoring details</h3>
<p>Plugins live under <code>app/caption_generation/plugins/&lt;your_plugin&gt;</code> and are discovered dynamically. Each plugin package must provide an <code>__init__.py</code> that exports a <code>register_plugin()</code> function returning a dictionary with <code>name</code>, <code>module_path</code>, and optionally <code>default_config</code>. The module referenced by <code>module_path</code> must export <code>get_generator(config)</code> which returns an instance of a class implementing <code>CaptionGenerator</code>. Heavy dependencies should be imported lazily inside <code>get_generator</code> to keep startup fast and to allow availability checks to fail gracefully without crashing the application. The captioner instance must return a <code>caption_type</code> string; this maps directly to the sidecar file extension used when saving results (for example, <code>tags</code>, <code>wd</code>, <code>caption</code>, or <code>florence</code>).</p>
<p>The plugin loader handles lazy initialization, availability checks, and configuration updates without requiring an application restart. Configuration changes are applied by resetting the plugin so that the next call re‑initializes with the updated config.</p>
<h2>Unified Service Behavior</h2>
<p>The <code>UnifiedCaptionService</code> coordinates model availability, loading, and generation for both single and batch operations. Models are categorized as lightweight or heavy to guide loading decisions. Per‑model async locks serialize load and download phases to prevent duplicate downloads and reduce contention. When a heavy model is not yet available, the service can place the request into a queue and return a queued response so the UI can notify the user and poll status. All generation attempts use bounded retries with exponential backoff; retryability is decided by error type.</p>
<p>Before generation, the service checks for existing sidecars matching the generator’s <code>caption_type</code> and skips work unless <code>force</code> is set. After success, optional post‑processing can normalize output (for example, replacing underscores with spaces for taggers) prior to persistence through the data source. Processing time is measured and returned to clients for UI feedback and metrics.</p>
<h2>Backend API Reference</h2>
<p>Single caption generation is provided by <code>POST /api/generate-caption/{path}</code>. Query parameters include <code>generator</code> (required), <code>force</code> (boolean, default <code>false</code>), and <code>post_process</code> (boolean, default <code>true</code>). The <code>path</code> supports a root shorthand where files at the root may be referenced as <code>_/file.png</code>. On success the response contains <code>success</code>, <code>caption</code>, <code>generator</code>, <code>caption_type</code>, and <code>processing_time</code>. When the target caption already exists and <code>force</code> is not set, an error is returned with <code>caption_exists</code>. If a heavy model download is still in progress, the endpoint returns a queued response with <code>queued: true</code>, a <code>request_id</code>, and a human‑readable <code>message</code> so the caller can monitor progress.</p>
<p>Batch generation is provided by <code>POST /api/batch-generate-captions</code> and returns a streaming response of progress events. The request body contains an <code>items</code> array of <code>{ path, name }</code> entries, a <code>generator</code> string, and an optional <code>config</code> including <code>force</code> and <code>post_process</code>. The stream emits JSON lines prefixed with <code>data:</code> including a <code>start</code> event with <code>total</code>, <code>item_complete</code> events that include <code>item_result</code> with <code>success</code>, optional <code>caption</code>, and error details when applicable, and a final <code>complete</code> event with <code>processed</code>, <code>successful</code>, and <code>failed</code>. The stream uses <code>text/plain</code> with headers that disable buffering so the frontend can process updates in real time.</p>
<p>Caption files can be written and deleted via <code>PUT /api/caption/{path}</code> and <code>DELETE /api/caption/{path}</code>. The update endpoint expects a JSON body with <code>type</code> (for example, <code>caption</code>, <code>tags</code>, <code>wd</code>, <code>florence</code>) and <code>caption</code> (string). Deletion requires a <code>caption_type</code> query parameter. Available caption sidecar extensions are managed by <code>GET /api/caption-types</code> and <code>POST /api/caption-types</code>, which respectively return and update the server‑side set of recognized extensions. Captioner configuration can be updated at runtime using <code>PUT /api/captioner-config/{name}</code> with a JSON body of configuration values; the plugin will be reset and re‑initialized on next use.</p>
<p>For queued heavy‑model requests the server exposes <code>GET /api/caption-request-queue-status</code> for queue summaries, <code>GET /api/caption-request-status/{request_id}</code> for per‑request status, and <code>DELETE /api/caption-request/{request_id}</code> to cancel a queued request when supported. All endpoints enforce authentication.</p>
<h2>Post‑processing Options</h2>
<p>Post‑processing can be applied to captions to normalize spacing, replace underscores, enforce terminal punctuation, and adjust case. The unified caption service supports both a simple default behavior and an advanced, configurable pipeline that can be customized globally and per‑generator.</p>
<p>Settings are stored server‑side and exposed via:</p>
<ul>
<li><code>GET /api/caption-post-processing</code>: returns the current settings</li>
<li><code>PUT /api/caption-post-processing</code>: updates settings (admin)</li>
</ul>
<p>Settings schema (representative):</p>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;enabled&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;rules&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;replace_underscores&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;case_conversion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;none&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;trim_whitespace&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;remove_duplicate_spaces&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;normalize_punctuation_spacing&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;ensure_terminal_punctuation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;pipeline&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-string">&quot;replace_underscores&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">&quot;trim_whitespace&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">&quot;remove_duplicate_spaces&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">&quot;normalize_punctuation_spacing&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">&quot;case_conversion&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">&quot;ensure_terminal_punctuation&quot;</span>
  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;overrides&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;jtp2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">&quot;replace_underscores&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;joy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">&quot;replace_underscores&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span> <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span></code></pre><p>When no explicit settings are provided, the backend applies a minimal default suitable for common models (e.g., replacing underscores for taggers and ensuring terminal punctuation for longer sentences).</p>
<h2>Error Model and Retries</h2>
<p>Errors returned from single or batch flows include a concise <code>error</code> message, an <code>error_type</code>, and a <code>retryable</code> flag. The main error types are <code>model_loading</code>, <code>model_unavailable</code>, <code>model_download</code>, <code>generation</code>, <code>caption_exists</code>, <code>network</code>, <code>timeout</code>, and <code>unexpected</code>. The unified service and frontend composable both apply bounded exponential backoff for retryable categories and surface user‑friendly notifications for non‑retryable ones. Batch streaming enriches <code>item_complete</code> events with derived <code>error_type</code> and <code>retryable</code> to allow responsive UI feedback.</p>
<h2>Frontend Usage</h2>
<p>The gallery integrates captioning through a composable at <code>src/composables/useUnifiedCaptionGeneration.ts</code>. It provides <code>generateSingleCaption(imagePath, { generator, force, postProcess })</code> and <code>generateBatchCaptions({ items, generator, config, force, postProcess })</code>. The single‑request path automatically interprets queued responses by handing off to a caption request queue composable in <code>src/composables/useCaptionRequestQueue.ts</code>, which polls <code>caption-request-queue-status</code> and <code>caption-request-status</code> endpoints and surfaces notifications. Batch flows consume the streaming response by reading lines beginning with <code>data:</code> and updating progress in real time. A convenience path for classic operations is available via <code>src/resources/browse.ts</code> where <code>generateCaption(path, name, generator, force)</code> calls the single‑caption endpoint, and advanced gallery operations in <code>src/modules/gallery/advancedOperations.ts</code> wrap tag generation with notifications.</p>
<h2>Request and Response Examples</h2>
<p>Single caption generation request using the root shorthand:</p>
<pre><code class="hljs language-bash">curl -X POST \
  <span class="hljs-string">&quot;http://localhost:7000/api/generate-caption/_/example.jpg?generator=jtp2&amp;post_process=true&quot;</span> \
  -H <span class="hljs-string">&quot;Authorization: Bearer &lt;token&gt;&quot;</span></code></pre><p>Successful response shape:</p>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;success&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;caption&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;tag_one, tag_two, tag_three&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;generator&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;jtp2&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;caption_type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;tags&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;processing_time&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0.42</span>
<span class="hljs-punctuation">}</span></code></pre><p>Queued response shape when a heavy model is downloading:</p>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;success&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;queued&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;request_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;c1a2b3c4-d5e6-7f89-0123-456789abcdef&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Model florence2 is being downloaded. Your request has been queued and will be processed automatically when the download completes.&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;error&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Request queued (ID: c1a2...)&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;error_type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;model_unavailable&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;retryable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>
<span class="hljs-punctuation">}</span></code></pre><p>Batch request body example:</p>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;items&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span> <span class="hljs-attr">&quot;path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;example.jpg&quot;</span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span> <span class="hljs-attr">&quot;path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;another.png&quot;</span> <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;generator&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;joy&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;config&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">&quot;force&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;post_process&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span> <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span></code></pre><p>The streaming response consists of lines starting with <code>data:</code> containing JSON objects such as <code>{ &quot;type&quot;: &quot;start&quot;, &quot;total&quot;: 2 }</code>, <code>{ &quot;type&quot;: &quot;item_complete&quot;, &quot;item_result&quot;: { &quot;success&quot;: true, &quot;caption&quot;: &quot;...&quot;, &quot;caption_type&quot;: &quot;caption&quot; } }</code>, and a final <code>{ &quot;type&quot;: &quot;complete&quot;, &quot;processed&quot;: 2, &quot;successful&quot;: 2, &quot;failed&quot;: 0 }</code>.</p>
<h2>Notes on Sidecar Types</h2>
<p>Recognized caption sidecar extensions are managed server‑side and can be read and updated without restart. The default set includes <code>.caption</code>, <code>.txt</code>, <code>.tags</code>, <code>.florence</code>, and <code>.wd</code>. Frontend UI uses a caption types context to present both manual and auto‑captioner types, and backend persistence writes sidecars using the generator’s <code>caption_type</code> as the extension. When adding a new captioner, choose a <code>caption_type</code> that is concise, unique, and representative of the output format.</p>
</div>
    </div>
  </main>
  <footer class="docs-footer"><p>&copy; 2024 Reynard Documentation Test. Built with ❤️ using SolidJS.</p></footer>
</body>
</html>