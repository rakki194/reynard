/**
 * üê∫ EXPLOIT RUNNER
 *
 * *snarls with predatory focus* Handles execution of individual exploits
 * with proper error handling and result parsing.
 */

import { exec } from "child_process";
import path from "path";
import { promisify } from "util";
import { getExploitClassName } from "./exploit-class-mapper";
import { determineSeverity, generateExploitRecommendations } from "./exploit-recommendations";
import type { ExploitOptions, ExploitResult, PenetrationResult } from "./penetration-types";

const execAsync = promisify(exec);

/**
 * Exploit Runner Class
 */
export class ExploitRunner {
  private readonly fenrirPath: string;
  private readonly config: {
    timeout: number;
    backendUrl: string;
    verbose: boolean;
    destructive: boolean;
  };

  constructor(config: { timeout: number; backendUrl: string; verbose: boolean; destructive: boolean }) {
    this.config = config;
    this.fenrirPath = path.join(process.cwd(), "..", "fenrir");
  }

  /**
   * Run a specific exploit
   */
  async runExploit(exploitModule: string, options: ExploitOptions = {}): Promise<PenetrationResult> {
    const startTime = Date.now();

    try {
      const command = this.buildExploitCommand(exploitModule, options);
      const { stdout, stderr } = await this.executeCommand(command);

      if (stderr && !stderr.includes("Warning")) {
        console.warn(`‚ö†Ô∏è Exploit ${exploitModule} warning: ${stderr}`);
      }

      const result: ExploitResult = JSON.parse(stdout);
      const executionTime = Date.now() - startTime;

      return this.createSuccessResult(exploitModule, result, executionTime);
    } catch (error) {
      console.error(`‚ùå Exploit ${exploitModule} failed:`, error);
      return this.createErrorResult(exploitModule, error as Error, Date.now() - startTime);
    }
  }

  /**
   * Build the Python command for running an exploit
   */
  private buildExploitCommand(exploitModule: string, options: ExploitOptions): string {
    const pythonPath = process.env.PYTHON_PATH || "bash -c 'source ~/venv/bin/activate && python3'";
    const quickTestFlag = options.quickTest ? "quick_test=True" : "quick_test=False";

    return `${pythonPath} -c "
import sys
sys.path.append('${this.fenrirPath}')
from ${exploitModule} import *
import json

# Run the exploit
exploit = ${getExploitClassName(exploitModule)}('${options.target || this.config.backendUrl}')
result = exploit.run_exploit(${quickTestFlag})

# Return results as JSON
print(json.dumps({
    'success': True,
    'vulnerabilities_found': len([r for r in result if hasattr(r, 'success') and r.success]),
    'details': [{'type': r.vulnerability_type, 'description': r.description, 'impact': r.impact} for r in result if hasattr(r, 'vulnerability_type')],
    'execution_time': 0
}))
"`;
  }

  /**
   * Execute the exploit command
   */
  private async executeCommand(command: string): Promise<{ stdout: string; stderr: string }> {
    return await execAsync(command, {
      timeout: this.config.timeout,
      cwd: this.fenrirPath,
    });
  }

  /**
   * Create a successful result object
   */
  private createSuccessResult(exploitModule: string, result: ExploitResult, executionTime: number): PenetrationResult {
    return {
      exploitName: exploitModule,
      success: result.success,
      vulnerabilitiesFound: result.vulnerabilities_found || 0,
      executionTime,
      details: result.details || [],
      severity: determineSeverity(result.vulnerabilities_found || 0),
      recommendations: generateExploitRecommendations(exploitModule, result.vulnerabilities_found || 0),
    };
  }

  /**
   * Create an error result object
   */
  private createErrorResult(exploitModule: string, error: Error, executionTime: number): PenetrationResult {
    return {
      exploitName: exploitModule,
      success: false,
      vulnerabilitiesFound: 0,
      executionTime,
      details: { error: error.message },
      severity: "LOW",
      recommendations: [`Fix ${exploitModule} execution`],
    };
  }
}
