/**
 * üê∫ EXPLOIT RUNNER
 *
 * *snarls with predatory focus* Handles execution of individual exploits
 * with proper error handling and result parsing.
 */

import { exec } from "child_process";
import { promisify } from "util";
import path from "path";
import type { 
  ExploitOptions, 
  ExploitResult, 
  PenetrationResult, 
  VulnerabilityDetail 
} from "./penetration-types";

const execAsync = promisify(exec);

/**
 * Exploit Runner Class
 */
export class ExploitRunner {
  private fenrirPath: string;
  private config: {
    timeout: number;
    backendUrl: string;
    verbose: boolean;
    destructive: boolean;
  };

  constructor(config: {
    timeout: number;
    backendUrl: string;
    verbose: boolean;
    destructive: boolean;
  }) {
    this.config = config;
    this.fenrirPath = path.join(process.cwd(), "..", "fenrir");
  }

  /**
   * Run a specific exploit
   */
  async runExploit(
    exploitModule: string,
    options: ExploitOptions = {},
  ): Promise<PenetrationResult> {
    const startTime = Date.now();

    try {
      const pythonPath =
        process.env.PYTHON_PATH ||
        "bash -c 'source ~/venv/bin/activate && python3'";

      const quickTestFlag = options.quickTest
        ? "quick_test=True"
        : "quick_test=False";

      const command = `${pythonPath} -c "
import sys
sys.path.append('${this.fenrirPath}')
from ${exploitModule} import *
import json

# Run the exploit
exploit = ${this.getExploitClassName(exploitModule)}('${options.target || this.config.backendUrl}')
result = exploit.run_exploit(${quickTestFlag})

# Return results as JSON
print(json.dumps({
    'success': True,
    'vulnerabilities_found': len([r for r in result if hasattr(r, 'success') and r.success]),
    'details': [{'type': r.vulnerability_type, 'description': r.description, 'impact': r.impact} for r in result if hasattr(r, 'vulnerability_type')],
    'execution_time': 0
}))
"`;

      const { stdout, stderr } = await execAsync(command, {
        timeout: this.config.timeout,
        cwd: this.fenrirPath,
      });

      if (stderr && !stderr.includes("Warning")) {
        console.warn(`‚ö†Ô∏è Exploit ${exploitModule} warning: ${stderr}`);
      }

      const result: ExploitResult = JSON.parse(stdout);
      const executionTime = Date.now() - startTime;

      return {
        exploitName: exploitModule,
        success: result.success,
        vulnerabilitiesFound: result.vulnerabilities_found || 0,
        executionTime,
        details: result.details || [],
        severity: this.determineSeverity(result.vulnerabilities_found || 0),
        recommendations: this.generateExploitRecommendations(
          exploitModule,
          result.vulnerabilities_found || 0,
        ),
      };
    } catch (error) {
      console.error(`‚ùå Exploit ${exploitModule} failed:`, error);

      return {
        exploitName: exploitModule,
        success: false,
        vulnerabilitiesFound: 0,
        executionTime: Date.now() - startTime,
        details: { error: (error as Error).message },
        severity: "LOW",
        recommendations: [`Fix ${exploitModule} execution`],
      };
    }
  }

  /**
   * Get the exploit class name from module path
   */
  private getExploitClassName(modulePath: string): string {
    const parts = modulePath.split(".");
    const moduleName = parts[parts.length - 1];

    // Map of module names to actual class names
    const classMap: Record<string, string> = {
      // Fuzzing modules
      comprehensive_fuzzer: "ComprehensiveFuzzerExploit",
      endpoint_fuzzer: "EndpointFuzzerExploit",
      exploit_wrappers: "ComprehensiveFuzzerExploit",

      // SQL Injection modules
      basic_injection: "BasicInjectionExploit",
      blind_injection: "BlindInjectionExploit",
      time_based_injection: "TimeBasedInjectionExploit",
      union_injection: "UnionInjectionExploit",
      obfuscated_payloads: "ObfuscatedPayloadExploit",
      regex_bypass: "RegexBypassExploit",

      // API Exploits
      bola_attacks: "BolaAttacksExploit",
      idor_attacks: "IdorAttacksExploit",

      // CSRF Exploits
      csrf_attacks: "CsrfAttacksExploit",
      csrf_bypass: "CsrfBypassExploit",

      // Path Traversal
      basic_traversal: "BasicTraversalExploit",
      encoded_traversal: "EncodedPathTraversalExploit",
      unicode_bypass: "UnicodeBypassExploit",
      null_byte_injection: "NullByteInjectionExploit",
      double_encoding: "DoubleEncodingExploit",

      // SSRF Exploits
      ssrf_attacks: "SsrfAttacksExploit",
      ssrf_bypass: "SsrfBypassExploit",

      // Race Conditions
      race_exploits: "RaceExploitsExploit",
      concurrent_attacks: "ConcurrentAttacksExploit",

      // CORS Exploits
      cors_misconfiguration: "CorsMisconfigurationExploit",
      cors_bypass: "CorsBypassExploit",

      // HTTP Smuggling
      request_smuggling: "RequestSmugglingExploit",
      response_smuggling: "ResponseSmugglingExploit",

      // Unicode Exploits
      normalization_bypass: "NormalizationBypassExploit",
      unicode_attacks: "UnicodeAttacksExploit",

      // Rate Limiting
      rate_limit_bypass: "RateLimitBypassExploit",
      rate_limit_attacks: "RateLimitAttacksExploit",

      // JWT Exploits
      secret_key_attack: "SecretKeyVulnerabilityExploit",
      algorithm_confusion: "AlgorithmConfusionExploit",
      kid_manipulation: "KidManipulationExploit",
      jwt_replay: "JwtReplayExploit",
      jwt_injection: "JwtInjectionExploit",
    };

    // Return mapped class name or generate default
    if (classMap[moduleName]) {
      return classMap[moduleName];
    }

    // Fallback: generate class name without "Exploit" suffix
    const className = moduleName
      .split("_")
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join("");

    return className;
  }

  /**
   * Determine severity based on vulnerability count
   */
  private determineSeverity(
    count: number,
  ): "LOW" | "MEDIUM" | "HIGH" | "CRITICAL" {
    if (count >= 5) return "CRITICAL";
    if (count >= 3) return "HIGH";
    if (count >= 1) return "MEDIUM";
    return "LOW";
  }

  /**
   * Generate exploit-specific recommendations
   */
  private generateExploitRecommendations(
    exploitModule: string,
    vulnerabilityCount: number,
  ): string[] {
    if (vulnerabilityCount === 0) {
      return [`‚úÖ ${exploitModule} - No vulnerabilities found`];
    }

    const recommendations: string[] = [];

    if (exploitModule.includes("jwt")) {
      recommendations.push("üîê JWT Security Recommendations:");
      recommendations.push("  ‚Ä¢ Use persistent, secure secret keys");
      recommendations.push("  ‚Ä¢ Implement proper token rotation");
      recommendations.push("  ‚Ä¢ Add token validation middleware");
    }

    if (exploitModule.includes("sql")) {
      recommendations.push("üõ°Ô∏è SQL Injection Prevention:");
      recommendations.push("  ‚Ä¢ Use parameterized queries exclusively");
      recommendations.push("  ‚Ä¢ Implement input validation");
      recommendations.push("  ‚Ä¢ Add database access controls");
    }

    if (exploitModule.includes("path")) {
      recommendations.push("üìÅ Path Traversal Prevention:");
      recommendations.push("  ‚Ä¢ Implement proper path validation");
      recommendations.push("  ‚Ä¢ Use allowlists for file access");
      recommendations.push("  ‚Ä¢ Add file system access controls");
    }

    if (exploitModule.includes("cors")) {
      recommendations.push("üåê CORS Security:");
      recommendations.push("  ‚Ä¢ Configure specific allowed origins");
      recommendations.push("  ‚Ä¢ Avoid wildcard origins");
      recommendations.push("  ‚Ä¢ Implement proper CORS headers");
    }

    if (exploitModule.includes("rate")) {
      recommendations.push("‚ö° Rate Limiting:");
      recommendations.push("  ‚Ä¢ Implement proper rate limiting");
      recommendations.push("  ‚Ä¢ Add IP-based restrictions");
      recommendations.push("  ‚Ä¢ Monitor for bypass attempts");
    }

    return recommendations;
  }
}
