#!/usr/bin/env node

/**
 * üê∫ Workflow Shell Script Extractor
 * Extracts and validates shell scripts embedded in GitHub Actions workflows
 *
 * This tool systematically hunts down every shell script vulnerability
 * in GitHub workflow files, ensuring bulletproof CI/CD security.
 */

import fs from "fs";
import path from "path";
import { execSync } from "child_process";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Colors for output
const colors = {
  red: "\x1b[31m",
  green: "\x1b[32m",
  yellow: "\x1b[33m",
  blue: "\x1b[34m",
  magenta: "\x1b[35m",
  cyan: "\x1b[36m",
  reset: "\x1b[0m",
  bold: "\x1b[1m",
};

class WorkflowShellExtractor {
  constructor(options = {}) {
    this.workflowDir = options.workflowDir || ".github/workflows";
    this.tempDir = options.tempDir || "/tmp/workflow_shell_extraction";
    this.shellcheckRc = options.shellcheckRc || ".shellcheckrc";
    this.verbose = options.verbose || false;
    this.fixMode = options.fixMode || false;

    this.extractedScripts = [];
    this.validationResults = [];
    this.fixes = [];
  }

  log(message, color = "reset") {
    if (this.verbose || color !== "reset") {
      console.log(`${colors[color]}${message}${colors.reset}`);
    }
  }

  /**
   * Extract shell scripts from a workflow file
   */
  extractShellScripts(workflowPath) {
    this.log(`üîç Extracting shell scripts from: ${workflowPath}`, "blue");

    const content = fs.readFileSync(workflowPath, "utf8");
    const lines = content.split("\n");
    const scripts = [];

    let inScript = false;
    let scriptStartLine = 0;
    let scriptContent = [];
    let scriptName = "";

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      // Detect start of multi-line shell script
      if (line.match(/^\s*run:\s*\|/)) {
        inScript = true;
        scriptStartLine = i + 1;
        scriptContent = [];
        scriptName = `line_${i + 1}`;
        this.log(`  üìÑ Found multi-line script at line ${i + 1}`, "cyan");
        continue;
      }

      // Collect script content
      if (inScript) {
        // Remove leading spaces and the | character
        const cleanLine = line.replace(/^\s*\|\s*/, "");
        scriptContent.push(cleanLine);
      }

      // Detect end of multi-line script
      if (inScript && line.match(/^\s*[^-\s]/) && !line.match(/^\s*\|/)) {
        inScript = false;

        if (scriptContent.length > 0) {
          const script = {
            workflow: workflowPath,
            name: scriptName,
            startLine: scriptStartLine,
            endLine: i,
            content: scriptContent.join("\n"),
            type: "multiline",
          };
          scripts.push(script);
          this.log(`    ‚úÖ Extracted ${scriptContent.length} lines`, "green");
        }
        scriptContent = [];
      }
    }

    // Handle script that goes to end of file
    if (inScript && scriptContent.length > 0) {
      const script = {
        workflow: workflowPath,
        name: scriptName,
        startLine: scriptStartLine,
        endLine: lines.length,
        content: scriptContent.join("\n"),
        type: "multiline",
      };
      scripts.push(script);
      this.log(`    ‚úÖ Extracted ${scriptContent.length} lines (end of file)`, "green");
    }

    return scripts;
  }

  /**
   * Validate extracted shell script with shellcheck
   */
  validateScript(script) {
    this.log(`üîç Validating script: ${script.name}`, "blue");

    // Create temporary script file
    const tempScriptPath = path.join(this.tempDir, `${path.basename(script.workflow)}_${script.name}.sh`);

    // Ensure temp directory exists
    if (!fs.existsSync(this.tempDir)) {
      fs.mkdirSync(this.tempDir, { recursive: true });
    }

    // Write script content
    const scriptContent = `#!/bin/bash
# Extracted from ${script.workflow}:${script.startLine}
# Generated by WorkflowShellExtractor

${script.content}`;

    fs.writeFileSync(tempScriptPath, scriptContent);

    try {
      // Run shellcheck
      const result = execSync(`shellcheck --rcfile=${this.shellcheckRc} "${tempScriptPath}"`, {
        encoding: "utf8",
        stdio: "pipe",
      });

      this.log(`    ‚úÖ Valid`, "green");
      return { valid: true, issues: [], script: tempScriptPath };
    } catch (error) {
      const issues = error.stdout || error.stderr || "";
      this.log(`    ‚ùå Issues found`, "red");

      if (this.verbose) {
        console.log(issues);
      }

      return { valid: false, issues, script: tempScriptPath };
    }
  }

  /**
   * Generate fixes for shell script issues
   */
  generateFixes(script, validationResult) {
    if (validationResult.valid) {
      return [];
    }

    const fixes = [];
    const issues = validationResult.issues;

    // Parse shellcheck output and generate fixes
    const lines = issues.split("\n");
    for (const line of lines) {
      if (line.includes("SC2292")) {
        // Replace [ ] with [[ ]]
        fixes.push({
          type: "replace",
          pattern: /if \[ /g,
          replacement: "if [[ ",
          description: "Replace [ ] with [[ ]] for bash tests",
        });
        fixes.push({
          type: "replace",
          pattern: /\] /g,
          replacement: "]] ",
          description: "Replace [ ] with [[ ]] for bash tests",
        });
      }

      if (line.includes("SC2250")) {
        // Add braces around variables
        fixes.push({
          type: "replace",
          pattern: /\$([A-Za-z_][A-Za-z0-9_]*)/g,
          replacement: "${$1}",
          description: "Add braces around variable references",
        });
      }

      if (line.includes("SC2154")) {
        // Fix unassigned variables
        fixes.push({
          type: "replace",
          pattern: /\$GITHUB_OUTPUT/g,
          replacement: "${GITHUB_OUTPUT}",
          description: "Add braces around GITHUB_OUTPUT variable",
        });
      }
    }

    return fixes;
  }

  /**
   * Apply fixes to workflow file
   */
  applyFixes(workflowPath, fixes) {
    if (!this.fixMode || fixes.length === 0) {
      return false;
    }

    this.log(`üîß Applying ${fixes.length} fixes to ${workflowPath}`, "yellow");

    let content = fs.readFileSync(workflowPath, "utf8");
    let modified = false;

    for (const fix of fixes) {
      if (fix.type === "replace") {
        const newContent = content.replace(fix.pattern, fix.replacement);
        if (newContent !== content) {
          content = newContent;
          modified = true;
          this.log(`    ‚úÖ Applied: ${fix.description}`, "green");
        }
      }
    }

    if (modified) {
      fs.writeFileSync(workflowPath, content);
      this.log(`    üíæ Saved fixes to ${workflowPath}`, "green");
    }

    return modified;
  }

  /**
   * Process all workflow files
   */
  async processWorkflows() {
    this.log("üê∫ Starting workflow shell script extraction and validation...", "magenta");
    this.log("=".repeat(60), "magenta");

    // Ensure temp directory exists
    if (!fs.existsSync(this.tempDir)) {
      fs.mkdirSync(this.tempDir, { recursive: true });
    }

    // Find all workflow files
    const workflowFiles = this.findWorkflowFiles();

    if (workflowFiles.length === 0) {
      this.log("‚ùå No workflow files found", "red");
      return { success: false, scripts: [], results: [] };
    }

    this.log(`üìä Found ${workflowFiles.length} workflow files`, "blue");

    let totalScripts = 0;
    let validScripts = 0;
    let invalidScripts = 0;

    // Process each workflow file
    for (const workflowFile of workflowFiles) {
      const scripts = this.extractShellScripts(workflowFile);
      totalScripts += scripts.length;

      for (const script of scripts) {
        const validationResult = this.validateScript(script);
        this.validationResults.push({
          script,
          validation: validationResult,
        });

        if (validationResult.valid) {
          validScripts++;
        } else {
          invalidScripts++;

          // Generate and apply fixes if in fix mode
          if (this.fixMode) {
            const fixes = this.generateFixes(script, validationResult);
            if (fixes.length > 0) {
              this.applyFixes(workflowFile, fixes);
            }
          }
        }
      }
    }

    // Clean up temporary files
    this.cleanup();

    // Generate summary
    this.generateSummary(totalScripts, validScripts, invalidScripts);

    return {
      success: invalidScripts === 0,
      scripts: this.extractedScripts,
      results: this.validationResults,
      summary: {
        totalScripts,
        validScripts,
        invalidScripts,
      },
    };
  }

  /**
   * Find all workflow files
   */
  findWorkflowFiles() {
    if (!fs.existsSync(this.workflowDir)) {
      return [];
    }

    const files = fs.readdirSync(this.workflowDir);
    return files
      .filter(file => file.endsWith(".yml") || file.endsWith(".yaml"))
      .map(file => path.join(this.workflowDir, file));
  }

  /**
   * Clean up temporary files
   */
  cleanup() {
    if (fs.existsSync(this.tempDir)) {
      const files = fs.readdirSync(this.tempDir);
      for (const file of files) {
        fs.unlinkSync(path.join(this.tempDir, file));
      }
      fs.rmdirSync(this.tempDir);
    }
  }

  /**
   * Generate summary report
   */
  generateSummary(total, valid, invalid) {
    this.log("", "reset");
    this.log("üéØ Summary Report", "magenta");
    this.log("=".repeat(30), "magenta");
    this.log(`üìä Total shell scripts found: ${total}`, "blue");
    this.log(`‚úÖ Valid scripts: ${valid}`, "green");
    this.log(`‚ùå Invalid scripts: ${invalid}`, invalid > 0 ? "red" : "green");

    if (invalid > 0) {
      this.log("", "reset");
      this.log("üîß To fix issues:", "yellow");
      this.log("  1. Run with --fix flag to auto-fix common issues", "yellow");
      this.log("  2. Manually fix remaining issues in workflow files", "yellow");
      this.log("  3. Use shellcheck directly for detailed analysis", "yellow");
    } else {
      this.log("", "reset");
      this.log("üéâ All workflow shell scripts are valid!", "green");
    }
  }
}

// CLI interface
if (import.meta.url === `file://${process.argv[1]}`) {
  const args = process.argv.slice(2);
  const options = {
    verbose: args.includes("--verbose") || args.includes("-v"),
    fixMode: args.includes("--fix"),
    workflowDir: args.find(arg => arg.startsWith("--workflow-dir="))?.split("=")[1],
    tempDir: args.find(arg => arg.startsWith("--temp-dir="))?.split("=")[1],
    shellcheckRc: args.find(arg => arg.startsWith("--shellcheck-rc="))?.split("=")[1],
  };

  const extractor = new WorkflowShellExtractor(options);

  extractor
    .processWorkflows()
    .then(result => {
      process.exit(result.success ? 0 : 1);
    })
    .catch(error => {
      console.error("‚ùå Error:", error.message);
      process.exit(1);
    });
}

export default WorkflowShellExtractor;
