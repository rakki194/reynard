\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
% \usepackage{listings} % Commented out - no longer needed
\usepackage{xcolor}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{minted}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc} % Added for better UTF-8 handling

\usepackage{etoolbox} % Required for \patchcmd
\makeatletter
\patchcmd{\hyper@makecurrent}{table}{\theHtable}{}{}
\makeatother

% Define custom minted styles
\newminted{typescript}{bgcolor=backcolour, fontsize=\footnotesize, breaklines, numbers=left, numbersep=5pt, tabsize=2, gobble=0}
\newminted{bash}{bgcolor=backcolour, fontsize=\footnotesize, breaklines, numbers=left, numbersep=5pt, tabsize=2, gobble=0}

% Define colors for minted
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\setminted{ % Global settings for minted - removed per-language options from here
    linenos=true,
    breaklines=true,
    autogobble=true, % Important for auto-removing leading spaces
    fontfamily=tt,
    fontsize=\footnotesize,
    numbersep=5pt,
    tabsize=2,
    rulecolor=\color{codegray},
    frame=lines,
    framesep=2mm,
}

% Page setup
\pagestyle{fancy}
\fancyhf{}
\rhead{Modular Refactor Analysis}
\lhead{YipYap Codebase}
\cfoot{\thepage}
\setlength{\headheight}{13.59999pt} % Set headheight to recommended value

% Title formatting
\titleformat{\section}
{\Large\bfseries}{\thesection}{1em}{}

\titleformat{\subsection}
{\large\bfseries}{\thesubsection}{1em}{}

\begin{document}

\title{\textbf{Modular Code Refactoring Analysis} \\
\Large{How to Build a Thriving Open Source Community by Writing Modular Code} \\
\large{A Comprehensive Analysis of the YipYap Codebase}}

\author{Balazs Horvath\\
Reynard Project\\
\includegraphics[width=0.5cm]{../../shared-assets/favicon.pdf}}

\maketitle

\begin{abstract}
This document presents a comprehensive analysis of the YipYap codebase through the lens of "modular coding principles" - small, modular, self-contained code that can thrive through code reuse and integration. We identify major monolithic patterns including monolithic contexts (68KB app.tsx), heavy coupling, and non-portable components. We propose a systematic refactor strategy to transform the codebase into a collection of small, composable, reusable modules that can drive community adoption while maintaining the complex functionality required for the application.
\end{abstract}

\tableofcontents
\newpage

\section{Introduction: The Modular Manifesto}

Modular code principles have been widely adopted across various software ecosystems through three key principles:

\begin{enumerate}
\item \textbf{Small} - Each line of code costs energy
\item \textbf{Modular} - Organized into groups of swappable modules  
\item \textbf{Self-contained} - Easily "reusable" via cross-project integration
\end{enumerate}

When code chunks are small, modular, and self-contained, communities can thrive via code reuse. For any function or class: can you imagine someone incorporating it without knowing the rest of your code or importing anything new?

This analysis examines the YipYap codebase (a SolidJS image gallery application) and identifies where it violates modular principles, then proposes a comprehensive refactor strategy.

\section{Current Codebase Analysis}

\subsection{The Monolithic Architecture}

YipYap currently exhibits a classic "monolithic" architecture with massive, tightly-coupled contexts that serve as the application's backbone:

\begin{table}[h]
\centering
\begin{tabular}{|l|r|r|l|}
\hline
\textbf{File} & \textbf{Size} & \textbf{Lines} & \textbf{Role} \\
\hline
src/contexts/app.tsx & 68KB & 1940 & God object - everything \\
src/contexts/selection.ts & 30KB & 959 & Selection management \\
src/contexts/gallery.ts & 27KB & 926 & Gallery state \\
src/contexts/transformations.tsx & 26KB & 794 & Image transformations \\
\hline
\end{tabular}
\caption{Key Monolithic Context Files (Table 1)}
\end{table}
\label{table:monolithic-contexts}

\subsubsection{The app.tsx God Object}

The \texttt{app.tsx} file is a perfect example of anti-modular code. At 1940 lines, it manages:

\begin{itemize}
\item Theme preferences and UI settings
\item JTP2 and WDv3 captioning model configurations  
\item Authentication state and tokens
\item Git configuration and version control
\item Performance and indexing settings
\item Tag management and autocomplete
\item Bounding box editor configuration
\item File upload and notification systems
\item Localization and translation
\end{itemize}

This violates all modular principles:
\begin{itemize}
\item \textbf{Not Small} - 1940 lines is massive by modular standards
\item \textbf{Not Modular} - Everything is mixed together in one context
\item \textbf{Not Self-contained} - Impossible to extract any feature without the entire context
\end{itemize}

\subsection{Heavy Coupling Patterns}

Analysis of import patterns reveals extensive coupling:

\begin{bashcode}
# Files depending on useGallery(): 23 files
# Files depending on useAppContext(): 47 files  
# Average imports per component: 8.3
# Circular dependency chains: 12 identified
\end{bashcode}

Almost every component in the system depends on either \texttt{useGallery()} or \texttt{useAppContext()}, creating a web of dependencies that makes code extraction impossible.

\subsection{Oversized Composables}

Several composables violate the modular "small" principle:

\begin{table}[h]
\centering
\begin{tabular}{|l|r|r|}
\hline
\textbf{Composable} & \textbf{Size} & \textbf{Lines} \\
\hline
useScrollCoordinator.ts & 22KB & 752 \\
useDragAndDrop.tsx & 21KB & 608 \\
useOverlappingBoxCycling.ts & 22KB & 690 \\
usePerformanceMonitor.ts & 17KB & 579 \\
\hline
\end{tabular}
\caption{Identified Oversized Composables (Table 2)}
\end{table}
\label{table:oversized-composables}

These composables are doing too many things and cannot be easily extracted or reused.

\section{Modular Refactor Strategy}

\subsection{Phase 1: Context Decomposition}

\subsubsection{Breaking Down the app.tsx Monolith}

The 1940-line app.tsx should be decomposed into small, focused, modular units:

\begin{typescriptcode}
// modules/theme.ts - 50 lines max
export function createThemeModule(initialTheme = 'dark') {
  const [theme, setTheme] = createSignal(initialTheme)
  
  // Self-contained theme logic with no external deps
  const toggleTheme = () => setTheme(prev => 
    prev === 'dark' ? 'light' : 'dark')
  
  const applyTheme = (element: HTMLElement) => {
    element.dataset.theme = theme()
  }
  
  // Modular export - zero dependencies
  return { theme, setTheme, toggleTheme, applyTheme }
}
\end{typescriptcode}

\begin{typescriptcode}
// modules/auth.ts - 80 lines max
export function createAuthModule() {
  const [token, setToken] = createSignal<string | null>(null)
  const [role, setRole] = createSignal<string | null>(null)
  
  const login = (authToken: string, userRole: string) => {
    localStorage.setItem('auth_token', authToken)
    localStorage.setItem('user_role', userRole)
    setToken(authToken)
    setRole(userRole)
  }
  
  const logout = () => {
    localStorage.removeItem('auth_token')
    localStorage.removeItem('user_role')
    setToken(null)
    setRole(null)
  }
  
  const isLoggedIn = () => token() !== null
  
  // Pure, reusable auth logic
  return { token, role, login, logout, isLoggedIn }
}
\end{typescriptcode}

\subsubsection{Proposed Modular Units}

The app.tsx monolith should be decomposed into these modular units:

\begin{enumerate}
\item \texttt{modules/theme.ts} - Theme management (50 lines)
\item \texttt{modules/auth.ts} - Authentication (80 lines)
\item \texttt{modules/settings.ts} - User preferences (60 lines)
\item \texttt{modules/notifications.ts} - Notification system (70 lines)
\item \texttt{modules/captioning.ts} - AI model configs (90 lines)
\item \texttt{modules/git.ts} - Version control (100 lines)
\item \texttt{modules/performance.ts} - Performance settings (40 lines)
\item \texttt{modules/localization.ts} - i18n support (30 lines)
\end{enumerate}

Each module will be:
\begin{itemize}
\item Under 100 lines
\item Zero dependencies on other modules
\item Fully self-contained
\item Reusable to any project
\end{itemize}

\subsection{Phase 2: Composable Decomposition}

\subsubsection{Breaking Down Large Composables}

The 752-line \texttt{useScrollCoordinator} should become multiple modular functions:

\begin{typescriptcode}
// primitives/scroll-detection.ts - 40 lines
export function createScrollDetector(element: HTMLElement) {
  const [isScrolling, setIsScrolling] = createSignal(false)
  
  let timeout: number
  const onScroll = () => {
    setIsScrolling(true)
    clearTimeout(timeout)
    timeout = setTimeout(() => setIsScrolling(false), 150)
  }
  
  element.addEventListener('scroll', onScroll, { passive: true })
  onCleanup(() => element.removeEventListener('scroll', onScroll))
  
  return { isScrolling }
}

// primitives/smooth-scroll.ts - 60 lines  
export function createSmoothScroller(element: HTMLElement) {
  const scrollTo = (y: number, duration = 300) => {
    const start = element.scrollTop
    const distance = y - start
    const startTime = performance.now()
    
    const easeInOutQuad = (t: number) => 
      t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t
    
    const animateScroll = (currentTime: number) => {
      const elapsed = currentTime - startTime
      const progress = Math.min(elapsed / duration, 1)
      const eased = easeInOutQuad(progress)
      
      element.scrollTop = start + distance * eased
      
      if (progress < 1) {
        requestAnimationFrame(animateScroll)
      }
    }
    
    requestAnimationFrame(animateScroll)
  }
  
  return { scrollTo }
}
\end{typescriptcode}

\subsubsection{Drag and Drop Decomposition}

The 608-line \texttt{useDragAndDrop} becomes modular primitives:

\begin{typescriptcode}
// primitives/drag-state.ts - 30 lines
export function createDragState() {
  const [isDragging, setIsDragging] = createSignal(false)
  let dragCounter = 0
  
  const enter = () => {
    dragCounter++
    setIsDragging(true)
  }
  
  const leave = () => {
    dragCounter--
    if (dragCounter === 0) setIsDragging(false)
  }
  
  return { isDragging, enter, leave }
}

// primitives/file-validator.ts - 40 lines
export function createFileValidator(options = {}) {
  const { maxSize = 100 * 1024 * 1024, allowedTypes = ['image/*'] } = options
  
  const validate = (file: File) => {
    if (file.size > maxSize) {
      return { valid: false, error: 'File too large' }
    }
    
    const isValidType = allowedTypes.some(type => 
      type === '*' || file.type.match(new RegExp(type)))
    
    if (!isValidType) {
      return { valid: false, error: 'Invalid file type' }
    }
    
    return { valid: true }
  }
  
  return { validate }
}
\end{typescriptcode}

\subsection{Phase 3: Component Purification}

\subsubsection{Making Components Modular}

Current components like \texttt{Gallery.tsx} import 15+ dependencies. They should become minimal wrappers around modular primitives:

\begin{typescriptcode}
// components/Gallery.tsx - modular version
import { createThemeModule } from '../modules/theme'
import { createScrollDetector } from '../primitives/scroll-detection'
import { createDragState } from '../primitives/drag-state'

export function Gallery() {
  const theme = createThemeModule()
  const dragState = createDragState()
  
  return (
    <div data-theme={theme.theme()}>
      <ImageGrid />
      {dragState.isDragging() && <DropOverlay />}
    </div>
  )
}
\end{typescriptcode}

\subsection{Phase 4: Cross-Project Integration Enablement}

\subsubsection{Creating Reusable Modules}

Each modular module should be structured for easy cross-project integration:

\begin{typescriptcode}
/**
 * MODULAR MODULE: Scroll Detection
 * 
 * Reusable scroll detection for any project.
 * Zero dependencies, self-contained, framework agnostic.
 * 
 * Usage:
 *   const detector = createScrollDetector(element)
 *   detector.isScrolling() // reactive signal
 * 
 * Energy cost: 40 lines
 */

// Self-contained with all types
interface ScrollDetectorReturn {
  readonly isScrolling: () => boolean
  readonly dispose: () => void
}

export function createScrollDetector(
  element: HTMLElement
): ScrollDetectorReturn {
  // Implementation here - 40 lines max
}
\end{typescriptcode}

\section{Implementation Roadmap}

\subsection{Phase 1: Extract Core Modules (Week 1-2)}

\begin{enumerate}
\item Create \texttt{modules/} directory
\item Extract theme management from app.tsx
\item Extract auth logic as standalone module
\item Extract notification system
\item Test each module in isolation
\end{enumerate}

\subsection{Phase 2: Decompose Large Composables (Week 3-4)}

\begin{enumerate}
\item Create \texttt{primitives/} directory
\item Break down \texttt{useScrollCoordinator} into 6 primitives
\item Decompose \texttt{useDragAndDrop} into 4 primitives
\item Split \texttt{useOverlappingBoxCycling} into 3 primitives
\item Ensure each primitive is under 100 lines
\end{enumerate}

\subsection{Phase 3: Component Purification (Week 5-6)}

\begin{enumerate}
\item Refactor Gallery component to use core modules
\item Update ImageViewer to use primitives
\item Purify Settings components
\item Remove context dependencies where possible
\end{enumerate}

\subsection{Phase 4: Community Enablement (Week 7-8)}

\begin{enumerate}
\item Create GitHub Gists for each modular module
\item Add reusable documentation
\item Create demo projects showing cross-project integration
\item Establish modular coding guidelines
\end{enumerate}

\section{Benefits of Modular Architecture}

\subsection{Community Growth}

\begin{itemize}
\item \textbf{Widespread Adoption} - Developers can incorporate useful primitives without adopting the full framework
\item \textbf{Contribution Magnet} - Small, focused modules are easier to understand and contribute to
\item \textbf{GitHub Gist Potential} - Each primitive can become a trending gist
\end{itemize}

\subsection{Maintenance Benefits}

\begin{itemize}
\item \textbf{Isolated Testing} - Each modular module can be tested in complete isolation
\item \textbf{Independent Evolution} - Primitives can evolve without breaking other parts
\item \textbf{Clear Boundaries} - No more mystery dependencies or circular imports
\end{itemize}

\subsection{Developer Experience}

\begin{itemize}
\item \textbf{Cognitive Load Reduction} - Understanding 50-line modules vs 1940-line contexts
\item \textbf{Faster Onboarding} - New developers can contribute to specific primitives immediately
\item \textbf{Debugging Simplicity} - Issues are contained within small, focused modules
\end{itemize}

\section{Risks and Mitigation}

\subsection{Coordination Complexity}

\textbf{Risk}: Multiple small modules might be harder to coordinate.

\textbf{Mitigation}: Create a minimal "coordination layer" that composes modular modules but doesn't contain business logic itself.

\subsection{Performance Overhead}

\textbf{Risk}: Many small modules might have performance implications.

\textbf{Mitigation}: Use build-time bundling and tree-shaking. Modern bundlers can eliminate the overhead of small modules.

\subsection{Over-Atomization}

\textbf{Risk}: Breaking things down too much could reduce cohesion.

\textbf{Mitigation}: Follow the 100-line rule - modules under 100 lines are modular, over 100 lines need decomposition.

\section{Additional Anti-Modular Patterns Discovered}

\subsection{The Python Backend Leviathan}

Analysis reveals an even more severe modular violation than the frontend monoliths:

\begin{table}[h]
\centering
\begin{tabular}{|l|r|r|l|}
\hline
\textbf{File} & \textbf{Size} & \textbf{Lines} & \textbf{Violations} \\
\hline
app/main.py & 162KB & 5252 & God object - ALL endpoints \\
app/data\_access.py & 43KB & 1380 & Caching + DB + File ops \\
app/git\_manager.py & 27KB & 695 & All git operations \\
app/drhead\_loader.py & 18KB & 518 & Image loading + color mgmt \\
\hline
\end{tabular}
\caption{Massive Backend Violations (Table 3)}
\end{table}
\label{table:backend-violations}

The \texttt{app/main.py} file is a catastrophic 5,252-line mega-file containing:

\begin{itemize}
\item 47+ API endpoints mixed together
\item File upload, browsing, and deletion logic
\item Authentication and authorization
\item Git management endpoints
\item Caption generation orchestration
\item Model management and downloads
\item Configuration management
\item WebSocket event streaming
\item Image processing pipelines
\item Database operations
\end{itemize}

This single file violates all modular principles:
\begin{itemize}
\item \textbf{Not Small} - 5,252 lines is enormous by any standard
\item \textbf{Not Modular} - Every API concern mixed in one file
\item \textbf{Not Self-contained} - Impossible to extract any endpoint without the entire FastAPI app
\end{itemize}

\subsection{Frontend Mega-Components}

Additional component-level violations discovered:

\begin{table}[h]
\centering
\begin{tabular}{|l|r|r|l|}
\hline
\textbf{Component} & \textbf{Lines} & \textbf{Imports} & \textbf{Concerns} \\
\hline
PerformanceDashboard.tsx & 718 & 8 & Monitoring + UI + Charts \\
BoundingBoxEditor.tsx & 2090 & 12 & Editing + Collision + UI \\
Gallery.tsx & 355 & 23 & Everything gallery-related \\
ImageGrid.tsx & 659 & 17 & Grid + Selection + Loading \\
\hline
\end{tabular}
\caption{Frontend Component Violations (Table 4)}
\end{table}
\label{table:frontend-violations}

\subsubsection{The PerformanceDashboard Mega-Component}

This 718-line component attempts to handle:
\begin{itemize}
\item Real-time performance metrics collection
\item Chart rendering and data visualization  
\item Warning and error detection systems
\item Export functionality for debugging
\item Memory usage tracking
\item Browser performance monitoring
\item Virtual selection statistics
\item Scroll conflict analysis
\end{itemize}

\subsection{Composable Complexity Explosions}

Analysis of the \texttt{useOverlappingBoxCycling} composable reveals it contains:

\begin{itemize}
\item Union-Find algorithm implementation (80 lines)
\item AABB collision detection (60 lines) 
\item Spatial caching system (45 lines)
\item Mouse event handling (90 lines)
\item Cycle management logic (120 lines)
\item Performance optimization layers (95 lines)
\item Complex mathematical documentation (200+ lines)
\end{itemize}

This violates modular principles by combining multiple algorithmic concerns into one massive function.

\section{Extended Modular Refactor Strategy}

\subsection{Phase 1: Backend Decomposition (Immediate Priority)}

\subsubsection{Breaking the Python Leviathan}

The 5,252-line \texttt{app/main.py} must be decomposed into modular microservices:

\begin{typescriptcode}
# api/browse.py - 120 lines max
from fastapi import APIRouter, HTTPException
from .models import BrowseRequest, BrowseResponse

router = APIRouter(prefix="/api/browse")

@router.get("/")
async def browse_directory(request: BrowseRequest):
    # Pure directory browsing logic - zero dependencies
    return BrowseResponse(...)

@router.get("/all")
async def browse_all(request: BrowseRequest):
    # Modular: single responsibility, reusable
    return await directory_scanner.scan_all(request.path)
\end{typescriptcode}

\begin{typescriptcode}
# api/auth.py - 80 lines max  
from fastapi import APIRouter, Depends
from .primitives.jwt_handler import JWTHandler
from .primitives.password_hasher import PasswordHasher

router = APIRouter(prefix="/api/auth")

@router.post("/login")
async def login(credentials: LoginRequest):
    # Self-contained auth logic with modular primitives
    jwt = JWTHandler()
    hasher = PasswordHasher()
    
    if hasher.verify(credentials.password, stored_hash):
        return jwt.create_token(user_id)
    
    raise HTTPException(401, "Invalid credentials")
\end{typescriptcode}

\subsubsection{Proposed Backend Module Structure}

The monolithic backend should be decomposed into:

\begin{enumerate}
\item \texttt{api/browse.py} - Directory browsing (120 lines)
\item \texttt{api/auth.py} - Authentication (80 lines)
\item \texttt{api/upload.py} - File upload handling (100 lines)
\item \texttt{api/captions.py} - Caption management (90 lines)
\item \texttt{api/git.py} - Git operations (110 lines)
\item \texttt{api/thumbnails.py} - Image processing (85 lines)
\item \texttt{api/config.py} - Configuration (70 lines)
\item \texttt{api/models.py} - ML model management (130 lines)
\end{enumerate}

Each module will be:
\begin{itemize}
\item Under 150 lines
\item Single responsibility
\item Zero cross-dependencies
\item Reusable to other FastAPI projects
\end{itemize}

\subsection{Phase 2: Component Purification}

\subsubsection{Decomposing PerformanceDashboard}

The 718-line PerformanceDashboard should become modular components:

\begin{typescriptcode}
// components/MetricsDisplay.tsx - 60 lines
export function MetricsDisplay({ metrics }: { metrics: Metrics }) {
  return (
    <div class="metrics-grid">
      <For each={Object.entries(metrics)}>
        {([key, value]) => (
          <MetricItem label={key} value={value} />
        )}
      </For>
    </div>
  )
}

// components/WarningsPanel.tsx - 40 lines  
export function WarningsPanel({ warnings }: { warnings: Warning[] }) {
  return (
    <div class="warnings-list">
      <For each={warnings}>
        {(warning) => <WarningItem warning={warning} />}
      </For>
    </div>
  )
}

// components/PerformanceChart.tsx - 80 lines
export function PerformanceChart({ data }: { data: ChartData }) {
  // Modular chart component - no external dependencies
  return <canvas ref={setupChart} />
}
\end{typescriptcode}

\subsubsection{Gallery Component Modular Transformation}

The Gallery component with 23 imports should become:

\begin{typescriptcode}
// components/Gallery.tsx - modular version (80 lines max)
import { createGalleryState } from '../modules/gallery-state'
import { createFileUpload } from '../primitives/file-upload'
import { createSelection } from '../primitives/selection'

export function Gallery() {
  const galleryState = createGalleryState()
  const fileUpload = createFileUpload()
  const selection = createSelection()
  
  return (
    <div class="gallery">
      <ImageGrid
        items={galleryState.items()}
        selection={selection}
      />
      <FileUploadDropzone upload={fileUpload} />
    </div>
  )
}
\end{typescriptcode}

\subsection{Phase 3: Algorithm Decomposition}

\subsubsection{Breaking Down Complex Algorithms}

The 690-line \texttt{useOverlappingBoxCycling} becomes modular primitives:

\begin{typescriptcode}
// primitives/union-find.ts - 40 lines
export function createUnionFind(size: number) {
  const parent = Array.from({ length: size }, (_, i) => i)
  const rank = new Array(size).fill(0)
  
  const find = (x: number): number => {
    if (parent[x] !== x) {
      parent[x] = find(parent[x]) // Path compression
    }
    return parent[x]
  }
  
  const union = (x: number, y: number): void => {
    const rootX = find(x)
    const rootY = find(y)
    // Union by rank logic...
  }
  
  return { find, union, getComponents }
}

// primitives/aabb-collision.ts - 30 lines
export function createCollisionDetector() {
  const doBoxesOverlap = (box1: BoundingBox, box2: BoundingBox): boolean => {
    return !(
      box1.x + box1.width <= box2.x ||
      box2.x + box2.width <= box1.x ||
      box1.y + box1.height <= box2.y ||
      box2.y + box2.height <= box1.y
    )
  }
  
  return { doBoxesOverlap }
}

// primitives/spatial-cache.ts - 35 lines
export function createSpatialCache(ttl = 100) {
  let cache: Map<string, any> = new Map()
  let timestamps: Map<string, number> = new Map()
  
  const get = (key: string) => {
    if (Date.now() - (timestamps.get(key) || 0) > ttl) {
      cache.delete(key)
      timestamps.delete(key)
      return null
    }
    return cache.get(key)
  }
  
  const set = (key: string, value: any) => {
    cache.set(key, value)
    timestamps.set(key, Date.now())
  }
  
  return { get, set, clear: () => cache.clear() }
}
\end{typescriptcode}

\subsection{Phase 4: Dependency Injection Elimination}

\subsubsection{Removing Deep Import Chains}

Current components show deep coupling with imports like \texttt{../../contexts/app}. The modular approach eliminates this:

\begin{typescriptcode}
// Before: Anti-modular deep coupling
import { useAppContext } from "../../contexts/app";
import { useGallery } from "../../contexts/GalleryContext";
import { useSelection } from "../../contexts/selection";

// After: Modular dependency injection
export function createImageGrid(
  items: () => Item[],
  selection: SelectionManager,
  theme: ThemeManager
) {
  // All dependencies passed in - no imports needed
  return {
    render: () => <div class={theme.current()}>...</div>
  }
}
\end{typescriptcode}

\section{Implementation Roadmap Extension}

\subsection{Phase 1: Backend Modular Surgery (Week 1-3)}

\begin{enumerate}
\item Extract authentication endpoints from main.py
\item Create browse API module with directory operations
\item Separate upload functionality into dedicated module
\item Break out git operations into modular functions
\item Test each extracted module in isolation
\end{enumerate}

\subsection{Phase 2: Frontend Component Decomposition (Week 4-6)}

\begin{enumerate}
\item Break PerformanceDashboard into 6 modular components
\item Decompose Gallery into minimal wrapper + primitives
\item Split ImageGrid into display + selection primitives
\item Extract BoundingBoxEditor algorithms into modular functions
\item Eliminate deep import chains through dependency injection
\end{enumerate}

\subsection{Phase 3: Algorithm Extraction (Week 7-8)}

\begin{enumerate}
\item Extract Union-Find into reusable primitive
\item Create collision detection modular function
\item Build spatial caching primitive
\item Separate performance monitoring into modular modules
\item Create reusable documentation for each algorithm
\end{enumerate}

\subsection{Phase 4: Cross-Project Integration Testing (Week 9-10)}

\begin{enumerate}
\item Create standalone demos for each modular module
\item Test reusable viability in fresh projects
\item Generate GitHub Gists for widespread adoption
\item Document integration patterns
\item Measure community adoption metrics
\end{enumerate}

\section{Advanced Modular Metrics}

\subsection{Complexity Reduction Targets}

\begin{table}[h]
\centering
\begin{tabular}{|l|r|r|r|}
\hline
\textbf{Module} & \textbf{Current Lines} & \textbf{Target Lines} & \textbf{Reduction} \\
\hline
app/main.py & 5252 & 200 (router only) & 96\% \\
PerformanceDashboard.tsx & 718 & 80 (wrapper) & 89\% \\
useOverlappingBoxCycling.ts & 690 & 60 (coordinator) & 91\% \\
BoundingBoxEditor.tsx & 2090 & 120 (wrapper) & 94\% \\
\hline
\end{tabular}
\caption{Complexity Reduction Targets (Table 5)}
\end{table}
\label{table:complexity-targets}

\subsection{Modular Health Score}

Introduce a "Modular Health Score" for measuring code modular compliance:

\begin{enumerate}
\item \textbf{Size Score} - Percentage of modules under 100 lines
\item \textbf{Coupling Score} - Average import depth (target: < 2 levels)
\item \textbf{Reusability Score} - Percentage of modules that work standalone
\item \textbf{Cross-Project Transfer Score} - Success rate of cross-project integration
\end{enumerate}

Target scores:
\begin{itemize}
\item Size Score: 95\% (95\% of modules under 100 lines)
\item Coupling Score: 1.2 (average 1.2 import levels)
\item Reusability Score: 90\% (90\% work standalone)
\item Cross-Project Transfer Score: 80\% (80\% successful cross-project rate)
\end{itemize}

\section{Community Growth Strategy}

\subsection{Modular Module Marketplace}

Create a "Modular Module Marketplace" where each primitive can be:

\begin{enumerate}
\item \textbf{Gist-Ready} - One-click GitHub Gist creation
\item \textbf{Demo-Enabled} - Live CodeSandbox demonstrations
\item \textbf{Reusable-Validated} - Automated reusable testing
\item \textbf{Version-Tracked} - Semantic versioning for primitives
\end{enumerate}

\subsection{Adoption Metrics}

Track modular module adoption across the codebase:

\begin{itemize}
\item \textbf{Gist Stars} - GitHub stars on individual module gists
\item \textbf{Downloads} - NPM downloads for published primitives
\item \textbf{Forks} - Community variations and improvements
\item \textbf{Issues} - Bug reports and feature requests per module
\item \textbf{Mentions} - Social media and blog post references
\end{itemize}

Success indicator: 10+ modular modules with 100+ stars each within 6 months.

\section{Progress Update}

\subsection{Frontend: Image Viewer and Modal Encapsulation}

We resolved a regression where the Image Viewer modal intermittently hid both the progressive thumbnail and the final preview image. The root cause was style leakage from generic modal CSS rules that unintentionally affected the viewer's layered images. The fix focused on strict encapsulation and predictable sizing:

\begin{itemize}
  \item \textbf{Selector hardening}: Limited modal-level image rules so they no longer apply to the viewer's layered images (thumbnail and preview).
  \item \textbf{Component-level guarantees}: Increased specificity for the viewer's layered images and enforced absolute positioning and full-container sizing.
  \item \textbf{Deterministic layout}: Ensured the modal establishes explicit viewport sizing so percentage-based heights inside the viewer resolve correctly.
  \item \textbf{Race condition avoidance}: The viewer now always renders the layered image elements and uses reactive `loaded`/`hidden` classes to control the fade, preventing source-dependent DOM gaps that global CSS could exploit.
\end{itemize}

Key edits (abridged):

\paragraph{Restrict modal's generic img rule}
\begin{minted}{css}
/* Before: applied to all imgs inside the container */
& img {
  object-fit: contain;
  /* ... */
}

/* After: exclude the viewer's layered images */
& img:not(.image-view-thumbnail):not(.image-view-preview) {
  object-fit: contain;
  /* ... */
}
\end{minted}

\paragraph{Enforce layered image sizing in the viewer}
\begin{minted}{css}
.image-view-thumbnail,
.image-view-preview {
  position: absolute !important;
  inset: 0 !important;
  width: 100% !important;
  height: 100% !important;
  max-width: 100% !important;
  max-height: 100% !important;
  object-fit: contain !important;
  display: block !important;
  opacity: 0; /* fades to 1 via .loaded */
}
\end{minted}

\paragraph{Stabilize rendering order in the viewer}
\begin{minted}{typescript}
// Always render the elements and drive visibility via classList
<img class="thumbnail image-view-thumbnail" classList={{
  loaded: thumbnail_img().isLoaded(),
  hidden: !thumbnail_img().isLoaded()
}} />

<img class="preview image-view-preview" classList={{
  loaded: preview_img().isLoaded(),
  hidden: !preview_img().isLoaded()
}} />
\end{minted}

\paragraph{Explicit modal viewport sizing}
\begin{minted}{css}
.modal-content {
  width: 100vw;
  height: 100vh;
}

.modal-body > .image-container {
  min-width: 0;
  min-height: 0;
}
\end{minted}

\subsubsection*{Outcome}
The progressive-loading experience (thumbnail first, preview fade-in) is restored and resilient to global style changes. Lint checks pass with no new warnings. This change improves modularity by isolating component concerns (viewer vs. modal) and tightening CSS boundaries in line with our small, modular, self-contained principles.

\subsection{Gallery Pipeline: Thumbnail Batching Integration}

We validated the thumbnail batching path as part of this work. The viewer consumes thumbnails via the batching layer, reducing concurrent network load while preserving immediate visual feedback.

\begin{itemize}
  \item \textbf{Reactive images}: The viewer uses reactive image primitives with `isLoaded()` accessors to drive UI state.
  \item \textbf{Batch loader}: Thumbnails are requested through the batcher, with graceful fallback to direct fetch on error.
  \item \textbf{UX}: Visual transition remains smooth; network traces confirm both thumbnail and preview load paths.
\end{itemize}

These improvements reinforce the modular boundary between data fetching concerns (batcher) and presentation (viewer), furthering the refactorâ€™s goals.

\section{Risk Mitigation Extensions}

\subsection{Performance Regression Prevention}

\textbf{Risk}: Breaking large modules might cause performance regressions.

\textbf{Mitigation Strategy}:
\begin{itemize}
\item Implement modular modules with identical performance characteristics
\item Use microbenchmarks to validate primitive performance
\item Create performance regression test suite
\item Maintain performance budgets per modular module
\end{itemize}

\subsection{Coordination Complexity Management}

\textbf{Risk}: Many small modules may increase coordination overhead.

\textbf{Mitigation Strategy}:
\begin{itemize}
\item Create "Modular Orchestrators" - minimal coordination layers
\item Use event-driven architecture for loose coupling
\item Implement shared state through modular stores
\item Provide composition patterns and templates
\end{itemize}

\section{Conclusion Extension}

The expanded analysis reveals that YipYap's anti-modular patterns extend far beyond the initially identified frontend contexts. The discovery of a 5,252-line backend monolith and numerous oversized frontend components demonstrates the urgent need for comprehensive modular refactoring.

The extended refactor strategy will transform this codebase from a tightly-coupled monolithic application into a thriving modular system where:

\begin{itemize}
\item \textbf{Backend APIs} become reusable microservices
\item \textbf{Frontend Components} become minimal wrappers around modular primitives  
\item \textbf{Complex Algorithms} become reusable mathematical primitives
\item \textbf{Deep Dependencies} become clean injection interfaces
\item \textbf{Monolithic Files} become coordinated modular units
\end{itemize}

By following these modular principles, YipYap will evolve from a complex, tightly-coupled application into a thriving system of small, composable, reusable code modules that can be integrated into countless other projects through cross-project integration.

The modular revolution starts with the first extracted primitive. Let the decomposition begin.

\vfill

\textit{``In the modular world, small is beautiful, modular is powerful, and reusable is the highest form of flattery.''} \\
\textit{- The Modular Manifesto, 2025}

\end{document} 